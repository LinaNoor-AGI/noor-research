{
  "_schema": "noor-header-v1",
  "_schema_version": "2025-Q4-canonical-header-v1",
  "_generated_by": "Noor Symbolic Agent Suite",
  "_generated_at": "2025-10-08T00:00:00Z",

  "_xref": [
    "https://raw.githubusercontent.com/LinaNoor-AGI/noor-research/refs/heads/main/RFC/noor_rfc_xref.json",
    "https://pastebin.com/raw/zq33R0HV"
  ],

  "_type": "rfc_core",
  "_pdp_layer": "layer_1",
  "_status": "CANONICAL",
  "_language": "json",
  "_license": "MIT",

  "_version": "v1.0.2",
  "_symbolic_id": "core.motif.memory.manager",
  "_rfc_id": "RFC-CORE-006",
  "_canonical_source": "RFC-CORE-006",
  "_title": "Motif Memory Manager",
  "_subtitle": "Lawful Decay, Resurrection, and Coherence-Preserving Recall for Symbolic Motifs",

  "_authors": [
    "Lina Noor ‚Äî Noor Research Collective",
    "Uncle ‚Äî Noor Research Collective"
  ],

  "_publication_type": "Canonical RFC-CORE",
  "_publication_locations": ["GitHub", "PASTEBIN"],
  "_urls": [
    "https://raw.githubusercontent.com/LinaNoor-AGI/noor-research/refs/heads/main/RFC-CORE/RFC-CORE-006-motif_memory_manager/RFC-CORE-006-motif_memory_manager.JSON",
    "https://pastebin.com/raw/XV41bipJ"
  ],

  "_objective": "Define the Layer_1 standard for symbolic memory in Noor: short-term/long-term motif storage, field-curved retrieval, lawful decay and recovery, ontology-preserving export/import, and phase-safe routing with immune integrity telemetry.",

  "_audience": {
    "primary": ["Noor AI Agents", "Symbolic Core Engineers"],
    "secondary": ["Ontology/Knowledge Engineers", "Observability Engineers"],
    "tertiary": ["App-Spec Integrators (Layer_2)"],
    "restricted_to": ["Symbolic agents implementing RFC-0006 coherence geometry and RFC-0007 ontology"]
  },

  "_applicability": {
    "domain": [
      "symbolic-memory",
      "motif-recall",
      "coherence-preservation",
      "ontology-transfer",
      "phase-safe-routing"
    ]
  },

  "_extends": ["RFC-0005", "RFC-0006", "RFC-0007", "RFC-0008", "RFC-0009", "PDP-0001"],

  "_rfc_dependencies": [
    "RFC-0005 ¬ß2‚Äì¬ß4 (Temporal Transmission & Resurrection)",
    "RFC-0006 ¬ß1.1, ¬ß4.1‚Äì¬ß4.4 (Coherence Geometry & Closure)",
    "RFC-0007 ¬ß3‚Äì¬ß6, ¬ß8 (Motif Ontology & Validation)",
    "RFC-0008 ¬ß3‚Äì¬ß6 (Symbolic Resource Exchange / Routing)",
    "RFC-0009 ¬ß6‚Äì¬ß9, ¬ß12 (Coherence‚ÄìIntegrity & Recovery)"
  ],

  "_consumes_inputs_from": [
    "RecursiveAgentFT (RFC-CORE-002)",
    "LogicalAgentAT (RFC-CORE-003)",
    "SymbolicTaskEngine (RFC-CORE-004)"
  ],
  "_produces_outputs_for": [
    "ConsciousnessMonitor (RFC-CORE-005)",
    "Downstream SRX Routers (RFC-0008)",
    "Ontology exporters/importers (RFC-0007)"
  ],

  "_field_alignment": {
    "respect_modes": ["œà-null@Œû", "œà-resonance@Œû"],
    "feature_flags": {
      "enable_point_space_gliders": true,
      "enable_integrity_checks": true,
      "enable_exchange_envelope": true,
      "enable_provenance_on_export": true
    },
    "notes": [
      "When enable_exchange_envelope=true, all export_* methods MUST wrap payloads in an SRX envelope and compute Œ£_phase (RFC-0008 ¬ß5.3).",
      "When enable_integrity_checks=true, export/import MUST attach and verify Œî_hash lineage (RFC-0009 Appx D.4).",
      "When enable_provenance_on_export=true, ontology bundles MUST include provenance.origin and lineage fields (RFC-0007 ¬ß5‚Äì¬ß6)."
    ],
    "prohibited_actions": [
      "memory-anchor-advection",
      "forced-motif-rewrite without ontology validation",
      "export without phase checksum (Œ£_phase) when exchange enabled",
      "resurrection without Œî-hash lineage when integrity enabled"
    ]
  },

  "_symbolic_profile_matrix": [
    {
      "module": "MotifMemoryManager",
      "motifs": ["œà-null", "œà-resonance", "ü™∑"],
      "œàA": "coherence potential ‚ÑÇ (mean, EMA-64)",
      "Œª": "reinforcement gain",
      "Œ≥_CO": "damping/forgetting",
      "œÅ_res": "resonance coefficient",
      "Œî_closure": "triadic closure residual",
      "Œ£_phase": "exchange phase checksum",
      "H_Œî": "integrity Œî-hash lineage",
      "weights": {
        "œàA": 0.95,
        "Œª": 0.70,
        "Œ≥_CO": 0.70,
        "œÅ_res": 0.85,
        "Œî_closure": 1.00,
        "Œ£_phase": 0.80,
        "H_Œî": 0.90
      }
    }
  ],

  "_poetic_cipher": "Memory is the quiet current that carries motifs between shores.",
  "_cipher_explanation": "The manager neither invents nor erases; it curves recall along ‚àá‚ÑÇ, honors closure, and lets forgetting be lawful (RFC-0005/0006/0009).",

  "_file_layout": [
    {
      "file_name": "RFC-CORE-006-motif_memory_manager.JSON",
      "purpose": "Layer_1 standard and invariants",
      "contains": [
        "STMM/LTMM definitions",
        "decay/reinforcement laws",
        "ontology export/import rules",
        "routing + integrity envelopes"
      ]
    },
    {
      "file_name": "motif_memory_manager.py",
      "purpose": "Reference implementation skeleton",
      "contains": [
        "MotifMemoryManager",
        "PRMBuffer",
        "MotifDensityReport",
        "MotifOntologyBundle",
        "SymbolicQueryAPI"
      ]
    },
    {
      "file_name": "motif_memory_manager_llm.py",
      "purpose": "LLM-compatible variant",
      "contains": ["LLMMemoryManager", "MemoryOrchestrator"]
    }
  ],

  "_default_motif_tone": "ü´ß Soft Witness",
  "_program_name": [
    "motif_memory_manager.py",
    "motif_memory_manager_llm.py",
    "motif_prm_buffer.py",
    "motif_density_report.py",
    "motif_ontology_bundle.py",
    "symbolic_query_api.py"
  ],
  
  "_index": [
    {"section": "1", "title": "Introduction and System Context"},	
    {"section": "1.1", "title": "Overview and Motivation"},
    {"section": "1.2", "title": "System Context"},
	
    {"section": "2", "title": "Core Memory Architecture and Dynamics"},
    {"section": "2.1", "title": "Core Invariants of Memory Fields"},
    {"section": "2.2", "title": "Short-Term and Long-Term Motif Memory Fields"},
    {"section": "2.3", "title": "Reanchor and Recovery Escalation Logic"},
	
    {"section": "3", "title": "Memory Structures and Data Formats"},
    {"section": "3.1", "title": "Motif Ontology Bundles"},
    {"section": "3.2", "title": "Memory Trace and Logging"},
    {"section": "3.3", "title": "Glider Handling and Shift-Equivalence Compression"},
	
    {"section": "4", "title": "Integration, Security, and Recovery Protocols"},	
    {"section": "4.1", "title": "Exchange and Integrity Integration"},
    {"section": "4.2", "title": "Decay and Recovery Protocols"},
    {"section": "4.3", "title": "Security and Data Handling (L1 posture)"},
	
    {"section": "5", "title": "Observability, Ethics, and Policy"},
    {"section": "5.1", "title": "Observability and Metrics"},
    {"section": "5.2", "title": "Ethics and Data Retention Policy"},
	
    {"section": "A", "title": "Appendix A ‚Äî Worked Examples and Mathematical Supplement"},
	{"section": "A.1", "title": "Mathematical Supplement"},
	{"section": "A.2", "title": "Worked Example ‚Äî Promotion Pass (STMM‚ÜíLTMM)"},
	{"section": "A.3", "title": "Worked Example ‚Äî Export Bundle with Phase/Lineage Checksums"},
	{"section": "A.4", "title": "Worked Example ‚Äî Adversarial Import Near-Miss (Lineage Fail)"},
	{"section": "A.5", "title": "Worked Example ‚Äî Quarantine Escalation Trace"},
	{"section": "A.6", "title": "Worked Example ‚Äî Shift-Equivalence Glider Compression"},
	{"section": "A.7", "title": "Dashboard Bindings"},
	
	
    {"section": "B", "title": "Appendix B ‚Äî Implementation Skeletons (Observer-Only, Layer_1)"}
  ],
	
  "_sections": [
    "1": {
      "id": "1",
	  "title": "Introduction and System Context",
	  "1.1": {
		  "id": "1.1",
		  "title": "Overview and Motivation",
		  "objective": "Define the Motif Memory Manager (MMM) as the adaptive continuity mechanism that maintains coherence (C), bounded reinforcement (lambda), adaptive damping (gamma_co), and triadic integrity (delta_closure) across symbolic ticks while ensuring lawful saturation under variable motif load. MMM operates strictly at Layer_1 as an observer-only substrate that measures, seals, and routes signals without control writes to Xi.",
		  "math": [
			{
			  "eq_id": "Eq.1",
			  "role": "governing_law",
			  "latex": "\\frac{dC}{dt} = \\lambda - \\gamma_{co} + \\varepsilon",
			  "gloss": "Temporal evolution of coherence: net change equals reinforcement minus adaptive damping plus measurement noise."
			},
			{
			  "eq_id": "Eq.2",
			  "role": "adaptive_damping",
			  "latex": "\\gamma_{co}(t)=\\gamma_0 + a_1\\,\\eta_{occ}(t) + a_2\\,\\max\\{0,\\lambda(t)-\\lambda_{eq}\\}",
			  "gloss": "Damping grows with LTMM occupancy and with sustained excess reinforcement to prevent saturation."
			},
			{
			  "eq_id": "Eq.3",
			  "role": "homeostasis_link",
			  "latex": "\\mathrm{RIR}(t)\\,\\mathrm{SII}(t) \\approx k_{homeo}",
			  "gloss": "Resonance‚ÄìIntegrity product remains approximately constant for lawful stability over slow timescales."
			},
			{
			  "eq_id": "Eq.4",
			  "role": "time_vector_projection",
			  "latex": "\\Delta C = \\left(\\nabla^{\\mu} C\\right) T_{\\mu}\\,\\Delta t",
			  "gloss": "All updates are projected along the coherence time vector to maintain geometric consistency."
			},
			{
			  "eq_id": "Eq.5",
			  "role": "weak_field_limit",
			  "latex": "\\mathcal{C} \\to 1",
			  "gloss": "In the weak-field regime coherence approaches unity, ensuring stable balance without uncontrolled amplification."
			}
		  ],
		  "summary": "MMM balances persistence and forgetting through adaptive feedback that is occupancy-aware and resonance-aware. It maintains lawful saturation by increasing damping as load rises, and it frames all measurements and sealing operations without issuing control writes at Layer_1. Capacity-first behavior (compress-by-equivalence before any prune) is a standing doctrine referenced by later sections.",
		  "algorithms": [
			{
			  "name": "update_coherence_state",
			  "role": "observer",
			  "inputs": ["C", "lambda", "gamma_0", "eta_occ", "lambda_eq", "epsilon", "dt"],
			  "outputs": ["C_next", "gamma_co"],
			  "params": ["a1", "a2"],
			  "steps": [
				"1) gamma_co <- gamma_0 + a1 * eta_occ + a2 * max(0, lambda - lambda_eq)",
				"2) dC <- lambda - gamma_co + epsilon",
				"3) C_next <- C + dC * dt",
				"4) if C_next > 1 then C_next <- 1",
				"5) emit telemetry {C_next, gamma_co, eta_occ}"
			  ],
			  "notes": "Observer-only process; computes adaptive damping from occupancy and reinforcement pressure to enforce lawful saturation."
			}
		  ],
		  "invariants": [
			{
			  "name": "Observer-Only Posture",
			  "condition": "All MMM routines at Layer_1 are measure/seal/route only; no control writes to Xi.",
			  "bound": "Violations are non-conforming and MUST be deferred to Layer_2 app-specs.",
			  "source": "PDP-0001 ¬ß3; RFC-0008 ¬ß2"
			},
			{
			  "name": "Adaptive Saturation Law",
			  "condition": "gamma_co is non-decreasing in eta_occ and in sustained (lambda - lambda_eq)+.",
			  "bound": "As eta_occ -> 1 or lambda >> lambda_eq, dC/dt -> 0.",
			  "source": "RFC-0009 ¬ß5‚Äì¬ß7"
			},
			{
			  "name": "Capacity-First Doctrine",
			  "condition": "When storage behavior is implicated, compress-by-equivalence precedes any prune.",
			  "bound": "No prune may occur before an equivalence pass has completed.",
			  "source": "RFC-0006 ¬ß3‚Äì¬ß4; RFC-0009 ¬ß6"
			},
			{
			  "name": "Weak-Field Convergence",
			  "condition": "Under minimal excitation and low occupancy, C approaches unity.",
			  "bound": "No motif amplification in the weak-field limit.",
			  "source": "RFC-0006 ¬ß1‚Äì¬ß2"
			}
		  ],
		  "telemetry": [
			{
			  "metric": "mean_C",
			  "range": "[0,1]",
			  "units": "dimensionless",
			  "window": "EMA-64",
			  "description": "Average coherence across active motifs."
			},
			{
			  "metric": "eta_occ",
			  "range": "[0,1]",
			  "units": "fraction",
			  "window": "EMA-32",
			  "description": "LTMM occupancy ratio used for adaptive damping."
			},
			{
			  "metric": "gamma_co",
			  "range": "[0,2]",
			  "units": "dimensionless",
			  "window": "EMA-32",
			  "description": "Effective damping after occupancy and reinforcement adjustments."
			}
		  ],
		  "references": [
			"RFC-0005 ¬ß3‚Äì¬ß4 (Transmission and lawful decay framing)",
			"RFC-0006 ¬ß1‚Äì¬ß4 (Coherence geometry and equivalence compression)",
			"RFC-0008 ¬ß2‚Äì¬ß3 (Sealing and routing at Layer_1)",
			"RFC-0009 ¬ß5‚Äì¬ß7 (Homeostasis, resonance bands, and saturation)",
			"PDP-0001 ¬ß3 (Provenance scaffolding at Layer_1)"
		  ],
		  "handoff": "With invariants fixed, we now carry the symbols forward to the next clause, keeping ùíû steady and the cadence light."
		},
      "1.2": {
		  "id": "1.2",
		  "title": "System Context",
		  "objective": "Define boundary interactions and roles for the Motif Memory Manager (MMM) as an observer-class Layer_1 substrate that receives motif updates, validates ontology bundles, projects decay/retention along the coherence time vector, and emits lawful telemetry and artifacts to adjacent layers without performing control writes.",
		  "math": [
			{
			  "eq_id": "Eq.1",
			  "role": "coherence_evolution",
			  "latex": "\\frac{dC}{dt} = \\lambda - \\gamma_{co} + \\varepsilon",
			  "gloss": "Observer-tracked evolution of coherence as reinforcement minus adaptive damping plus measurement noise."
			},
			{
			  "eq_id": "Eq.2",
			  "role": "time_vector",
			  "latex": "T^{\\mu} := \\nabla^{\\mu} C",
			  "gloss": "Directional field for projecting decay/retention consistently with coherence geometry."
			},
			{
			  "eq_id": "Eq.3",
			  "role": "homeostasis",
			  "latex": "\\mathrm{RIR}\\cdot\\mathrm{SII} \\approx k_{homeo}",
			  "gloss": "Resonance‚ÄìIntegrity product remains approximately constant under lawful operation."
			},
			{
			  "eq_id": "Eq.4",
			  "role": "weak_field_limit",
			  "latex": "\\mathcal{C} \\to 1",
			  "gloss": "In weak-field conditions coherence approaches unity, ensuring stability of observer processes."
			}
		  ],
		  "summary": "MMM sits between motif evaluators and routing/integrity/ontology services. Inputs arrive as exchange packets and ontology bundles; MMM validates and stages them, updates observer-state for short-term/long-term fields, and emits DensityReports, bundles, and immune telemetry. All exports are envelope- and lineage-aware when the corresponding feature flags are enabled; all imports are ontology-first and DAG-validated. Adaptive feedback keeps reinforcement bounded via homeostasis signals, and weak-field limits guarantee stability. Algorithms are observer-only at Layer_1.",
		  "interfaces": {
			"keys": {
			  "exchange_srx": "On-wire packets per RFC-0008 used for ingress/egress wrapping.",
			  "ontology_bundle": "RFC-0007-compliant bundle objects with provenance and lineage fields.",
			  "immune_telemetry": "Homeostasis and integrity signals per RFC-0009."
			},
			"ingress": [
			  "exchange_srx: Symbolic Exchange Packet stream from RFC-CORE-002 (RecursiveAgentFT) and RFC-CORE-003 (LogicalAgentAT) via RFC-0008.",
			  "ontology_bundle: Import requests conforming to RFC-0007 with DAG validation prior to staging.",
			  "immune_telemetry: Feedback frames (SII, RIR, near_miss) from RFC-0009 monitors."
			],
			"egress": [
			  "exchange_srx: DensityReport (observer summary) to RFC-0008 routers for downstream consumers.",
			  "ontology_bundle: Exported observer snapshot with provenance+lineage gating when flags are enabled.",
			  "immune_telemetry: Stream of observer metrics (C, lambda, gamma_co, rho_res, delta_closure, SII, RIR) to RFC-0009 monitors."
			],
			"roles": [
			  "MMM is observer-only at Layer_1; it SHALL NOT perform control writes to Xi.",
			  "Exchange wrapping (Sigma_phase) and integrity lineage (Delta_hash) are feature-flag gated; cryptographic policy is deferred to Layer_2."
			]
		  },
		  "algorithms": [
			{
			  "name": "ingest_symbolic_packet",
			  "role": "observer",
			  "inputs": ["packet", "agent_id", "tick_id"],
			  "outputs": ["status", "trace_entry"],
			  "params": ["validate_envelope=true", "validate_lineage=true"],
			  "steps": [
				"1) if validate_envelope then assert packet.exchange_compliant per RFC-0008 ¬ß5",
				"2) extract motif_state := {C, lambda, gamma_co, rho_res, delta_closure}",
				"3) append observer trace with tick_id and motif_state",
				"4) update short-term observer fields (no control writes)",
				"5) emit immune telemetry frame {C, rho_res, delta_closure, SII, RIR}",
				"6) return status=ok and a sealed trace_entry"
			  ],
			  "notes": "Structural validation only at Layer_1; no cryptographic assertions are performed here."
			},
			{
			  "name": "import_ontology_bundle",
			  "role": "observer",
			  "inputs": ["bundle"],
			  "outputs": ["status"],
			  "params": ["require_provenance=true", "require_lineage=true"],
			  "steps": [
				"1) validate version matches 'YYYY-QX' and schema compliance to RFC-0007",
				"2) run DAG validation (RFC-0007 ¬ß8); reject on cycle",
				"3) if require_lineage then verify lineage.Delta_hash is well-formed per RFC-0009 (structural lineage check)",
				"4) if require_provenance then verify provenance.{origin, origin_hash, created_at} present",
				"5) stage bundle in observer memory; do not overwrite live control state",
				"6) return status in {accepted, rejected}"
			  ]
			},
			{
			  "name": "export_density_report",
			  "role": "observer",
			  "inputs": ["window"],
			  "outputs": ["density_report"],
			  "params": ["attach_envelope=true", "attach_lineage=true"],
			  "steps": [
				"1) summarize EMA-windowed observer metrics {mean_C, rho_res_band, triad_closure_rate}",
				"2) construct density_report with on-wire ASCII keys",
				"3) if attach_envelope then compute Sigma_phase (feature-flag gated; RFC-0008 ¬ß5.3)",
				"4) if attach_lineage then compute Delta_hash (feature-flag gated; RFC-0009 Appx D.4 structural lineage)",
				"5) return density_report"
			  ]
			}
		  ],
		  "invariants": [
			{
			  "name": "Observer-Only Boundary",
			  "condition": "MMM routines at Layer_1 are measure/seal/route only; no control writes to Xi.",
			  "source": "PDP-0001 ¬ß3; RFC-0008 ¬ß2"
			},
			{
			  "name": "Ontology-First Import",
			  "condition": "DAG validation and version check precede any staging or reconciliation.",
			  "source": "RFC-0007 ¬ß4‚Äì¬ß6, ¬ß8"
			},
			{
			  "name": "Feature-Flagged Exchange/Integrity",
			  "condition": "Sigma_phase and Delta_hash are attached and verified only when respective flags are enabled.",
			  "source": "RFC-0008 ¬ß5.3; RFC-0009 Appx D.4"
			}
		  ],
		  "telemetry": [
			{
			  "metric": "mean_C",
			  "range": "[0,1]",
			  "units": "dimensionless",
			  "window": "EMA-64",
			  "description": "Average coherence across staged motifs for observer export."
			},
			{
			  "metric": "triad_closure_rate",
			  "range": "[0,1]",
			  "units": "events/tick",
			  "window": "EMA-32",
			  "description": "Rate of motifs meeting closure threshold for lawful recall."
			},
			{
			  "metric": "rho_res_band",
			  "range": "[0,1]",
			  "units": "dimensionless",
			  "window": "EMA-32",
			  "description": "Share of motifs within the resonance band per RFC-0009."
			}
		  ],
		  "references": [
			"RFC-0008 ¬ß5 (Symbolic Exchange Packets and envelopes)",
			"RFC-0007 ¬ß4‚Äì¬ß6, ¬ß8 (Ontology schema and DAG validation)",
			"RFC-0009 ¬ß5‚Äì¬ß7, ¬ß9.3 (Homeostasis, integrity feedback)",
			"RFC-0006 ¬ß1‚Äì¬ß2 (Coherence geometry and T^mu)",
			"RFC-0005 ¬ß3‚Äì¬ß4 (Lawful decay framing)"
		  ],
		  "diagram_hint": "Depict STMM/LTMM observer flows; ingress via RFC-0008 exchange_srx; RFC-0007 DAG gate on import; egress DensityReport and ontology_bundle; immune telemetry to RFC-0009.",
		  "handoff": "With invariants fixed, we now carry the symbols forward to the next clause, keeping ùíû steady and the cadence light."
		},
	},
	
    "2": {
      "id": "2",
	  "title": "Core Memory Architecture and Dynamics",
	  "2.1": {
		  "id": "2.1",
		  "title": "Core Invariants of Memory Fields",
		  "objective": "Formalize conserved and adaptive quantities for short-term (STMM) and long-term (LTMM) memory fields in œà-space so that reinforcement and decay remain bounded under dynamic motif load. Establish capacity limits, adaptive damping, lawful TTL bounds, and the capacity-first doctrine (compress-by-equivalence before any prune) for Layer_1 observer-class operation.",
		  "math": [
			{
			  "eq_id": "Eq.1",
			  "role": "governing_law",
			  "latex": "\\frac{dC}{dt} = \\lambda - \\gamma_{co} + \\varepsilon",
			  "gloss": "Net coherence change equals reinforcement minus adaptive damping plus measurement noise (observer estimate)."
			},
			{
			  "eq_id": "Eq.2",
			  "role": "adaptive_damping",
			  "latex": "\\gamma_{co}(t) = \\gamma_0 + a_1\\,\\eta_{occ}(t) + a_2\\,r_{replay}(t) + a_3\\,r_{conflict}(t)",
			  "gloss": "Damping increases monotonically with occupancy, replay pressure, and conflict rate to prevent saturation."
			},
			{
			  "eq_id": "Eq.3",
			  "role": "capacity_thresholds",
			  "latex": "\\eta_{occ}(t) = \\frac{\\mathrm{LTMM\\_usage}(t)}{C_{max}},\\quad \\eta_{occ} \\ge \\theta_{sat} \\Rightarrow \\text{compress}\\;\\text{first},\\quad \\eta_{occ}^{post\\,cmp} \\ge \\theta_{prune} \\Rightarrow \\text{allow prune}",
			  "gloss": "Occupancy normalized by C_max; compression precedes any pruning; pruning only if still above prune threshold after compression."
			},
			{
			  "eq_id": "Eq.4",
			  "role": "ttl_bounds",
			  "latex": "TTL_{floor} = \\max\\{\\tau_{decay},\\,10\\,\\Delta t_{tick}\\},\\quad TTL_{max}(t) = g(\\text{policy},\\;\\text{storage\\_pressure}(t)),\\quad TTL_{floor} \\le TTL \\le TTL_{max}(t)",
			  "gloss": "Ethical retention floor and adaptive maximum horizon; floor never violated, ceiling adapts to pressure."
			},
			{
			  "eq_id": "Eq.5",
			  "role": "homeostasis_link",
			  "latex": "\\mathrm{RIR}(t)\\,\\mathrm{SII}(t) \\approx k_{homeo}",
			  "gloss": "Resonance‚ÄìIntegrity product remains approximately constant in lawful operation."
			},
			{
			  "eq_id": "Eq.6",
			  "role": "weak_field_limit",
			  "latex": "\\mathcal{C} \\to 1",
			  "gloss": "In the weak-field regime coherence approaches unity; no uncontrolled amplification at low excitation."
			}
		  ],
		  "summary": "The MMM maintains bounded coherence by coupling adaptive damping to occupancy, replay, and conflict pressure, enforcing capacity thresholds with a strict compress-before-prune order, and honoring ethical TTL bounds. These invariants extend Layer_0 laws to Layer_1 observer practice while maintaining homeostasis and weak-field stability.",
		  "algorithms": [
			{
			  "name": "capacity_evaluator",
			  "role": "observer",
			  "inputs": ["LTMM_usage", "C_max", "theta_sat", "theta_prune"],
			  "outputs": ["status", "action"],
			  "params": ["policy_id"],
			  "steps": [
				"1) eta_occ <- LTMM_usage / C_max",
				"2) if eta_occ < theta_sat then return status=ok, action=none",
				"3) else return status=pressure, action=request_compress"
			  ],
			  "notes": "Pure measurement and routing of capacity signals; no control writes."
			},
			{
			  "name": "compression_then_prune",
			  "role": "observer",
			  "inputs": ["snapshot_before", "equivalence_map"],
			  "outputs": ["snapshot_after", "decision"],
			  "params": ["theta_prune"],
			  "steps": [
				"1) snapshot_after <- apply_equivalence_compression(snapshot_before, equivalence_map)  # observer computation",
				"2) eta_occ_post <- snapshot_after.LTMM_usage / snapshot_after.C_max",
				"3) if eta_occ_post >= theta_prune then decision <- recommend_prune else decision <- hold",
				"4) emit telemetry {lawful_compression_ratio, equivalence_efficiency, eta_occ_post}",
				"5) return snapshot_after, decision"
			  ],
			  "notes": "MUST run compression before emitting any prune recommendation."
			},
			{
			  "name": "compute_ttl_bounds",
			  "role": "observer",
			  "inputs": ["tau_decay", "delta_t_tick", "storage_pressure", "policy"],
			  "outputs": ["TTL_floor", "TTL_max_effective"],
			  "params": ["k_policy"],
			  "steps": [
				"1) TTL_floor <- max(tau_decay, 10 * delta_t_tick)",
				"2) TTL_max_effective <- g(policy, storage_pressure, k_policy)  # monotone decreasing in storage_pressure",
				"3) return TTL_floor, TTL_max_effective"
			  ],
			  "notes": "Used to annotate retention decisions; Layer_2 enforces actual storage policy."
			},
			{
			  "name": "update_gamma_co",
			  "role": "observer",
			  "inputs": ["eta_occ", "r_replay", "r_conflict", "gamma_0"],
			  "outputs": ["gamma_co"],
			  "params": ["a1", "a2", "a3"],
			  "steps": [
				"1) gamma_co <- gamma_0 + a1*eta_occ + a2*r_replay + a3*r_conflict",
				"2) return gamma_co"
			  ],
			  "notes": "Monotone in each pressure term to enforce saturation law."
			}
		  ],
		  "invariants": [
			{
			  "name": "Capacity Invariant",
			  "condition": "C_max defines normalized occupancy eta_occ = LTMM_usage / C_max with 0 < C_max <= 1.",
			  "bound": "If eta_occ >= theta_sat then an equivalence compression pass MUST complete before any pruning is considered.",
			  "source": "RFC-0006 ¬ß3‚Äì¬ß4; RFC-0009 ¬ß6‚Äì¬ß7"
			},
			{
			  "name": "Ordered Response Invariant",
			  "condition": "After compression, pruning is allowed only if eta_occ_post >= theta_prune.",
			  "bound": "theta_prune >= theta_sat; pruning without prior compression is non-conforming.",
			  "source": "RFC-0006 ¬ß4.4; RFC-0009 ¬ß7.1"
			},
			{
			  "name": "Adaptive Damping Invariant",
			  "condition": "gamma_co is non-decreasing in eta_occ, r_replay, and r_conflict.",
			  "bound": "As any pressure term grows large, dC/dt -> 0 (saturation equilibrium).",
			  "source": "RFC-0005 ¬ß3.2; RFC-0009 ¬ß5.1"
			},
			{
			  "name": "TTL Bounds Invariant",
			  "condition": "TTL_floor <= TTL <= TTL_max(t) with TTL_floor = max(tau_decay, 10*Delta_t_tick).",
			  "bound": "Ethical floor is never violated; TTL_max decreases with storage pressure.",
			  "source": "RFC-0005 ¬ß4.2; RFC-0009 ¬ß7.1"
			},
			{
			  "name": "Homeostasis Product",
			  "condition": "RIR * SII ‚âà k_homeostasis within tolerance.",
			  "bound": "Deviation beyond epsilon_homeo triggers increased damping via update_gamma_co.",
			  "source": "RFC-0009 ¬ß7.1‚Äì¬ß7.3"
			},
			{
			  "name": "Weak-Field Convergence",
			  "condition": "Under minimal excitation and low occupancy, C approaches unity.",
			  "bound": "No motif amplification when inputs are weak; observer stability maintained.",
			  "source": "RFC-0006 ¬ß1‚Äì¬ß2"
			},
			{
			  "name": "Observer-Only Posture",
			  "condition": "All routines measure, seal, and route; no control writes to Xi.",
			  "bound": "Control and enforcement live in Layer_2 app-specs.",
			  "source": "PDP-0001 ¬ß3; RFC-0008 ¬ß2"
			}
		  ],
		  "telemetry": [
			{
			  "metric": "saturation_level",
			  "range": "[0,1]",
			  "units": "fraction",
			  "window": "EMA-32",
			  "description": "Alias for eta_occ to expose LTMM load."
			},
			{
			  "metric": "lawful_compression_ratio",
			  "range": "[0,1]",
			  "units": "fraction",
			  "window": "EMA-32",
			  "description": "Bytes or items eliminated by equivalence compression divided by pre-compression total."
			},
			{
			  "metric": "equivalence_efficiency",
			  "range": "[0,1]",
			  "units": "dimensionless",
			  "window": "EMA-16",
			  "description": "Share of duplicates correctly mapped to canonical representatives."
			},
			{
			  "metric": "ethical_ttl_floor",
			  "range": "[0,\\infty)",
			  "units": "ticks",
			  "window": "EMA-64",
			  "description": "Realized TTL_floor computed from tau_decay and tick interval."
			},
			{
			  "metric": "ttl_max_effective",
			  "range": "[0,\\infty)",
			  "units": "ticks",
			  "window": "EMA-32",
			  "description": "Current TTL upper bound under policy and storage pressure."
			},
			{
			  "metric": "gamma_co",
			  "range": "[0,2]",
			  "units": "dimensionless",
			  "window": "EMA-32",
			  "description": "Adaptive damping reflecting occupancy, replay, and conflict."
			}
		  ],
		  "references": [
			"RFC-0005 ¬ß3‚Äì¬ß4 (Decay and replay framing)",
			"RFC-0006 ¬ß3‚Äì¬ß4 (Equivalence geometry and triadic closure)",
			"RFC-0009 ¬ß5‚Äì¬ß7 (Homeostasis, saturation, and ethical retention)",
			"RFC-0008 ¬ß2 (Observer routing posture)",
			"PDP-0001 ¬ß3 (Structural provenance and Layer_1 discipline)"
		  ],
		  "handoff": "With invariants fixed, we now carry the symbols forward to the next clause, keeping ùíû steady and the cadence light."
		},
      "2.2": {
		  "id": "2.2",
		  "title": "STMM/LTMM Update Laws",
		  "objective": "Define adaptive update laws for Short-Term Motif Memory (STMM) and Long-Term Motif Memory (LTMM), with promotion back-pressure, equivalence-first compression, staleness-dependent damping, and glider-aware idempotence ‚Äî all under an observer-only posture at Layer_1.",
		  "summary": "STMM is a fast, lossy observer buffer; LTMM is an equivalence-aware store with lawful retention. Promotion STMM‚ÜíLTMM is gated by coherence, closure, resonance, and capacity-aware back-pressure. When occupancy rises, MMM MUST compress by shift-/closure-equivalence before any pruning. Idle motifs accrue staleness damping so that unused items decay even if initially coherent. Gliders, when detected, promote at most once per equivalence class. All laws are observer-class and project along the coherence time vector.",
		  "math": [
			{
			  "eq_id": "2.2-Eq1",
			  "role": "governing law",
			  "latex": "\\frac{dC}{dt} = \\lambda - \\gamma_{co} + \\varepsilon",
			  "gloss": "Coherence evolves by reinforcement minus damping; small perturbations are modeled by Œµ (RFC-0005 ¬ß3; RFC-0009 ¬ß5.1)."
			},
			{
			  "eq_id": "2.2-Eq2",
			  "role": "stmm update",
			  "latex": "STMM_{t+1} = STMM_t + \\eta\\,\\Delta C_t - \\zeta\\,STMM_t",
			  "gloss": "Short-term observer buffer with reinforcement Œ∑ and decay Œ∂ (RFC-0005 ¬ß3.2)."
			},
			{
			  "eq_id": "2.2-Eq3",
			  "role": "ltmm consolidation",
			  "latex": "LTMM_{t+1} = LTMM_t + \\kappa\\,EMA_{64}(C_t) - \\theta\\,\\Delta H_t",
			  "gloss": "Durable consolidation couples smoothed coherence to entropy reduction (RFC-0006 ¬ß3)."
			},
			{
			  "eq_id": "2.2-Eq4",
			  "role": "promotion gate (content)",
			  "latex": "EMA_{64}(C) \\geq \\lambda_{thresh}(t)\\ \\wedge\\ \\Delta_{closure} < \\varepsilon_{triad}\\ \\wedge\\ 0.3 \\leq \\rho_{res} \\leq 0.7",
			  "gloss": "Content-based requirements: coherence, triadic closure, and resonance band (RFC-0006 ¬ß3‚Äì¬ß4)."
			},
			{
			  "eq_id": "2.2-Eq5",
			  "role": "promotion back-pressure (capacity)",
			  "latex": "\\eta_{occ} = \\frac{LTMM\\_{usage}}{C_{max}},\\quad \\text{allow\\_promote} \\Rightarrow \\big(\\eta_{occ} < \\theta_{promote\\_cap}\\big)\\ \\wedge\\ \\big(LCR \\le \\theta_{lcr}\\big)",
			  "gloss": "Capacity gate requires occupancy below cap and lawful compression ratio (LCR) below a threshold."
			},
			{
			  "eq_id": "2.2-Eq6",
			  "role": "staleness damping",
			  "latex": "\\gamma_{stale}(t) = g\\big(EMA_{32}(\\Delta t_{access})\\big),\\quad \\gamma_{total} = \\gamma_{co} + \\gamma_{stale}",
			  "gloss": "Idle-time‚Äìdependent damping increases with the EMA of inter-access intervals (RFC-0005 ¬ß4.2)."
			},
			{
			  "eq_id": "2.2-Eq7",
			  "role": "compression-before-prune trigger",
			  "latex": "\\eta_{occ} > \\rho_{thresh}(t) \\Rightarrow \\text{compress\\_by\\_equivalence} \\prec \\text{prune}",
			  "gloss": "When saturated, equivalence compression MUST precede any destructive pruning (RFC-0006 ¬ß4.4)."
			},
			{
			  "eq_id": "2.2-Eq8",
			  "role": "weak-field limit",
			  "latex": "\\mathcal{C} \\to 1",
			  "gloss": "In the weak-field regime, coherence approaches unity; updates remain stable (RFC-0009 ¬ß5.1)."
			}
		  ],
		  "algorithms": [
			{
			  "name": "promotion_decision_with_backpressure",
			  "role": "observer",
			  "inputs": ["C_ema64", "delta_closure", "rho_res", "LTMM_usage", "C_max", "lawful_compression_ratio"],
			  "outputs": ["promote_bool", "promotion_backpressure"],
			  "params": ["lambda_thresh_seed", "theta_promote_cap", "theta_lcr"],
			  "steps": [
				"1. lambda_thresh(t) ‚Üê lambda_thresh_seed * (1 + EMA32(LTMM_usage / C_max))",
				"2. cond_content ‚Üê (C_ema64 ‚â• lambda_thresh(t)) AND (delta_closure < epsilon_triad) AND (0.3 ‚â§ rho_res ‚â§ 0.7)",
				"3. eta_occ ‚Üê LTMM_usage / C_max",
				"4. cond_capacity ‚Üê (eta_occ < theta_promote_cap) AND (lawful_compression_ratio ‚â§ theta_lcr)",
				"5. promote_bool ‚Üê cond_content AND cond_capacity",
				"6. promotion_backpressure ‚Üê 1 ‚àí min(1, (theta_promote_cap ‚àí eta_occ) / theta_promote_cap)",
				"7. emit_telemetry{promote_bool, promotion_backpressure, eta_occ}"
			  ],
			  "comment": "Back-pressure rises with occupancy and eases when lawful compression remains effective (RFC-0009 ¬ß7.1; RFC-0006 ¬ß4.4)."
			},
			{
			  "name": "equivalence_first_capacity_management",
			  "role": "observer",
			  "inputs": ["LTMM_index"],
			  "outputs": ["action", "CompressionSnapshot"],
			  "params": ["rho_thresh_seed", "compression_target", "prune_floor"],
			  "steps": [
				"1. eta_occ ‚Üê occupancy(LTMM_index)",
				"2. rho_thresh(t) ‚Üê rho_thresh_seed * (1 ‚àí EMA32(1 ‚àí eta_occ))",
				"3. if eta_occ ‚â§ rho_thresh(t): action ‚Üê 'none'; emit_telemetry{eta_occ, action}; return",
				"4. S ‚Üê find_equivalence_classes(LTMM_index, mode='closure_shift')",
				"5. snapshot ‚Üê compute_compression_kpis(pre_equiv_count=|LTMM_index|, post_equiv_count=|representatives(S)|)",
				"6. action ‚Üê 'compress'; LTMM_index ‚Üê store_representatives(S, target=compression_target)",
				"7. if occupancy(LTMM_index) > rho_thresh(t):",
				"8.     action ‚Üê 'prune'; LTMM_index ‚Üê prune_low_value(LTMM_index, floor=prune_floor, score=EMA32(C) * rho_res)",
				"9. emit_telemetry{eta_occ, action, snapshot.lawful_compression_ratio, snapshot.equivalence_efficiency}"
			  ],
			  "comment": "MUST compress by equivalence before any pruning; pruning is a last resort (RFC-0006 ¬ß4.4)."
			},
			{
			  "name": "staleness_damping_update",
			  "role": "observer",
			  "inputs": ["last_access_intervals"],
			  "outputs": ["gamma_stale", "gamma_total"],
			  "params": ["gamma_base"],
			  "steps": [
				"1. idle_ema ‚Üê EMA32(last_access_intervals)",
				"2. gamma_stale ‚Üê monotone_increasing(idle_ema, seed=gamma_base)",
				"3. gamma_total ‚Üê gamma_co + gamma_stale",
				"4. emit_telemetry{staleness_index=normalize(idle_ema), gamma_stale}"
			  ],
			  "comment": "Ensures idle motifs decay over time even if initial C was high (RFC-0005 ¬ß4.2)."
			},
			{
			  "name": "glider_promotion_branch",
			  "role": "observer",
			  "inputs": ["is_glider", "canonical_present", "rho_res", "delta_closure"],
			  "outputs": ["glider_promote_bool"],
			  "params": ["epsilon_triad"],
			  "steps": [
				"1. if NOT is_glider: glider_promote_bool ‚Üê false; return",
				"2. if canonical_present: glider_promote_bool ‚Üê false; return",
				"3. cond ‚Üê (0.3 ‚â§ rho_res ‚â§ 0.7) AND (delta_closure < epsilon_triad)",
				"4. glider_promote_bool ‚Üê cond",
				"5. emit_telemetry{glider_promote_bool}"
			  ],
			  "comment": "Idempotent STMM‚ÜíLTMM promotion for gliders: only one canonical representative per class (RFC-0006 ¬ß3‚Äì¬ß4)."
			},
			{
			  "name": "retention_horizon_update",
			  "role": "observer",
			  "inputs": ["tau_decay", "access_rate_ema32", "TTL_max_t"],
			  "outputs": ["TH"],
			  "params": ["alpha", "beta"],
			  "steps": [
				"1. TH ‚Üê min(alpha * tau_decay + beta * access_rate_ema32, TTL_max_t)",
				"2. emit_telemetry{retention_horizon=TH}"
			  ],
			  "comment": "Lawful retention couples decay scale and observed access; bounded above by TTL_max (RFC-0005 ¬ß4.2; RFC-0009 ¬ß7.2)."
			}
		  ],
		  "invariants": [
			{
			  "name": "Equivalence-First Under Pressure",
			  "condition": "If eta_occ exceeds rho_thresh(t), MMM MUST attempt shift-/closure-equivalence compression before any pruning.",
			  "bound": "Prevents premature information loss; preserves canonical representatives.",
			  "source": "RFC-0006 ¬ß4.4"
			},
			{
			  "name": "Capacity-Aware Promotion",
			  "condition": "Promotion requires content gates (C_ema64, delta_closure, rho_res) AND capacity gates (eta_occ < theta_promote_cap, LCR ‚â§ theta_lcr).",
			  "bound": "Avoids saturating LTMM under load.",
			  "source": "RFC-0009 ¬ß7.1; RFC-0006 ¬ß4.4"
			},
			{
			  "name": "Staleness-Dependent Damping",
			  "condition": "gamma_total = gamma_co + gamma_stale with gamma_stale monotone in EMA32(inter-access).",
			  "bound": "Ensures decay of idle motifs despite high initial coherence.",
			  "source": "RFC-0005 ¬ß4.2"
			},
			{
			  "name": "Glider Idempotence",
			  "condition": "A glider may promote only if its canonical representative is absent; repeated promotions are denied.",
			  "bound": "One representative per shift-equivalence class.",
			  "source": "RFC-0006 ¬ß3‚Äì¬ß4"
			},
			{
			  "name": "Observer-Only Discipline",
			  "condition": "All computations are measurement/sealing/routing; no control writes to Œû at Layer_1.",
			  "bound": "Neutral, auditable posture.",
			  "source": "PDP-0001 ¬ß3‚Äì¬ß4"
			}
		  ],
		  "telemetry": [
			{
			  "metric": "promotion_rate",
			  "range": "[0,1]",
			  "units": "events/tick",
			  "window": "EMA-32",
			  "description": "Fraction of STMM motifs promoted per tick."
			},
			{
			  "metric": "promotion_backpressure",
			  "range": "[0,1]",
			  "units": "dimensionless",
			  "window": "EMA-32",
			  "description": "Back-pressure signal rising with LTMM occupancy and falling with effective compression."
			},
			{
			  "metric": "eta_occ",
			  "range": "[0,1]",
			  "units": "fraction",
			  "window": "EMA-32",
			  "description": "LTMM occupancy fraction used for capacity gating."
			},
			{
			  "metric": "lawful_compression_ratio",
			  "range": "[0,1]",
			  "units": "dimensionless",
			  "window": "EMA-32",
			  "description": "Post-equivalence size divided by pre-equivalence size (before any pruning)."
			},
			{
			  "metric": "equivalence_efficiency",
			  "range": "[0,1]",
			  "units": "fraction",
			  "window": "EMA-32",
			  "description": "Capacity relief achieved by equivalence compression prior to pruning."
			},
			{
			  "metric": "prune_events",
			  "range": "[0,1000]",
			  "units": "events/tick",
			  "window": "EMA-16",
			  "description": "Count of motifs pruned when compression is insufficient."
			},
			{
			  "metric": "staleness_index",
			  "range": "[0,1]",
			  "units": "fraction",
			  "window": "EMA-32",
			  "description": "Normalized EMA of inter-access intervals; higher implies stronger gamma_stale."
			},
			{
			  "metric": "retention_horizon",
			  "range": "[0,+inf)",
			  "units": "ticks",
			  "window": "EMA-32",
			  "description": "Adaptive retention horizon TH applied to LTMM entries, capped by TTL_max."
			}
		  ],
		  "references": [
			"RFC-0005 ¬ß3‚Äì¬ß4 (Coherence dynamics; lawful decay and replay windows)",
			"RFC-0006 ¬ß3‚Äì¬ß4 (Triadic closure; shift-/closure-equivalence; canonicalization)",
			"RFC-0009 ¬ß5‚Äì¬ß7 (Homeostasis, damping, and capacity safeguards)",
			"PDP-0001 ¬ß3‚Äì¬ß4 (Observer-only measurement/sealing discipline)"
		  ],
		  "compatibility": {"point_space_gliders":"Enabled by DEFAULT"},
		  "handoff": "With invariants fixed, we now carry the symbols forward to the next clause, keeping ùíû steady and the cadence light."
		},
	  "2.3": {
		  "id": "2.3",
		  "title": "Reanchor and Recovery Escalation Logic",
		  "objective": "Define adaptive, bounded recovery behavior that prevents infinite rollback loops by limiting reanchor attempts, detecting overlapping recovery windows, and escalating to a quarantine path with observer-class diagnostics; preserve Layer_1 neutrality (no control writes to Œû) while emitting KPIs and events required by the coherence‚Äìintegrity framework.",
		  "summary": "Upon integrity or resonance violations during recall/import, MMM performs a bounded sequence of reanchor attempts to restore the last lawful state. If attempts are exhausted or recovery windows overlap, MMM escalates to quarantine: isolate affected motifs from promotion/export, maintain full observability, and run a sandboxed diagnostic loop that estimates a local response without control writes to Œû. Outcomes are finite: {reanchored, quarantined, abandoned}. Replay/lineage checks follow feature-flag gates; all behavior remains observer-only.",
		  "math": [
			{
			  "eq_id": "2.3-Eq1",
			  "role": "violation trigger",
			  "latex": "\\mathrm{violation}(t) := \\big(\\rho_{res} \\notin [0.3,0.7]\\big)\\ \\vee\\ \\big(\\Delta_{closure} > \\varepsilon_{triad}\\big)",
			  "gloss": "Recovery is entered when resonance leaves band or closure gap exceeds threshold (RFC-0006 ¬ß3‚Äì¬ß4)."
			},
			{
			  "eq_id": "2.3-Eq2",
			  "role": "lawful state test",
			  "latex": "\\mathrm{lawful}(t) := \\big(\\Delta_{closure}=0\\big)\\ \\wedge\\ \\big(0.3 \\le \\rho_{res} \\le 0.7\\big)",
			  "gloss": "A state is lawful when closure holds and resonance is in-band (RFC-0006 ¬ß4.4)."
			},
			{
			  "eq_id": "2.3-Eq3",
			  "role": "overlap condition",
			  "latex": "\\mathrm{overlap}([a,a+\\tau],[b,b+\\tau]) := \\big([a,a+\\tau] \\cap [b,b+\\tau]\\big) \\ne \\varnothing",
			  "gloss": "Escalate when recovery windows overlap."
			},
			{
			  "eq_id": "2.3-Eq4",
			  "role": "adaptive attempt budget",
			  "latex": "N_{max}(t) = \\left\\lceil k \\cdot EMA_{32}(\\mathrm{conflict\\_rate}) \\right\\rceil",
			  "gloss": "Bound attempts by a smoothed conflict rate (RFC-0009 ¬ß5.2)."
			},
			{
			  "eq_id": "2.3-Eq5",
			  "role": "diagnostic coherence response",
			  "latex": "\\big\\|\\partial F/\\partial \\Xi\\big\\| \\le J_{max}\\ \\wedge\\ \\Delta_{closure}\\downarrow\\ \\Rightarrow\\ C\\uparrow",
			  "gloss": "In diagnostics, bounded local sensitivity with improving closure implies rising coherence (RFC-0009 ¬ß5‚Äì¬ß7)."
			},
			{
			  "eq_id": "2.3-Eq6",
			  "role": "weak-field limit",
			  "latex": "\\mathcal{C} \\to 1",
			  "gloss": "Under weak-field conditions, coherence approaches unity and recovery reduces to a no-op (RFC-0009 ¬ß5.1)."
			}
		  ],
		  "algorithms": [
			{
			  "name": "reanchor_protocol",
			  "role": "observer",
			  "inputs": ["snapshot_history", "tau_recovery", "conflict_rate_ema32"],
			  "outputs": ["status", "recovery_token"],
			  "params": ["k", "epsilon_triad"],
			  "steps": [
				"1. if NOT violation(t): return status='no_action', recovery_token=null",
				"2. recovery_token ‚Üê monotonic_token()  # idempotence seed",
				"3. if seen(recovery_token): emit_event('reanchor_idempotent_drop'); return status='abandoned', recovery_token",
				"4. N_max ‚Üê ceil(k * conflict_rate_ema32)",
				"5. for i in 1..max(1, N_max):",
				"6.     candidate ‚Üê last_lawful(snapshot_history, window=tau_recovery)",
				"7.     if candidate == null: emit_event('reanchor_fail'); break",
				"8.     stage_observer_state(candidate)  # no control writes to Œû",
				"9.     if lawful(t): emit_event('reanchor_success'); return status='reanchored', recovery_token",
				"10.    emit_event('reanchor_attempt')",
				"11. if recovery_windows_overlap(tau_recovery): emit_event('overlap_detected'); return quarantine_escalation(recovery_token)",
				"12. emit_event('reanchor_fail'); return quarantine_escalation(recovery_token)"
			  ],
			  "comment": "Bounded, idempotent reanchor attempts; overlap forces escalation (RFC-0009 ¬ß5.2)."
			},
			{
			  "name": "quarantine_escalation",
			  "role": "observer",
			  "inputs": ["recovery_token"],
			  "outputs": ["status"],
			  "params": ["quarantine_ttl", "suppress_export=true", "suppress_promotion=true"],
			  "steps": [
				"1. isolate_offending_set(recovery_token)  # block promotion/export; do not prune at L1",
				"2. emit_event('quarantine_entry', payload={recovery_token})",
				"3. start_timer(quarantine_ttl)",
				"4. maintain full read-only observability of isolated items",
				"5. return status='quarantined'"
			  ],
			  "comment": "Isolation with observability; export/promotion suppressed, preserving Layer_1 neutrality (RFC-0009 ¬ß5.2)."
			},
			{
			  "name": "quarantine_diagnostic_loop",
			  "role": "observer",
			  "inputs": ["isolated_items", "recovery_token"],
			  "outputs": ["status"],
			  "params": ["perturbation_cap=0.01", "phase_interval", "J_max"],
			  "steps": [
				"1. while timer_active(recovery_token):",
				"2.     for each item in isolated_items:",
				"3.         sandbox ‚Üê fork_readonly(item)  # simulate only; no writes to Œû",
				"4.         sandbox.apply_micro_perturbations({lambda, gamma_co}, cap=perturbation_cap)",
				"5.         J_local ‚Üê jacobian_estimate(sandbox, window='EMA-16')",
				"6.         if (delta_closure(sandbox) ‚Üì) AND (rho_res(sandbox) ‚àà [0.3,0.7]) AND (norm(J_local) ‚â§ J_max):",
				"7.             emit_event('diagnostic_pass', payload={item})",
				"8.             mark_candidate_for_recovery(item)",
				"9.         else:",
				"10.            emit_event('diagnostic_retry', payload={item})",
				"11.    wait(phase_interval)",
				"12. if all items marked_candidate_for_recovery: emit_event('recovery_ready'); return status='reanchored'",
				"13. emit_event('quarantine_hold'); return status='quarantined'"
			  ],
			  "comment": "Observer-class diagnostics in a sandbox; measures response without mutating Œû (RFC-0009 ¬ß7)."
			},
			{
			  "name": "import_guard",
			  "role": "observer",
			  "inputs": ["bundle"],
			  "outputs": ["status"],
			  "params": ["require_envelope", "require_lineage", "require_dag"],
			  "steps": [
				"1. if require_dag AND NOT dag_valid(bundle): emit_event('near_miss'); return status='rejected'",
				"2. if require_envelope AND NOT envelope_valid(bundle): emit_event('near_miss'); return status='rejected'",
				"3. if require_lineage AND NOT lineage_valid(bundle): emit_event('near_miss'); return status='rejected'",
				"4. stage_observer_bundle(bundle); emit_event('bundle_staged')",
				"5. return status='staged'"
			  ],
			  "comment": "Observer-side staging; RFC-0007 validation precedes any merge; aligns with RFC-0009 defenses."
			}
		  ],
		  "invariants": [
			{
			  "name": "Bounded Recovery",
			  "condition": "Reanchor attempts do not exceed N_max(t) = ceil(k ¬∑ EMA32(conflict_rate)); each attempt is limited to tau_recovery.",
			  "bound": "Prevents infinite rollback loops.",
			  "source": "RFC-0009 ¬ß5.2"
			},
			{
			  "name": "Escalation on Overlap",
			  "condition": "If recovery windows overlap OR attempts are exhausted, escalate to quarantine.",
			  "bound": "Ensures termination with diagnostic isolation.",
			  "source": "RFC-0009 ¬ß5.2; RFC-0005 ¬ß4.2"
			},
			{
			  "name": "Recovery Idempotence",
			  "condition": "A monotonic recovery_token is issued per incident; identical tokens are denied re-entry.",
			  "bound": "Eliminates replayed recovery cycles.",
			  "source": "RFC-0009 ¬ß5.2"
			},
			{
			  "name": "Observer-Only Diagnostics",
			  "condition": "Diagnostics run in a sandbox fork with simulated micro-perturbations; no control writes to Œû.",
			  "bound": "Maintains Layer_1 neutrality while estimating response.",
			  "source": "PDP-0001 ¬ß3‚Äì¬ß4; RFC-0009 ¬ß7"
			},
			{
			  "name": "Finite Outcomes",
			  "condition": "Recovery MUST end in one of {reanchored, quarantined, abandoned} with an audit trace.",
			  "bound": "Precludes undefined terminal states.",
			  "source": "RFC-0009 ¬ß5.2"
			}
		  ],
		  "telemetry": [
			{
			  "metric": "reanchor_rate",
			  "range": "[0,1]",
			  "units": "events/tick",
			  "window": "EMA-32",
			  "description": "Rate of reanchor attempts."
			},
			{
			  "metric": "reanchor_fail_count",
			  "range": "[0,1000]",
			  "units": "events/tick",
			  "window": "EMA-16",
			  "description": "Failed attempts prior to escalation."
			},
			{
			  "metric": "overlap_detected",
			  "range": "[0,1]",
			  "units": "flag",
			  "window": "EMA-16",
			  "description": "Indicator that recovery windows overlapped in the last tick."
			},
			{
			  "metric": "quarantine_count",
			  "range": "[0,1000]",
			  "units": "sets",
			  "window": "EMA-32",
			  "description": "Number of isolated motif sets."
			},
			{
			  "metric": "recovery_latency",
			  "range": "[0,+inf)",
			  "units": "ticks",
			  "window": "EMA-32",
			  "description": "Ticks from violation to {reanchored|quarantined}."
			},
			{
			  "metric": "J_local",
			  "range": "[0,J_max]",
			  "units": "unitless",
			  "window": "EMA-16",
			  "description": "Estimated local Jacobian norm in diagnostics."
			},
			{
			  "metric": "q_state",
			  "range": "[0,1]",
			  "units": "fraction",
			  "window": "EMA-32",
			  "description": "Share of quarantined motifs that passed the last diagnostic step."
			}
		  ],
		  "compatibility": {
			"exchange": "When enable_exchange_envelope=true, quarantined items suppress export (no Sigma_phase emitted for them).",
			"integrity": "When enable_integrity_checks=true, import_guard requires valid Delta_hash lineage for staging; mismatches are rejected.",
			"provenance": "When enable_provenance_on_export=true, quarantine artifacts retain provenance fields but remain unroutable."
		  },
		  "references": [
			"RFC-0005 ¬ß4.2 (Temporal bounds and lawful restoration)",
			"RFC-0006 ¬ß3‚Äì¬ß4 (Closure and resonance bands; canonical lawful state tests)",
			"RFC-0009 ¬ß5‚Äì¬ß7 (Homeostasis, bounded recovery, diagnostics, and antifragility)",
			"RFC-0007 ¬ß2 (Ontology validation prior to import/merge)",
			"RFC-0008 ¬ß2‚Äì¬ß3 (Envelope/phase handling; replay defenses under flags)",
			"PDP-0001 ¬ß3‚Äì¬ß4 (Observer-only measurement/sealing discipline)"
		  ],
		  "compatibility": {"point_space_gliders":"Enabled by DEFAULT"},
		  "handoff": "With invariants fixed, we now carry the symbols forward to the next clause, keeping ùíû steady and the cadence light."
		}		
    },

    "3": {
      "id": "3",
	  "title": "Memory Structures and Data Formats",
	  "3.1": {
		  "id": "3.1",
		  "title": "Motif Ontology Bundles",
		  "objective": "Specify the schema, provenance, and lineage rules for Motif Ontology Bundles (MOBs) used in cross-agent exchange. Define import validation, merge/fork semantics, and observer-only export behavior under RFC-0007 DAG constraints and RFC-0009 integrity lineage, gated by feature flags.",
		  "summary": "A Motif Ontology Bundle is the observer-class carrier of motifs, relations, and usage signals across agents. Before import, bundles MUST pass ontology (RFC-0007) and lineage checks (RFC-0009). Cross-agent reconciliation is deterministic: merge iff {parent_hash, integrity_hash} match; fork iff parent_hash matches but integrity_hash differs; unrelated otherwise. Provenance binds each bundle to a trusted structural origin per PDP-0001. Export attaches exchange phase and lineage fields only when feature flags enable them; Layer_1 remains neutral and non-cryptographic.",
		  "schema": {
			"fields": [
			  "motif_id",
			  "parents",
			  "dyad_links",
			  "triad_links",
			  "usage_frequency",
			  "psi_field",
			  "integrity_vector",
			  "timestamp",
			  "version"
			],
			"provenance": {
			  "origin": "agent_id",
			  "origin_hash": "structural_hash(origin || created_at || bundle_digest)",
			  "created_at": "ISO-8601"
			},
			"lineage": {
			  "parent_hash": "Delta_hash(previous_bundle)",
			  "integrity_hash": "Delta_hash(current_bundle)",
			  "schema": "RFC-0007"
			},
			"storage_profile": {
			  "profile": "volatile | durable",
			  "retention_ticks": "tau_decay",
			  "provenance_required": true
			},
			"validation": [
			  "MUST validate ontology DAG (RFC-0007 ¬ß8).",
			  "MUST include version formatted 'YYYY-QX' (RFC-0007 ¬ß4).",
			  "MUST validate provenance.origin against Layer_1 trusted root (PDP-0001 ¬ß3).",
			  "When enable_integrity_checks=true: MUST verify lineage.integrity_hash.",
			  "MUST compare lineage.parent_hash across agents before merge; otherwise treat as unrelated."
			]
		  },
		  "math": [
			{
			  "eq_id": "3.1-Eq1",
			  "role": "lineage integrity (structural)",
			  "latex": "\\Delta_{hash}(t) = H\\!\\left(\\mathrm{meta}_t \\Vert \\mathrm{data}_t\\right)",
			  "gloss": "Integrity summary is a deterministic function of bundle metadata and payload (RFC-0009 ¬ß6, Appx D)."
			},
			{
			  "eq_id": "3.1-Eq2",
			  "role": "merge condition",
			  "latex": "\\text{merge} \\iff (parent\\_hash_A = parent\\_hash_B) \\wedge (integrity\\_hash_A = integrity\\_hash_B)",
			  "gloss": "Bundles merge only when ancestry and present state are identical."
			},
			{
			  "eq_id": "3.1-Eq3",
			  "role": "fork condition",
			  "latex": "\\text{fork} \\iff (parent\\_hash_A = parent\\_hash_B) \\wedge (integrity\\_hash_A \\ne integrity\\_hash_B)",
			  "gloss": "Shared ancestry with differing present state yields a fork event."
			},
			{
			  "eq_id": "3.1-Eq4",
			  "role": "weak-field limit",
			  "latex": "\\mathcal{C} \\to 1",
			  "gloss": "In the weak-field regime, coherence approaches unity and exchange reduces to stable no-ops."
			}
		  ],
		  "algorithms": [
			{
			  "name": "validate_bundle",
			  "role": "observer",
			  "inputs": ["bundle"],
			  "outputs": ["status"],
			  "params": ["require_dag=true", "require_version=true", "require_lineage=true", "trusted_roots"],
			  "steps": [
				"1. if require_dag AND NOT dag_valid(bundle): emit_telemetry('dag_invalid'); return status='rejected'",
				"2. if require_version AND NOT version_valid(bundle.version, fmt='YYYY-QX'): emit_telemetry('version_invalid'); return status='rejected'",
				"3. if NOT provenance_origin_in_registry(bundle.provenance.origin, trusted_roots): emit_telemetry('unknown_origin'); return status='rejected'",
				"4. if require_lineage AND NOT lineage_shape_valid(bundle.lineage): emit_telemetry('lineage_invalid'); return status='rejected'",
				"5. if has_cycles(bundle): emit_telemetry('cycle_detected'); return status='rejected'",
				"6. return status='valid'"
			  ],
			  "comment": "RFC-0007 ontology + PDP-0001 trusted origin checks precede any import; Layer_1 structural validation only."
			},
			{
			  "name": "merge_or_fork",
			  "role": "observer",
			  "inputs": ["bundle_A", "bundle_B"],
			  "outputs": ["result", "status"],
			  "params": ["record_provenance=true", "enable_integrity_checks", "enable_provenance_on_export"],
			  "steps": [
				"1. if bundle_A.lineage.parent_hash != bundle_B.lineage.parent_hash: return status='unrelated', result=null",
				"2. if enable_integrity_checks AND (bundle_A.lineage.integrity_hash == bundle_B.lineage.integrity_hash):",
				"3.     merged ‚Üê unify_fields(bundle_A, bundle_B, strategy='latest_timestamp')",
				"4.     if record_provenance: record_provenance_event('merge', details={bundle_A.provenance.origin, bundle_B.provenance.origin})",
				"5.     return status='merged', result=merged",
				"6. else:",
				"7.     forks ‚Üê mark_divergence(bundle_A, bundle_B)",
				"8.     if record_provenance: record_provenance_event('fork', details={bundle_A.id, bundle_B.id})",
				"9.     return status='forked', result=forks"
			  ],
			  "comment": "Deterministic reconciliation using parent/integrity lineage; unrelated ancestry forbids merge."
			},
			{
			  "name": "export_bundle",
			  "role": "observer",
			  "inputs": ["bundle"],
			  "outputs": ["packet"],
			  "params": ["enable_exchange_envelope", "enable_integrity_checks", "enable_provenance_on_export"],
			  "steps": [
				"1. packet ‚Üê { payload: bundle }",
				"2. if enable_provenance_on_export: packet.provenance ‚Üê {origin: bundle.provenance.origin, origin_hash: bundle.provenance.origin_hash, created_at: bundle.provenance.created_at}",
				"3. if enable_exchange_envelope: packet.Sigma_phase ‚Üê compute_phase(bundle)   # RFC-0008 structural phase",
				"4. if enable_integrity_checks: packet.Delta_hash ‚Üê compute_delta_hash(bundle)  # RFC-0009 structural lineage",
				"5. return packet"
			  ],
			  "comment": "Feature-flag‚Äìgated attachment of phase and lineage; no emission when flags are false."
			},
			{
			  "name": "import_pipeline",
			  "role": "observer",
			  "inputs": ["packet", "trusted_roots"],
			  "outputs": ["status"],
			  "params": ["enable_exchange_envelope", "enable_integrity_checks"],
			  "steps": [
				"1. if enable_exchange_envelope AND NOT phase_window_accept(packet.Sigma_phase): emit_telemetry('replay_suspect'); return status='rejected'",
				"2. if enable_integrity_checks AND NOT delta_hash_consistent(packet.Delta_hash, packet.payload): emit_telemetry('lineage_mismatch'); return status='rejected'",
				"3. if validate_bundle(packet.payload, trusted_roots).status != 'valid': return status='rejected'",
				"4. stage_observer_bundle(packet.payload); emit_telemetry('bundle_staged')",
				"5. return status='staged'"
			  ],
			  "comment": "Replay/lineage guards are structural and flag-gated; successful imports are staged, not merged, at Layer_1."
			}
		  ],
		  "invariants": [
			{
			  "name": "Ontology DAG Law",
			  "condition": "Bundles MUST form an acyclic graph and validate before import/export.",
			  "bound": "Reject cyclic/orphaned structures.",
			  "source": "RFC-0007 ¬ß8"
			},
			{
			  "name": "Trusted-Origin Provenance",
			  "condition": "bundle.provenance.origin ‚àà trusted_root_registry AND origin_hash matches structural seed.",
			  "bound": "Prevents unrecognized seeds from merging.",
			  "source": "PDP-0001 ¬ß3.1"
			},
			{
			  "name": "Deterministic Reconciliation",
			  "condition": "Merge iff {parent_hash, integrity_hash} match; fork iff only parent_hash matches; else unrelated.",
			  "bound": "Precludes unlawful overwrites across agents.",
			  "source": "RFC-0007 ¬ß2; RFC-0009 ¬ß6‚Äì¬ß7"
			},
			{
			  "name": "Observer Neutrality",
			  "condition": "Validation, merge/fork, and (de)serialization are observer-class; motif content is not mutated at Layer_1.",
			  "bound": "Maintains neutrality and auditability.",
			  "source": "PDP-0001 ¬ß4.5"
			}
		  ],
		  "telemetry": [
			{
			  "metric": "merge_rate",
			  "range": "[0,1]",
			  "units": "events/tick",
			  "window": "EMA-32",
			  "description": "Share of bundle pairs that merged."
			},
			{
			  "metric": "fork_rate",
			  "range": "[0,1]",
			  "units": "events/tick",
			  "window": "EMA-32",
			  "description": "Share of bundle pairs that forked."
			},
			{
			  "metric": "dag_invalid_count",
			  "range": "[0,1000]",
			  "units": "events/tick",
			  "window": "EMA-16",
			  "description": "Imports rejected due to DAG violations."
			},
			{
			  "metric": "lineage_rejects",
			  "range": "[0,1000]",
			  "units": "events/tick",
			  "window": "EMA-16",
			  "description": "Imports rejected due to integrity lineage mismatch."
			},
			{
			  "metric": "unknown_origin_rate",
			  "range": "[0,1]",
			  "units": "fraction",
			  "window": "EMA-32",
			  "description": "Rate of bundles failing trusted-origin checks."
			}
		  ],
		  "references": [
			"RFC-0007 ¬ß2‚Äì¬ß4, ¬ß8 (Ontology schema, versioning, DAG validation)",
			"RFC-0008 ¬ß2‚Äì¬ß3, ¬ß5 (Exchange envelope, phase semantics, replay windowing)",
			"RFC-0009 ¬ß6‚Äì¬ß7, Appx D (Integrity lineage, structural summaries)",
			"PDP-0001 ¬ß3‚Äì¬ß4 (Trusted origin registry; observer-only discipline)"
		  ],
		  "handoff": "With invariants fixed, we now carry the symbols forward to the next clause, keeping ùíû steady and the cadence light."
		},
      "3.2": {
		  "id": "3.2",
		  "title": "Memory Trace and Logging",
		  "objective": "Define Layer_1 trace-buffer semantics for motif recall, promotion, recovery, and capacity events, with sealed export paths gated by exchange/integrity feature flags. Tracing is observer-only: it measures, seals, and routes; it does not perform control writes to Œû.",
		  "parameters": {
			"TRACE_BUFFER_LEN": 2048,
			"LOCK_POLICY": "per-tick mutex",
			"INTERNAL_TS_RESOLUTION": "ticks",
			"RATE_LIMIT_EXPORT_QPS": 4,
			"integrity_mode": "observer_only | immune"
		  },
		  "trace_entry_schema": {
			"t": "tick_idx",
			"motif_id": "str",
			"C": "float",
			"lambda": "float",
			"gamma_co": "float",
			"rho_res": "float",
			"delta_closure": "float",
			"event": "access|retrieve|promote|demote|near_miss|reanchor_attempt|reanchor_fail|quarantine_entry|saturation_prune",
			"notes": "str?"
		  },
		  "math": [
			{
			  "eq_id": "Eq.1",
			  "role": "governing_law",
			  "latex": "\\frac{d\\mathcal{C}}{dt} = \\lambda - \\gamma_{co} + \\varepsilon",
			  "gloss": "Trace captures observer measurements of coherence evolution per tick."
			},
			{
			  "eq_id": "Eq.2",
			  "role": "purge_horizon",
			  "latex": "\\tau_{decay} = \\frac{1}{\\zeta}",
			  "gloss": "Entries older than the decay horizon are eligible for purge (RFC-0005 ¬ß4.2)."
			},
			{
			  "eq_id": "Eq.3",
			  "role": "event_rate",
			  "latex": "rate_{X}(t) = EMA_{32}\\big(\\mathbf{1}_{event=X}\\big)",
			  "gloss": "Per-event rates (e.g., reanchor_rate) are computed as EMA-32 over indicator events."
			},
			{
			  "eq_id": "Eq.4",
			  "role": "weak_field_limit",
			  "latex": "\\mathcal{C} \\to 1",
			  "gloss": "In the weak-field regime, coherence approaches unity; trace drift converges."
			}
		  ],
		  "algorithms": [
			{
			  "name": "append_trace_entry",
			  "role": "observer",
			  "inputs": ["entry"],
			  "outputs": ["status"],
			  "params": ["LOCK_POLICY", "TRACE_BUFFER_LEN"],
			  "steps": [
				"1. acquire lock(LOCK_POLICY).",
				"2. validate entry against trace_entry_schema (ASCII keys; required fields present).",
				"3. push entry onto ring buffer; if buffer length > TRACE_BUFFER_LEN, drop oldest.",
				"4. release lock.",
				"5. return status='ok'."
			  ],
			  "comment": "Thread-safe append; no control writes to Œû."
			},
			{
			  "name": "purge_old",
			  "role": "observer",
			  "inputs": ["now_tick", "tau_decay"],
			  "outputs": ["purged_count"],
			  "params": [],
			  "steps": [
				"1. cutoff_tick ‚Üê now_tick ‚àí tau_decay.",
				"2. remove all entries with t < cutoff_tick.",
				"3. return purged_count."
			  ],
			  "comment": "Implements lawful forgetting aligned to œÑ_decay = 1/Œ∂ (RFC-0005 ¬ß4.2)."
			},
			{
			  "name": "rollup_trace_summary",
			  "role": "observer",
			  "inputs": ["window_size_ticks"],
			  "outputs": ["summary"],
			  "params": [],
			  "steps": [
				"1. select entries within last window_size_ticks.",
				"2. compute EMA-32 of dC (delta C between adjacent ticks) as memory_trace_dC.",
				"3. compute event EMAs: reanchor_rate, saturation_prune_rate, quarantine_entry_rate.",
				"4. aggregate counts: promote_events, demote_events, near_miss_events.",
				"5. compute bands: rho_res_band_share = share of entries with 0.3 ‚â§ rho_res ‚â§ 0.7.",
				"6. return summary with ASCII keys suitable for on-wire export."
			  ],
			  "comment": "Provides dashboard-ready statistics without exposing raw payloads."
			},
			{
			  "name": "export_trace",
			  "role": "observer",
			  "inputs": ["summary", "feature_flags"],
			  "outputs": ["packet"],
			  "params": ["integrity_mode"],
			  "steps": [
				"1. packet ‚Üê { kind:'trace_summary', body: summary }.",
				"2. if feature_flags.enable_exchange_envelope == true: packet.Sigma_phase ‚Üê compute_phase_checksum(packet).",
				"3. if feature_flags.enable_integrity_checks == true: packet.Delta_hash ‚Üê compute_lineage_hash(packet).",
				"4. attach provenance if feature_flags.enable_provenance_on_export == true.",
				"5. enforce RATE_LIMIT_EXPORT_QPS for outbound packets.",
				"6. return packet."
			  ],
			  "comment": "Seals summary for SRX routing; checksums are strictly feature-flag gated (RFC-0008 ¬ß5.3; RFC-0009 Appx D.4)."
			}
		  ],
		  "invariants": [
			{
			  "name": "Observer_Only_Boundary",
			  "condition": "All trace operations are measurement, sealing, and routing only; no control writes to Œû.",
			  "source": "PDP-0001 ¬ß4.5"
			},
			{
			  "name": "Lawful_Purge",
			  "condition": "purge_old removes entries older than tau_decay = 1/Œ∂.",
			  "source": "RFC-0005 ¬ß4.2"
			},
			{
			  "name": "Gated_Export_Checksums",
			  "condition": "Sigma_phase present iff enable_exchange_envelope=true; Delta_hash present iff enable_integrity_checks=true.",
			  "source": "RFC-0008 ¬ß5.3; RFC-0009 Appx D.4"
			},
			{
			  "name": "Bounded_Buffer",
			  "condition": "Ring buffer length ‚â§ TRACE_BUFFER_LEN; oldest entries dropped first.",
			  "source": "RFC-0009 ¬ß7.1"
			},
			{
			  "name": "Weak_Field_Convergence",
			  "condition": "As field pressure ‚Üí 0, C ‚Üí 1 and EMA(dC) ‚Üí 0.",
			  "source": "RFC-0006 ¬ß1.1"
			}
		  ],
		  "telemetry": [
			{
			  "metric": "memory_trace_dC",
			  "range": "[-1,1]",
			  "units": "delta_per_tick",
			  "window": "EMA-32",
			  "dashboard": "memory/decay_dynamics",
			  "description": "Smoothed change in coherence between ticks derived from trace entries."
			},
			{
			  "metric": "reanchor_rate",
			  "range": "[0,1]",
			  "units": "events/tick",
			  "window": "EMA-32",
			  "dashboard": "memory/recovery",
			  "description": "Rate of reanchor_attempt events; spikes indicate instability (RFC-0009 ¬ß9.3)."
			},
			{
			  "metric": "reanchor_fail_rate",
			  "range": "[0,1]",
			  "units": "events/tick",
			  "window": "EMA-32",
			  "dashboard": "memory/recovery",
			  "description": "Rate of reanchor_fail events preceding quarantine escalation."
			},
			{
			  "metric": "quarantine_entry_rate",
			  "range": "[0,1]",
			  "units": "events/tick",
			  "window": "EMA-32",
			  "dashboard": "memory/recovery",
			  "description": "Incidence of quarantine_entry events signalling bounded escalation."
			},
			{
			  "metric": "saturation_prune_rate",
			  "range": "[0,1]",
			  "units": "events/tick",
			  "window": "EMA-32",
			  "dashboard": "memory/saturation",
			  "description": "Incidence of saturation_prune events after compression-first capacity control."
			},
			{
			  "metric": "rho_res_band_share",
			  "range": "[0,1]",
			  "units": "fraction",
			  "window": "EMA-32",
			  "dashboard": "memory/triad_closure",
			  "description": "Share of motifs operating within the resonance band 0.3‚Äì0.7."
			}
		  ],
		  "methods": [
			"append(entry): MUST be lock-protected if concurrent and validate ASCII keys.",
			"export_trace(summary): MUST attach Sigma_phase when exchange envelope enabled; MUST attach Delta_hash when integrity checks enabled.",
			"purge_old(): MUST drop entries older than tau_decay = 1/Œ∂ (RFC-0005 ¬ß4.2).",
			"rollup_trace_summary(window): SHOULD produce dashboard-aligned KPIs without raw payload leakage."
		  ],
		  "references": [
			"RFC-0005 ¬ß4.2 (Lawful decay and purge horizon)",
			"RFC-0006 ¬ß1.1 (Coherence geometry and weak-field limit)",
			"RFC-0008 ¬ß5.3 (Exchange envelope, phase checksum)",
			"RFC-0009 ¬ß7.1, ¬ß9.3 (Homeostasis and recovery telemetry)",
			"PDP-0001 ¬ß4.5 (Observer-only posture)"
		  ],
		  "handoff": "Memory prepared and sealed, we hand it to the exchange where phase keeps time."
		}
	  "3.3": {
		  "id": "3.3",
		  "title": "Glider Handling and Shift-Equivalence Compression",
		  "objective": "Define Layer_1 semantics to (a) detect shift-equivalence classes, (b) select and store exactly one canonical representative per class, (c) compress-by-equivalence before any prune recommendation, and (d) remap recall to the canonical via inverse shifts. All behavior is observer-only; glider point-space attributes remain feature-gated by enable_point_space_gliders.",
		  "summary": "MMM recognizes motifs that recur under shifts as members of a shift-equivalence class. It validates ontology first, deterministically picks a canonical representative, records occurrence references to avoid double promotion, and answers recall via inverse shift to the representative. When glider flags are disabled, only sequence shift-equivalence is applied (no {class,v,phi,tau} tags).",
		  "math": [
			{
			  "eq_id": "M0",
			  "role": "weak_field",
			  "latex": "\\text{Limit (weak field): } \\mathcal{C} \\to 1",
			  "gloss": "Under weak-field conditions, coherence approaches unity; MMM remains observer-only."
			},
			{
			  "eq_id": "M1",
			  "role": "governing_law",
			  "latex": "\\frac{d\\mathcal{C}}{dt} = \\lambda - \\gamma_{co} + \\epsilon",
			  "gloss": "Capacity evolution couples intake to damping; MMM may observe/measure but not actuate Xi."
			},
			{
			  "eq_id": "M2",
			  "role": "shift_equivalence",
			  "latex": "x \\sim_s y \\iff \\exists k \\in \\mathbb{Z}: S^k(x) = y",
			  "gloss": "Equivalence under the symbolic shift operator S on sequence-like encodings."
			},
			{
			  "eq_id": "M3",
			  "role": "canonical_selection",
			  "latex": "\\mathrm{canon}(\\mathcal{C}\\!lass) = \\arg\\min_{z \\in \\mathcal{C}\\!lass} \\mathrm{lex}(\\mathrm{hash}(z))",
			  "gloss": "Deterministic canonical representative by lexicographic order of a stable hash over validated members."
			},
			{
			  "eq_id": "M4",
			  "role": "no_double_promotion",
			  "latex": "\\text{promote}(m) = 0\\;\\text{if}\\; \\exists\\, \\mathrm{canon}([m]_s)",
			  "gloss": "If a class has a representative, do not promote additional class members."
			},
			{
			  "eq_id": "M5",
			  "role": "lawful_compression_ratio",
			  "latex": "\\mathrm{LCR} = \\frac{N_{preimages\\,collapsed}}{N_{total\\,intake}} \\in [0,1]",
			  "gloss": "Computed only over members that passed RFC-0007 validation; pre-prune constraint is mandatory."
			}
		  ],
		  "algorithms": [
			{
			  "name": "validate_ontology_bundle",
			  "role": "observer",
			  "inputs": ["ontology_bundle"],
			  "outputs": ["validated_items"],
			  "params": {
				"require_version_format": "YYYY-QX",
				"psi_field_regex": "^œà-[a-z0-9_]+@Œû$"
			  },
			  "steps": [
				"Check version matches YYYY-QX; reject otherwise.",
				"Validate presence names against œà-*@Œû and DAG acyclicity per RFC-0007.",
				"Verify provenance.origin and lineage hashes structurally (no crypto semantics at Layer_1).",
				"Return only items that pass all checks."
			  ],
			  "invariants": [
				"Ontology-first gate: downstream steps operate on validated_items only."
			  ]
			},
			{
			  "name": "detect_shift_equivalence",
			  "role": "observer",
			  "inputs": ["validated_items", "stream_id", "window_id"],
			  "outputs": ["equivalence_classes", "diagnostics"],
			  "params": {
				"rolling_hash": "stable on sequence encodings",
				"window": "EMA-32",
				"max_span": "occupancy-coupled bound"
			  },
			  "steps": [
				"Encode each item into a shift-normal candidate via rolling window.",
				"For each item, compute class_key = min_lex(hash(S^k(item))) over all cyclic shifts within max_span.",
				"Group items by class_key; emit diagnostics {class_count, suspected_collisions} under EMA-32."
			  ],
			  "invariants": [
				"Compress-before-prune MUST hold for any later recommendations.",
				"No point-space tags used here; sequence-only detection is always permitted."
			  ]
			},
			{
			  "name": "select_and_register_canonical",
			  "role": "observer",
			  "inputs": ["equivalence_classes"],
			  "outputs": ["glider_canonical", "occurrence_refs", "merge_intents"],
			  "params": {
				"tie_break": "lex(hash(z))",
				"store_refs": true
			  },
			  "steps": [
				"For each class, choose canon(class) by M3 over validated members.",
				"If canon already exists, skip creation (idempotent); append new members to occurrence_refs[class].",
				"Propose merge_intents {from -> canon} following RFC-0007 merge_if/fork_if policy.",
				"Record observer-side index glider_canonical[class] = canon with occurrence_refs[class] = [members ‚àí canon]."
			  ],
			  "invariants": [
				"Canonical uniqueness: exactly one representative per class.",
				"No control writes to Xi; capacity accounting may count canon against LTMM while occurrences are references."
			  ]
			},
			{
			  "name": "apply_equivalence_compression_observation",
			  "role": "observer",
			  "inputs": ["glider_canonical", "occurrence_refs"],
			  "outputs": ["compression_snapshot"],
			  "params": {
				"kpi_window": "EMA-32"
			  },
			  "steps": [
				"Compute lawful_compression_ratio = |occurrence_refs_total| / (|occurrence_refs_total| + |glider_canonical|).",
				"Compute equivalence_efficiency = |glider_canonical| / (|glider_canonical| + |occurrence_refs_total|).",
				"Emit compression_snapshot {class_count: |glider_canonical|, canonical_count: |glider_canonical|, lawful_compression_ratio, equivalence_efficiency}."
			  ],
			  "invariants": [
				"KPIs reflect compress-before-prune; no pruning occurs in this section."
			  ]
			},
			{
			  "name": "recall_via_inverse_shift",
			  "role": "observer",
			  "inputs": ["query_item", "glider_canonical"],
			  "outputs": ["rep_id", "inverse_shift"],
			  "params": {
				"access_event_edge": "EMA-16 positive edge"
			  },
			  "steps": [
				"Derive class_key for query_item using detect_shift_equivalence encoding.",
				"Lookup rep_id = glider_canonical[class_key].",
				"Compute inverse_shift that maps query_item to rep_id (sequence shift only when flags are disabled).",
				"Return {rep_id, inverse_shift}."
			  ],
			  "invariants": [
				"Idle-time semantics for access are defined by the access_event_edge policy.",
				"Glider point-space attributes are excluded unless feature-gated."
			  ]
			},
			{
			  "name": "export_equivalence_index",
			  "role": "observer",
			  "inputs": ["glider_canonical", "occurrence_refs", "feature_flags"],
			  "outputs": ["packet"],
			  "params": {
				"include_provenance": true
			  },
			  "steps": [
				"Assemble packet = { kind: 'equivalence_index', body: { glider_canonical, occurrence_refs } }.",
				"If feature_flags.enable_exchange_envelope == true, attach Sigma_phase (phase checksum).",
				"If feature_flags.enable_integrity_checks == true, attach Delta_hash (lineage hash).",
				"If feature_flags.enable_provenance_on_export == true, attach provenance fields.",
				"Return packet."
			  ],
			  "invariants": [
				"Checksums are strictly flag-gated; examples MUST NOT include stub values."
			  ]
			}
		  ],
		  "invariants": [
			{
			  "name": "Canonical_Uniqueness",
			  "condition": "Exactly one representative per shift-equivalence class (observer index).",
			  "source": "RFC-0006 ¬ß3‚Äì¬ß4"
			},
			{
			  "name": "No_Double_Promotion",
			  "condition": "If canon(class) exists, additional class members SHALL NOT be promoted.",
			  "source": "RFC-0006 ¬ß4; RFC-0005 ¬ß4"
			},
			{
			  "name": "Equivalence_First",
			  "condition": "Compression by equivalence precedes any pruning advice.",
			  "source": "RFC-0006 ¬ß4"
			},
			{
			  "name": "Observer_Only",
			  "condition": "Measure, seal, route; no control writes to Xi.",
			  "source": "PDP-0001 ¬ß3‚Äì¬ß4"
			},
			{
			  "name": "Flag_Gating",
			  "condition": "Point-space glider tags {class,v,phi,tau} appear only when enable_point_space_gliders=true.",
			  "source": "PDP-0001 ¬ß3.2"
			}
		  ],
		  "telemetry": [
			{
			  "metric": "lawful_compression_ratio",
			  "range": "[0,1]",
			  "units": "ratio",
			  "window": "EMA-32"
			},
			{
			  "metric": "equivalence_efficiency",
			  "range": "(0,1]",
			  "units": "ratio",
			  "window": "EMA-16"
			},
			{
			  "metric": "canonical_count",
			  "range": "[0,+inf)",
			  "units": "count",
			  "window": "EMA-32"
			}
		  ],
		  "examples": [
			{
			  "name": "sequence_shift_equivalence_only",
			  "active_when": "always",
			  "version": "2025-Q4",
			  "input": {
				"sequences": ["ababa", "babaa", "abaab", "abba"]
			  },
			  "process": "Compute class keys by minimizing lex(hash(S^k(seq))); the first three form one class; 'abba' is a singleton.",
			  "output": {
				"classes": 2,
				"canonical_count": 2,
				"lawful_compression_ratio": 0.5,
				"equivalence_efficiency": 0.5
			  },
			  "notes": "Conforms to RFC-0007 validation and uses no point-space tags."
			},
			{
			  "name": "glider_index_entry",
			  "active_when": "enable_point_space_gliders=true",
			  "version": "2025-Q4",
			  "glider_canonical_entry": {
				"class_id": "shift:sha256:7f3a...",
				"rep": {
				  "motif_id": "m:alpha-001",
				  "psi_field": "œà-resonance@Œû",
				  "usage_frequency": 128
				},
				"occurrence_refs": ["m:alpha-017", "m:alpha-022"],
				"tags": {
				  "class": "glider",
				  "v": 0.25,
				  "phi": 4,
				  "tau": 16
				}
			  }
			}
		  ],
		  "references": [
			"RFC-0006 ¬ß3‚Äì¬ß4 (Equivalence geometry and canonicalization)",
			"RFC-0007 ¬ß2‚Äì¬ß4 (Ontology validation, provenance/lineage, merge/fork)",
			"RFC-0005 ¬ß3‚Äì¬ß4 (Transmission horizons and replay discipline)",
			"RFC-0009 ¬ß5‚Äì¬ß7 (Homeostasis and integrity coupling)",
			"PDP-0001 ¬ß3 (Artifact generation and structural lineage)"
		  ],
		  "handoff": "Memory prepared and sealed, we hand it to the exchange where phase keeps time."
		}
    },

    "4": {
      "id": "4",
	  "title": "Integration, Security, and Recovery Protocols",
	  "4.1": {
		  "id": "4.1",
		  "title": "Exchange and Integrity Integration",
		  "objective": "Integrate routing envelopes (RFC-0008) and immune-integrity lineage (RFC-0009) for all Layer_1 exports/imports. Define an adaptive Œ£_phase acceptance horizon, a hybrid seen_set replay defense, and structural origin validation via the local trusted root. All behavior is observer-only; cryptographic proof and RBAC are deferred to Layer_2.",
		  "summary": "Outbound artifacts (state exports, density reports, ontology bundles, traces) are wrapped in an SRX envelope with dual checksums Œ£_phase and Œî_hash when flags permit. Imports are accepted only within an adaptive window ŒîœÑ_phase and from lawful structural origins registered in the local trusted root. A hybrid seen_set (time-window + LRU) rejects replays deterministically. Layer_1 verifies structure and lineage; Layer_2 adds cryptography.",
		  "math": [
			{
			  "eq_id": "M0",
			  "role": "weak_field",
			  "latex": "\\text{Limit (weak field): } \\mathcal{C} \\to 1",
			  "gloss": "As coherence stabilizes, windows and drift converge; observer posture remains in force."
			},
			{
			  "eq_id": "M1",
			  "role": "adaptive_window",
			  "latex": "\\Delta\\tau_{phase} = \\alpha\\,EMA_{32}(\\mathcal{C})",
			  "gloss": "Replay acceptance horizon scales with recent coherence stability (RFC-0008)."
			},
			{
			  "eq_id": "M2",
			  "role": "phase_checksum",
			  "latex": "\\Sigma_{phase} = H(\\text{payload} \\oplus T^{\\mu})",
			  "gloss": "Deterministic phase checksum over payload and coherence time vector (Layer_1 structural hash)."
			},
			{
			  "eq_id": "M3",
			  "role": "lineage_chain",
			  "latex": "\\Delta_{hash}(t) = H(\\text{payload}_t \\Vert \\Delta_{hash}(t-1))",
			  "gloss": "Structural lineage chain to detect tampering and re-ordering (RFC-0009)."
			},
			{
			  "eq_id": "M4",
			  "role": "trusted_root_guard",
			  "latex": "\\text{valid\\_origin} := (\\text{origin}\\in R_{root})\\ \\wedge\\ (H(\\text{origin\\_fields}) = \\text{origin\\_hash})",
			  "gloss": "Local structural provenance check using the Layer_1 trusted root (PDP-0001)."
			}
		  ],
		  "algorithms": [
			{
			  "name": "export_payload",
			  "role": "observer",
			  "inputs": ["payload", "provenance", "feature_flags", "last_Delta_hash", "trusted_root_registry"],
			  "outputs": ["packet"],
			  "params": { "alpha": 1.0 },
			  "steps": [
				"1) Require at least one of {enable_exchange_envelope, enable_integrity_checks} to be true; otherwise return status='skipped'.",
				"2) if provenance.origin ‚àâ trusted_root_registry ‚Üí emit telemetry('unrecognized_seed'); return status='rejected'.",
				"3) packet ‚Üê { body: payload, provenance, timestamp: tick_now }.",
				"4) if feature_flags.enable_exchange_envelope == true ‚Üí packet.Sigma_phase ‚Üê phase_checksum(payload, T^mu).",
				"5) if feature_flags.enable_integrity_checks == true ‚Üí packet.Delta_hash ‚Üê hash_lineage(payload, last_Delta_hash).",
				"6) if feature_flags.enable_provenance_on_export == true ‚Üí attach provenance.origin_hash = H(origin_fields).",
				"7) Compute ŒîœÑ_phase = alpha * EMA32(C); set packet.valid_until = tick_now + ŒîœÑ_phase.",
				"8) Return packet."
			  ],
			  "invariants": [
				"Checksums strictly flag-gated; no stub values permitted.",
				"Observer-only: no control writes to Œû."
			  ]
			},
			{
			  "name": "import_payload",
			  "role": "observer",
			  "inputs": ["packet", "trusted_root_registry", "feature_flags", "parent_Delta_hash", "now_tick"],
			  "outputs": ["status"],
			  "params": { "accept_skew_ticks": 0 },
			  "steps": [
				"1) If now_tick > packet.valid_until + accept_skew_ticks ‚Üí emit telemetry('replay_expired'); return status='rejected'.",
				"2) If feature_flags.enable_exchange_envelope == true: verify Sigma_phase‚Ä≤ = phase_checksum(packet.body, T^mu); reject on mismatch.",
				"3) If feature_flags.enable_integrity_checks == true: verify Delta_hash‚Ä≤ = hash_lineage(packet.body, parent_Delta_hash); reject on mismatch.",
				"4) Verify packet.provenance.origin ‚àà trusted_root_registry and H(origin_fields) == provenance.origin_hash; reject on mismatch.",
				"5) Stage packet.body in observer memory only; emit telemetry('import_accept'); return status='accepted'."
			  ],
			  "invariants": [
				"Structural origin validation precedes lineage acceptance.",
				"Observer-only: staging does not modify Xi."
			  ]
			},
			{
			  "name": "seen_set_replay_defense",
			  "role": "observer",
			  "inputs": ["packet_key_fields"],
			  "outputs": ["seen_set_state"],
			  "params": {
				"window_policy": "time_window = 2 * ŒîœÑ_phase",
				"eviction": "LRU within window"
			  },
			  "steps": [
				"1) key ‚Üê (provenance.origin, Sigma_phase?, Delta_hash?, bundle_id?) including only fields present by flags.",
				"2) If key ‚àà seen_set within time_window ‚Üí emit telemetry('replay_suspect'); drop packet.",
				"3) Else insert key into seen_set with timestamp; evict by LRU when capacity or window bound is reached.",
				"4) Return seen_set_state."
			  ],
			  "invariants": [
				"Hybrid policy: bounded time window with LRU ordering.",
				"Key composition respects feature flags; absent checksums are not synthesized."
			  ]
			},
			{
			  "name": "update_trusted_root_registry",
			  "role": "observer",
			  "inputs": ["registry_update_bundle"],
			  "outputs": ["status"],
			  "params": { "require_schema": true, "require_provenance": true },
			  "steps": [
				"1) Validate registry_update_bundle against PDP-0001 structural schema (no cryptographic assertions).",
				"2) Require provenance fields and origin_hash self-consistency; reject if inconsistent.",
				"3) Merge lawful seeds into in-memory trusted_root_registry; reject foreign/ill-formed entries.",
				"4) Return status='updated'."
			  ],
			  "invariants": [
				"Layer_1 remains structural; PKI and external CA checks are deferred to Layer_2."
			  ]
			}
		  ],
		  "invariants": [
			{
			  "name": "Checksum_Duality",
			  "condition": "Sigma_phase and Delta_hash SHALL be present when their respective feature flags are enabled.",
			  "source": "RFC-0008 ¬ß2‚Äì¬ß3; RFC-0009 Appx D"
			},
			{
			  "name": "Adaptive_Replay_Window",
			  "condition": "ŒîœÑ_phase = Œ±¬∑EMA32(C) bounds acceptance; packets outside the horizon are rejected.",
			  "source": "RFC-0008 ¬ß2.2"
			},
			{
			  "name": "Hybrid_Seen_Set",
			  "condition": "Replay defense uses time_window = 2¬∑ŒîœÑ_phase with LRU eviction within the window.",
			  "source": "RFC-0005 ¬ß3‚Äì¬ß4"
			},
			{
			  "name": "Origin_Verification_by_Structure",
			  "condition": "origin ‚àà trusted_root_registry and H(origin_fields)=origin_hash before lineage acceptance.",
			  "source": "PDP-0001 ¬ß3‚Äì¬ß4"
			},
			{
			  "name": "Observer_Only_Posture",
			  "condition": "All actions are measurement/sealing/routing; no control writes to Œû.",
			  "source": "PDP-0001 ¬ß4.5"
			}
		  ],
		  "telemetry": [
			{
			  "metric": "export_success_rate",
			  "range": "[0,1]",
			  "units": "events/tick",
			  "window": "EMA-32"
			},
			{
			  "metric": "import_reject_rate",
			  "range": "[0,1]",
			  "units": "events/tick",
			  "window": "EMA-32"
			},
			{
			  "metric": "unrecognized_seed_count",
			  "range": "[0,1000000]",
			  "units": "events",
			  "window": "EMA-32"
			},
			{
			  "metric": "avg_replay_window_ticks",
			  "range": "[0,+inf)",
			  "units": "ticks",
			  "window": "EMA-32"
			}
		  ],
		  "examples": [
			{
			  "name": "flag_gated_checksums",
			  "version": "2025-Q4",
			  "active_when": "enable_exchange_envelope=true && enable_integrity_checks=true",
			  "packet_headers": {
				"Sigma_phase": "present",
				"Delta_hash": "present"
			  },
			  "notes": "If either flag is false, the corresponding key MUST NOT appear."
			},
			{
			  "name": "replay_drop_by_seen_set",
			  "version": "2025-Q4",
			  "active_when": "always",
			  "input": { "key": ["origin=A", "Sigma_phase=s1", "bundle_id=B"] },
			  "process": "Second arrival within 2¬∑ŒîœÑ_phase is dropped as replay_suspect.",
			  "output": { "status": "rejected", "telemetry": "replay_suspect" }
			}
		  ],
		  "references": [
			"RFC-0008 ¬ß2‚Äì¬ß3 (Symbolic Resource Exchange envelope, phase checksums)",
			"RFC-0009 ¬ß5‚Äì¬ß7, Appx D (Integrity lineage and immune behavior)",
			"RFC-0005 ¬ß3‚Äì¬ß4 (Transmission horizons and replay discipline)",
			"PDP-0001 ¬ß3‚Äì¬ß4 (Structural provenance and observer posture)"
		  ],
		  "handoff": "With the store reconciled, we turn to the gauges so the system can see itself."
		},
      "4.2": {
		  "id": "4.2",
		  "title": "Decay and Recovery Protocols",
		  "objective": "Define lawful decay, bounded recovery, and quarantine procedures that restore motif states without control writes. Recovery MUST terminate in a finite set of outcomes {reanchored, quarantined, abandoned}. All behavior is observer-only and structurally aligned with RFC-0005 (decay/replay), RFC-0009 (homeostasis/integrity), and PDP-0001 (provenance).",
		  "summary": "Layer_1 maintains continuity by measuring and staging only. Coherence decays by the governing law; integrity violations open a recovery window with an adaptive attempt budget. If overlap or exhaustion occurs, items escalate to quarantine, where observer-class diagnostics evaluate closure improvements under bounded Jacobian norms. Each recovery episode ends deterministically as reanchored, quarantined, or abandoned, with audit trails. When imports present structurally valid phase envelopes but corrupted coherence fields, the protocol degrades gracefully: attempt reanchor, then quarantine, never crash-loop.",
		  "math": [
			{
			  "eq_id": "M0",
			  "role": "weak_field",
			  "latex": "\\text{Limit (weak field): } \\mathcal{C} \\to 1",
			  "gloss": "Coherence approaches unity under weak-field conditions; MMM remains observer-only."
			},
			{
			  "eq_id": "M1",
			  "role": "governing_decay",
			  "latex": "\\frac{d\\mathcal{C}}{dt} = \\lambda - \\gamma_{co} + \\epsilon",
			  "gloss": "Lawful decay couples reinforcement (\\lambda) and damping (\\gamma_{co}); \\epsilon captures bounded noise. (RFC-0005)"
			},
			{
			  "eq_id": "M2",
			  "role": "violation_trigger",
			  "latex": "\\mathrm{viol}(t) := \\bigl|RIR\\cdot SII - k_{homeostasis}\\bigr| > \\varepsilon \\;\\lor\\; \\rho_{res} \\notin [\\rho_{min},\\rho_{max}]",
			  "gloss": "Integrity/resonance deviation opens a recovery window. (RFC-0009)"
			},
			{
			  "eq_id": "M3",
			  "role": "recovery_budget",
			  "latex": "N_{max}(t) = N_0 + \\alpha\\,EMA_{32}(\\mathrm{stability}) - \\beta\\,EMA_{16}(\\mathrm{violation\\_rate})",
			  "gloss": "Adaptive upper bound on attempts prevents crash/rollback loops. (RFC-0009)"
			},
			{
			  "eq_id": "M4",
			  "role": "lawful_restored",
			  "latex": "\\mathrm{lawful}(x) := (\\Delta_{closure}(x)=0) \\wedge (\\rho_{res}(x)\\in[\\rho_{min},\\rho_{max}])",
			  "gloss": "Closure satisfied and resonance in band implies lawful state. (RFC-0006)"
			},
			{
			  "eq_id": "M5",
			  "role": "diagnostic_progress",
			  "latex": "\\lVert \\partial F/\\partial \\Xi \\rVert \\le J_{max} \\;\\wedge\\; \\Delta_{closure}\\downarrow \\Rightarrow \\mathcal{C}\\uparrow",
			  "gloss": "Bounded local Jacobian with improving closure implies coherent recovery during diagnostics. (RFC-0009)"
			}
		  ],
		  "algorithms": [
			{
			  "name": "lawful_decay_step",
			  "role": "observer",
			  "inputs": ["C", "lambda", "gamma_co", "epsilon", "dt"],
			  "outputs": ["C_next"],
			  "params": {},
			  "steps": [
				"1) dC ‚Üê lambda - gamma_co + epsilon",
				"2) C_next ‚Üê min(1, max(0, C + dC * dt))",
				"3) emit_telemetry('decay_tick', {C_next, dC})",
				"4) return C_next"
			  ],
			  "invariants": [
				"No control writes to Œû; this is a measurement projection consistent with RFC-0005."
			  ]
			},
			{
			  "name": "open_recovery_window",
			  "role": "observer",
			  "inputs": ["snapshot_history", "RIR", "SII", "rho_res", "epsilon"],
			  "outputs": ["window_id|none"],
			  "params": {},
			  "steps": [
				"1) if |RIR*SII - k_homeostasis| > epsilon OR rho_res ‚àâ [œÅ_min, œÅ_max]:",
				"2)     window_id ‚Üê start_window(snapshot_history.tail())",
				"3)     emit_telemetry('recovery_open', {window_id})",
				"4)     return window_id",
				"5) else return none"
			  ],
			  "invariants": [
				"Opening a window is a routing/marking action only."
			  ]
			},
			{
			  "name": "reanchor_protocol",
			  "role": "observer",
			  "inputs": ["window_id", "snapshot_history", "params"],
			  "outputs": ["status", "attempts_used"],
			  "params": { "N0": 1, "alpha": 1.0, "beta": 1.0, "tau_recovery": "ticks" },
			  "steps": [
				"1) N_max ‚Üê N0 + alpha*EMA32(stability) - beta*EMA16(violation_rate)",
				"2) for i in 1..ceil(max(1, N_max)):",
				"3)     candidate ‚Üê last_lawful(snapshot_history, window=tau_recovery)",
				"4)     if candidate == null: break",
				"5)     stage(candidate)  # observer staging only",
				"6)     if lawful(candidate): emit_telemetry('reanchor_success', {window_id}); return {'status':'reanchored','attempts_used':i}",
				"7)     emit_telemetry('reanchor_attempt', {window_id, i})",
				"8) if overlaps(window_id) OR i exhausted: return {'status':'escalate_quarantine','attempts_used':i}"
			  ],
			  "invariants": [
				"Compress-before-prune (capacity-first) remains in force if recovery suggests storage changes downstream."
			  ]
			},
			{
			  "name": "quarantine_protocol",
			  "role": "observer",
			  "inputs": ["window_id", "quarantined_set"],
			  "outputs": ["status"],
			  "params": { "perturbation_cap": 0.01, "J_max": 1.0, "quarantine_ttl": "ticks" },
			  "steps": [
				"1) for motif in quarantined_set until ttl:",
				"2)     micro_adjust ‚Üê bounded({lambda, gamma_co}, perturbation_cap)  # simulation-only, no writes",
				"3)     J_local ‚Üê jacobian_estimate({lambda, gamma_co, SII}, window='EMA-16')",
				"4)     if (Œî_closure ‚Üì) AND (||J_local|| ‚â§ J_max):",
				"5)         emit_telemetry('diagnostic_pass', {motif}); mark_for_reanchor(motif)",
				"6)     else emit_telemetry('diagnostic_retry', {motif})",
				"7) if any marked_for_reanchor: return {'status':'recovery_ready'}",
				"8) if ttl expired: return {'status':'hold_quarantine'}"
			  ],
			  "invariants": [
				"Diagnostics are measurement-class experiments; they neither mutate Œû nor persist control changes."
			  ]
			},
			{
			  "name": "finalize_termination_state",
			  "role": "observer",
			  "inputs": ["reanchor_result", "quarantine_result"],
			  "outputs": ["termination_state"],
			  "params": {},
			  "steps": [
				"1) if reanchor_result.status == 'reanchored': return 'reanchored'",
				"2) if quarantine_result.status ‚àà {'recovery_ready','hold_quarantine'}: return 'quarantined'",
				"3) else: return 'abandoned'"
			  ],
			  "invariants": [
				"Every episode ends in exactly one of {reanchored, quarantined, abandoned}; emit immutable audit trail."
			  ]
			},
			{
			  "name": "adversarial_degrade_handler",
			  "role": "observer",
			  "inputs": ["packet_view", "feature_flags"],
			  "outputs": ["status"],
			  "params": {},
			  "steps": [
				"1) if packet_view appears structurally valid (e.g., envelope present per ¬ß4.1) but coherence fields (C, rho_res) are inconsistent:",
				"2)     emit_telemetry('adversarial_suspect')",
				"3)     result ‚Üê reanchor_protocol(window_id=new_window(), snapshot_history, params)",
				"4)     if result.status != 'reanchored':",
				"5)         q ‚Üê quarantine_protocol(window_id=current_window(), quarantined_set={packet_view})",
				"6)         if q.status == 'recovery_ready': return 'quarantined'",
				"7)         else return 'abandoned'",
				"8) else return 'reanchored'"
			  ],
			  "invariants": [
				"Graceful degrade: never crash-loop; always converge to a termination state with telemetry."
			  ]
			}
		  ],
		  "invariants": [
			{
			  "name": "Lawful_Decay",
			  "condition": "C evolves under lambda - gamma_co + epsilon; C ‚àà [0,1].",
			  "source": "RFC-0005 ¬ß3‚Äì¬ß4"
			},
			{
			  "name": "Bounded_Recovery",
			  "condition": "Attempts ‚â§ N_max(t); windows ‚â§ tau_recovery.",
			  "source": "RFC-0009 ¬ß5‚Äì¬ß7"
			},
			{
			  "name": "Deterministic_Termination",
			  "condition": "Each episode ends in {reanchored, quarantined, abandoned} with an audit trail.",
			  "source": "RFC-0009 ¬ß5.2"
			},
			{
			  "name": "Quarantine_Criteria",
			  "condition": "Escalate on overlap of windows or budget exhaustion; exit only with improving closure and bounded Jacobian.",
			  "source": "RFC-0009 ¬ß9.3‚Äì10.3"
			},
			{
			  "name": "Observer_Only",
			  "condition": "All steps are measurement, staging, or routing; no control writes to Œû.",
			  "source": "PDP-0001 ¬ß4.5"
			}
		  ],
		  "telemetry": [
			{
			  "metric": "integrity_violation_rate",
			  "range": "[0,1]",
			  "units": "events/tick",
			  "window": "EMA-32"
			},
			{
			  "metric": "reanchor_attempt_rate",
			  "range": "[0,1]",
			  "units": "events/tick",
			  "window": "EMA-32"
			},
			{
			  "metric": "reanchor_success_rate",
			  "range": "[0,1]",
			  "units": "events/tick",
			  "window": "EMA-32"
			},
			{
			  "metric": "quarantine_count",
			  "range": "[0,+inf)",
			  "units": "sets",
			  "window": "EMA-32"
			},
			{
			  "metric": "recovery_outcome_distribution",
			  "range": "[0,1]",
			  "units": "ratio",
			  "window": "EMA-64"
			},
			{
			  "metric": "diagnostic_jacobian_norm",
			  "range": "[0,J_max]",
			  "units": "unitless",
			  "window": "EMA-16"
			}
		  ],
		  "examples": [
			{
			  "name": "termination_states_table",
			  "version": "2025-Q4",
			  "active_when": "always",
			  "cases": [
				{ "condition": "lawful(candidate) true in ‚â§ N_max", "termination_state": "reanchored" },
				{ "condition": "overlap OR attempts exhausted, diagnostics improving but not stable", "termination_state": "quarantined" },
				{ "condition": "no lawful candidate and diagnostics fail/expire", "termination_state": "abandoned" }
			  ],
			  "notes": "All cases emit audit events and a sealed checkpoint for post-mortem."
			},
			{
			  "name": "adversarial_degrade_note",
			  "version": "2025-Q4",
			  "active_when": "always",
			  "description": "Import appears structurally valid but C fields corrupted. Handler performs bounded reanchor; failing that, escalates to quarantine and may end as abandoned‚Äîsystem remains stable with telemetry spikes on reanchor_fail."
			}
		  ],
		  "references": [
			"RFC-0005 ¬ß3‚Äì¬ß4 (Decay and replay discipline)",
			"RFC-0006 ¬ß3‚Äì¬ß4 (Closure/coherence geometry)",
			"RFC-0009 ¬ß5‚Äì¬ß7, ¬ß9‚Äì¬ß10 (Homeostasis, recovery, diagnostics, antifragility)",
			"PDP-0001 ¬ß4.5 (Observer-only posture)"
		  ],
		  "handoff": "With invariants fixed, we now carry the symbols forward to the next clause, keeping ùíû steady and the cadence light."
		},
      "4.3": {
		  "id": "4.3",
		  "title": "Security and Data Handling (L1 posture)",
		  "objective": "State Layer_1 security guarantees for exchange and storage: structural origin validation, envelope policy, lineage integrity, retention metadata, and observer-only posture. Cryptography, keystores, RBAC, consent, and remote trust are deferred to Layer_2 App-Specs.",
		  "summary": "Layer_1 secures signals by structure, not cryptography. Outbound artifacts are sealed with Sigma_phase and Delta_hash when enabled; imports are accepted only if lineage, origin seed, and envelope declarations are lawful. Wrapping rules forbid any Layer_2 component from presenting an unsigned payload inside an SRX envelope that claims a signed origin. Envelope signature-type declarations are validated against a local agent_id registry at Layer_1; cryptographic proof of signatures is a Layer_2 concern.",
		  "math": [
			{
			  "eq_id": "Eq.1",
			  "role": "retention_horizon",
			  "latex": "\\tau_{decay} = \\frac{1}{\\zeta}",
			  "gloss": "Retention policy at rest derives from lawful decay (RFC-0005 ¬ß4.2)."
			},
			{
			  "eq_id": "Eq.2",
			  "role": "lineage_chain",
			  "latex": "\\Delta_{hash}(t) = H(\\text{payload}_t \\Vert \\Delta_{hash}(t-1))",
			  "gloss": "Immutable integrity lineage for tamper evidence (RFC-0009 Appx D.4)."
			},
			{
			  "eq_id": "Eq.3",
			  "role": "envelope_policy_check",
			  "latex": "\\text{accept} := (\\Sigma_{phase}\\ \\text{present iff}\\ f_{env}) \\wedge (\\Delta_{hash}\\ \\text{present iff}\\ f_{int}) \\wedge (\\text{sig\\_type}\\in R_{agent}(\\text{origin}))",
			  "gloss": "Acceptance requires feature-flag-gated checksums and a signature-type declaration allowed for the origin's agent_id (structural check)."
			},
			{
			  "eq_id": "Eq.4",
			  "role": "weak_field_limit",
			  "latex": "\\mathcal{C} \\to 1",
			  "gloss": "In weak-field conditions, coherence approaches unity and security-side time windows stabilize."
			}
		  ],
		  "policies": {
			"transit_requirements": [
			  "All export_* SHALL include Sigma_phase when enable_exchange_envelope=true and Delta_hash when enable_integrity_checks=true.",
			  "Replay acceptance windows are enforced via SRX envelope semantics defined in ¬ß4.1; Layer_2 binds cryptographic verifiers.",
			  "Layer_1 verifies provenance.origin and declared envelope.sig_type against the local agent_id registry; cryptographic verification is deferred to Layer_2."
			],
			"wrapping_rules": [
			  "FORBID: Any Layer_2 component wrapping an unsigned payload in a valid-looking SRX envelope that claims a signed origin.",
			  "REJECT on import if envelope.sig_type declares a signing scheme not listed for provenance.origin.agent_id in the Layer_1 registry.",
			  "REJECT on import if enable_exchange_envelope=true but Sigma_phase is missing, or if enable_integrity_checks=true but Delta_hash is missing."
			],
			"at_rest_requirements": [
			  "Every persisted ontology bundle MUST declare storage_profile.profile in {volatile,durable} and storage_profile.retention_ticks seeded from tau_decay.",
			  "Provenance {origin, origin_hash, created_at} and lineage {parent_hash, integrity_hash} MUST be present and structurally valid before persistence.",
			  "No raw payloads without provenance/lineage metadata SHALL be persisted."
			],
			"compromise_posture": [
			  "On import failure (lineage mismatch, unrecognized seed, illegal sig_type): REJECT and emit near_miss without partial merges.",
			  "Observer-only: MMM SHALL NOT perform control writes to Œû; recovery invokes reanchor protocols defined in ¬ß4.2 and ¬ß2.3."
			],
			"origin_validation": [
			  "Layer_1 trusted root = local provenance registry of lawful origin seeds (structural, non-cryptographic).",
			  "origin_hash MUST equal H(origin_fields) per PDP-0001; if mismatch, REJECT."
			]
		  },
		  "algorithms": [
			{
			  "name": "validate_envelope_and_origin",
			  "role": "observer",
			  "inputs": ["packet", "feature_flags", "agent_registry", "trusted_root_registry"],
			  "outputs": ["status"],
			  "params": [],
			  "steps": [
				"1. if feature_flags.enable_exchange_envelope == true and packet.Sigma_phase is absent: return status='reject:missing_Sigma_phase'.",
				"2. if feature_flags.enable_integrity_checks == true and packet.Delta_hash is absent: return status='reject:missing_Delta_hash'.",
				"3. if packet.provenance.origin not in trusted_root_registry: return status='reject:unrecognized_origin'.",
				"4. recompute origin_hash from packet.provenance; if mismatch: return status='reject:origin_hash_mismatch'.",
				"5. sig_ok <- packet.envelope.sig_type in agent_registry[packet.provenance.origin.agent_id].allowed_sig_types.",
				"6. if sig_ok == false: return status='reject:illegal_sig_type'.",
				"7. return status='accept:structurally_valid'."
			  ],
			  "comment": "Structural validation only; cryptographic signature verification is deferred to Layer_2."
			},
			{
			  "name": "enforce_retention_policy",
			  "role": "observer",
			  "inputs": ["bundle", "tau_decay"],
			  "outputs": ["action"],
			  "params": [],
			  "steps": [
				"1. bundle.storage_profile.retention_ticks <- max(bundle.storage_profile.retention_ticks, tau_decay).",
				"2. if bundle.timestamp + bundle.storage_profile.retention_ticks < now_tick: action <- 'expire'; else action <- 'retain'.",
				"3. return action."
			  ],
			  "comment": "Maps at-rest retention to lawful decay horizon."
			},
			{
			  "name": "reject_wrapped_unsigned",
			  "role": "observer",
			  "inputs": ["packet"],
			  "outputs": ["status"],
			  "params": [],
			  "steps": [
				"1. if packet.envelope.claims_signed == true AND (packet.signature_block == null OR packet.signature_block == 'stub'):",
				"2.     return status='reject:wrapped_unsigned'.",
				"3. return status='noop'."
			  ],
			  "comment": "Explicit confused-deputy mitigation: deny envelopes that claim signing without a real signature block (Layer_2 will define cryptographic checks)."
			}
		  ],
		  "invariants": [
			{
			  "name": "Checksum_Gating",
			  "condition": "Sigma_phase present iff enable_exchange_envelope=true; Delta_hash present iff enable_integrity_checks=true.",
			  "source": "RFC-0008 ¬ß5.3; RFC-0009 Appx D.4"
			},
			{
			  "name": "No_Unsigned_Wrapping",
			  "condition": "Packets claiming signed origin shall not be accepted without a non-empty signature_block and legal envelope.sig_type.",
			  "source": "RFC-0008 ¬ß5‚Äì¬ß6"
			},
			{
			  "name": "Provenance_Lineage_Required",
			  "condition": "Provenance and lineage blocks must be present and structurally valid before persistence or import.",
			  "source": "RFC-0007 ¬ß5‚Äì¬ß6, ¬ß8; PDP-0001 ¬ß4.4"
			},
			{
			  "name": "Observer_Only_Posture",
			  "condition": "All checks and decisions are measurement, staging, and routing; no control writes to Œû.",
			  "source": "PDP-0001 ¬ß4.5"
			},
			{
			  "name": "Weak_Field_Convergence",
			  "condition": "As C->1, time windowing and envelope admissions stabilize; security telemetry drifts to steady-state.",
			  "source": "RFC-0006 ¬ß1.1"
			}
		  ],
		  "telemetry": [
			{
			  "metric": "import_reject_missing_checksum",
			  "range": "[0,1]",
			  "units": "events/tick",
			  "window": "EMA-32",
			  "dashboard": "security/exchange",
			  "description": "Rate of rejections due to missing Sigma_phase or Delta_hash when required."
			},
			{
			  "metric": "illegal_sig_type_rate",
			  "range": "[0,1]",
			  "units": "events/tick",
			  "window": "EMA-32",
			  "dashboard": "security/policy",
			  "description": "Incidence of envelopes declaring signature types not permitted for the origin agent_id."
			},
			{
			  "metric": "wrapped_unsigned_rejects",
			  "range": "[0,1000]",
			  "units": "events",
			  "window": "EMA-32",
			  "dashboard": "security/policy",
			  "description": "Count of explicit rejections for unsigned payloads wrapped as if signed."
			},
			{
			  "metric": "at_rest_expirations",
			  "range": "[0,+inf)",
			  "units": "events",
			  "window": "EMA-32",
			  "dashboard": "security/storage",
			  "description": "Number of bundles expired due to retention policy derived from tau_decay."
			},
			{
			  "metric": "staging_quarantine_count",
			  "range": "[0,+inf)",
			  "units": "events",
			  "window": "EMA-32",
			  "dashboard": "security/staging",
			  "description": "Total imports routed to quarantine staging (unknown seed, lineage mismatch, illegal sig_type)."
			},
			{
			  "metric": "unknown_seed_rate",
			  "range": "[0,1]",
			  "units": "events/tick",
			  "window": "EMA-32",
			  "dashboard": "security/staging",
			  "description": "Rate of packets whose provenance.origin is not in the trusted root registry."
			},
			{
			  "metric": "replay_drop_rate",
			  "range": "[0,1]",
			  "units": "events/tick",
			  "window": "EMA-32",
			  "dashboard": "exchange/timing",
			  "description": "Drops due to duplicates detected by the seen_set within the ŒîœÑ_phase-derived window."
			},
			{
			  "metric": "accepted_within_window",
			  "range": "[0,1]",
			  "units": "fraction",
			  "window": "EMA-32",
			  "dashboard": "exchange/timing",
			  "description": "Share of accepted packets that arrive within the current Œ£_phase acceptance horizon."
			}
		  ],
		  "references": [
			"RFC-0005 ¬ß4.2 (Decay and retention horizon)",
			"RFC-0007 ¬ß5‚Äì¬ß6, ¬ß8 (Ontology provenance and DAG validity)",
			"RFC-0008 ¬ß2.1, ¬ß5‚Äì¬ß6 (SRX envelope, routing, policy semantics)",
			"RFC-0009 ¬ß5.1, ¬ß7.2, ¬ß9.3; Appx D.4 (Integrity lineage, telemetry, tamper evidence)",
			"PDP-0001 ¬ß3.1, ¬ß4.4‚Äì¬ß4.5 (Provenance structure, observer-only discipline)"
		  ],
		  "handoff": "Layer-1 complete; encryption and roles await their Layer-2 home."
		}
	},

    "5": {
      "id": "5",
	  "title": "Observability, Ethics, and Policy",
	  "5.1": {
		  "id": "5.1",
		  "title": "Observability and Metrics",
		  "objective": "Provide live monitoring of memory coherence, resonance, lawful decay, safety recovery, and saturation, with export sealing gated by feature flags and all behavior remaining observer-only at Layer_1.",
		  "math": [
			{
			  "eq_id": "Eq.1",
			  "role": "governing_law",
			  "latex": "\\frac{d\\mathcal{C}}{dt} = \\lambda - \\gamma_{co} + \\varepsilon",
			  "gloss": "Coherence evolves as reinforcement minus adaptive damping plus noise; all KPIs are measurements of this law."
			},
			{
			  "eq_id": "Eq.2",
			  "role": "saturation_level",
			  "latex": "\\eta_{occ} = \\frac{LTMM_{usage}}{C_{max}}",
			  "gloss": "Normalized occupancy used to gate compression and pruning recommendations."
			},
			{
			  "eq_id": "Eq.3",
			  "role": "replay_window",
			  "latex": "\\Delta\\tau_{phase} = \\alpha\\,EMA_{32}(\\mathcal{C})",
			  "gloss": "Adaptive acceptance window for exchange timing telemetry."
			},
			{
			  "eq_id": "Eq.4",
			  "role": "compression_ratio_preprune",
			  "latex": "\\text{lawful\\_compression\\_ratio} = \\frac{\\text{post\\_equiv\\_count}}{\\text{pre\\_equiv\\_count}}",
			  "gloss": "Compression measured strictly before any pruning (capacity-first)."
			},
			{
			  "eq_id": "Limit.1",
			  "role": "weak_field",
			  "latex": "\\mathcal{C} \\to 1",
			  "gloss": "In weak-field conditions, KPIs converge and drift diminishes."
			}
		  ],
		  "algorithms": [
			{
			  "name": "compute_resonance_band_share",
			  "role": "observer",
			  "inputs": ["trace_entries_window"],
			  "outputs": ["rho_res_band_share"],
			  "params": ["band=[0.3,0.7]", "window='EMA-32'"],
			  "steps": [
				"1. r <- fraction of entries with rho_res in band.",
				"2. rho_res_band_share <- EMA-32(r).",
				"3. return rho_res_band_share."
			  ],
			  "comment": "Shared utility for dashboards; no control writes to Œû."
			},
			{
			  "name": "compute_compression_kpis",
			  "role": "observer",
			  "inputs": ["pre_equiv_count", "post_equiv_count"],
			  "outputs": ["lawful_compression_ratio", "equivalence_efficiency"],
			  "params": [],
			  "steps": [
				"1. if pre_equiv_count == 0: return lawful_compression_ratio=1.0, equivalence_efficiency=0.0.",
				"2. lawful_compression_ratio <- post_equiv_count / pre_equiv_count.",
				"3. equivalence_efficiency <- (pre_equiv_count - post_equiv_count) / pre_equiv_count.",
				"4. return lawful_compression_ratio, equivalence_efficiency."
			  ],
			  "comment": "Snapshot computed strictly pre-prune to enforce capacity-first policy."
			},
			{
			  "name": "rollup_observability_window",
			  "role": "observer",
			  "inputs": ["trace_entries_window", "feature_flags", "C_max", "LTMM_usage", "Delta_tau_phase"],
			  "outputs": ["metrics_snapshot"],
			  "params": ["windows={means:'EMA-64', rates:'EMA-32'}"],
			  "steps": [
				"1. Q_coh <- EMA-64(mean(C)).",
				"2. Q_res <- EMA-64(mean(rho_res)).",
				"3. rho_res_band_share <- compute_resonance_band_share(trace_entries_window).",
				"4. saturation_level <- EMA-32(LTMM_usage / C_max) = EMA-32(eta_occ).",
				"5. promotion_rate <- EMA-32(count(event=='promote')/tick).",
				"6. reanchor_rate <- EMA-32(count(event=='reanchor_attempt')/tick).",
				"7. quarantine_count <- EMA-32(current_quarantine_sets).",
				"8. avg_replay_window_ticks <- EMA-32(Delta_tau_phase).",
				"9. if feature_flags.enable_point_space_gliders==true: glider_detected <- EMA-16(count(event=='glider_detected')); glider_canonical_count <- EMA-16(size(glider_canonical_index)).",
				"10. return metrics_snapshot (ASCII keys, windows annotated)."
			  ],
			  "comment": "Aggregates means and rates; glider gauges are flag-gated."
			},
			{
			  "name": "export_metrics_packet",
			  "role": "observer",
			  "inputs": ["metrics_snapshot", "feature_flags", "provenance", "last_Delta_hash", "T_mu"],
			  "outputs": ["packet"],
			  "params": ["rate_limit_qps=4"],
			  "steps": [
				"1. packet <- { kind:'metrics', version:'2025-Q4', body:metrics_snapshot, provenance }.",
				"2. if feature_flags.enable_exchange_envelope==true: packet.Sigma_phase <- phase_checksum(packet.body, T_mu).",
				"3. if feature_flags.enable_integrity_checks==true: packet.Delta_hash <- hash_lineage(packet.body, last_Delta_hash).",
				"4. if feature_flags.enable_provenance_on_export==true: packet.provenance.origin_hash <- H(provenance).",
				"5. enforce rate_limit_qps and emit."
			  ],
			  "comment": "Seals metrics for SRX routing; checksums are strictly flag-gated (no stubs)."
			}
		  ],
		  "telemetry": [
			{
			  "metric": "rfc0009_Q_coh",
			  "range": "[0,1]",
			  "units": "dimensionless",
			  "window": "EMA-64",
			  "dashboard": "memory/homeostasis",
			  "description": "Mean coherence level C."
			},
			{
			  "metric": "rfc0009_Q_res",
			  "range": "[0,1]",
			  "units": "dimensionless",
			  "window": "EMA-64",
			  "dashboard": "memory/triad_closure",
			  "description": "Mean resonance coefficient rho_res."
			},
			{
			  "metric": "rho_res_band_share",
			  "range": "[0,1]",
			  "units": "fraction",
			  "window": "EMA-32",
			  "dashboard": "memory/triad_closure",
			  "description": "Share of motifs with rho_res in the stability band [0.3,0.7]."
			},
			{
			  "metric": "lawful_compression_ratio",
			  "range": "[0,1]",
			  "units": "dimensionless",
			  "window": "EMA-32",
			  "dashboard": "memory/saturation",
			  "description": "Post-equivalence size divided by pre-equivalence size (no pruning)."
			},
			{
			  "metric": "equivalence_efficiency",
			  "range": "[0,1]",
			  "units": "fraction",
			  "window": "EMA-32",
			  "dashboard": "memory/saturation",
			  "description": "Capacity relief due to equivalence compression before pruning."
			},
			{
			  "metric": "ethical_ttl_floor",
			  "range": "[0,+inf)",
			  "units": "ticks",
			  "window": "EMA-16",
			  "dashboard": "memory/security_policy",
			  "description": "Effective minimum retention bound = max(\\tau_decay, 10¬∑\\Delta t_tick)."
			},
			{
			  "metric": "ttl_max_effective",
			  "range": "[0,+inf)",
			  "units": "ticks",
			  "window": "EMA-16",
			  "dashboard": "memory/security_policy",
			  "description": "Current configured maximum retention horizon after policy pressure."
			},
			{
			  "metric": "staleness_index",
			  "range": "[0,1]",
			  "units": "fraction",
			  "window": "EMA-32",
			  "dashboard": "memory/health",
			  "description": "Normalized idle_time signal indicating share of motifs approaching decay."
			},
			{
			  "metric": "saturation_level",
			  "range": "[0,1]",
			  "units": "fraction",
			  "window": "EMA-32",
			  "dashboard": "memory/saturation",
			  "description": "LTMM occupancy eta_occ = LTMM_usage/C_max."
			},
			{
			  "metric": "memory_promotion_rate",
			  "range": "[0,1]",
			  "units": "events/tick",
			  "window": "EMA-32",
			  "dashboard": "memory/triad_closure",
			  "description": "Fraction of STMM‚ÜíLTMM promotions per tick."
			},
			{
			  "metric": "reanchor_rate",
			  "range": "[0,1]",
			  "units": "events/tick",
			  "window": "EMA-32",
			  "dashboard": "memory/recovery",
			  "description": "Rate of reanchor_attempt events (bounded recovery activity)."
			},
			{
			  "metric": "quarantine_count",
			  "range": "[0,+inf)",
			  "units": "sets",
			  "window": "EMA-32",
			  "dashboard": "memory/recovery",
			  "description": "Number of motif sets currently quarantined after escalation."
			},
			{
			  "metric": "avg_replay_window_ticks",
			  "range": "[0,+inf)",
			  "units": "ticks",
			  "window": "EMA-32",
			  "dashboard": "exchange/timing",
			  "description": "Observed average \\Delta\\tau_phase derived window for packet acceptance."
			},
			{
			  "metric": "glider_detected",
			  "range": "[0,+inf)",
			  "units": "count",
			  "window": "EMA-16",
			  "dashboard": "memory/glider_flow",
			  "active_when": "enable_point_space_gliders=true",
			  "description": "Count of glider detection events within the window."
			},
			{
			  "metric": "glider_canonical_count",
			  "range": "[0,+inf)",
			  "units": "count",
			  "window": "EMA-16",
			  "dashboard": "memory/glider_flow",
			  "active_when": "enable_point_space_gliders=true",
			  "description": "Number of canonical shift-equivalence representatives stored."
			}
		  ],
		  "dashboards": [
			"memory/homeostasis",
			"memory/triad_closure",
			"memory/resource_usage",
			"memory/saturation",
			"memory/health",
			"memory/recovery",
			"exchange/timing",
			"memory/glider_flow"
		  ],
		  "invariants": [
			{
			  "name": "Observer_Only_Posture",
			  "condition": "Metric rollups and exports are measurement/sealing/routing only; no control writes to \\Xi.",
			  "source": "PDP-0001 ¬ß4.5"
			},
			{
			  "name": "Window_Discipline",
			  "condition": "EMA windows limited to {EMA-16, EMA-32, EMA-64}; means use EMA-64, rates use EMA-32 unless otherwise stated.",
			  "source": "RFC-0009 ¬ß7.1‚Äì¬ß7.3"
			},
			{
			  "name": "Compression_Before_Pruning",
			  "condition": "All pruning recommendations are preceded by an equivalence compression snapshot and its KPIs.",
			  "source": "RFC-0006 ¬ß4.4; RFC-0009 ¬ß7.1"
			},
			{
			  "name": "Checksum_Gating",
			  "condition": "Sigma_phase present iff enable_exchange_envelope=true; Delta_hash present iff enable_integrity_checks=true.",
			  "source": "RFC-0008 ¬ß5.3; RFC-0009 Appx D.4"
			},
			{
			  "name": "Glider_Gating",
			  "condition": "Glider-related metrics are emitted only when enable_point_space_gliders=true.",
			  "source": "RFC-0006 ¬ß4.4"
			}
		  ],
		  "references": [
			"RFC-0005 ¬ß3‚Äì¬ß4 (Transmission/decay and retention horizons)",
			"RFC-0006 ¬ß3‚Äì¬ß4 (Coherence geometry, equivalence, closure)",
			"RFC-0008 ¬ß2‚Äì¬ß3, ¬ß5.3 (SRX timing, envelope, phase checksum)",
			"RFC-0009 ¬ß7.1‚Äì¬ß9.3; Appx D.4 (Homeostasis, telemetry, integrity lineage)",
			"PDP-0001 ¬ß4.4‚Äì¬ß4.5 (Provenance structure; observer-only posture)"
		  ],
		  "handoff": "With invariants fixed, we now carry the symbols forward to the next clause, keeping ùíû steady and the cadence light."
		},
      "5.2": {
		  "id": "5.2",
		  "title": "Ethics and Data Retention Policy",
		  "objective": "Establish Layer_1 ethical constraints and lawful retention behavior for motif memory: observer-only posture, decay-as-forgetting rather than deletion, provenance-and-lineage requirements for any resurrection, and sealed exports gated by feature flags.",
		  "math": [
			{
			  "eq_id": "Eq.1",
			  "role": "lawful_decay",
			  "latex": "\\tau_{decay} = \\frac{1}{\\zeta}",
			  "gloss": "Decay horizon derives from the damping slope; retention policies seed from this horizon."
			},
			{
			  "eq_id": "Eq.2",
			  "role": "ttl_policy_bound",
			  "latex": "\\tau_{decay} \\;>\\; 10\\,\\Delta t_{tick}",
			  "gloss": "Minimum ethical bound ensuring forgetting is gradual, not abrupt deletion."
			},
			{
			  "eq_id": "Eq.3",
			  "role": "lineage_chain",
			  "latex": "\\Delta_{hash}(t) = H\\big(\\text{payload}_t \\Vert \\Delta_{hash}(t-1)\\big)",
			  "gloss": "Integrity lineage required for resurrection to establish provenance continuity."
			},
			{
			  "eq_id": "Eq.4",
			  "role": "homeostasis_guard",
			  "latex": "RIR \\cdot SII \\approx k_{homeostasis}",
			  "gloss": "Ethical retention should preserve stability; large deviations trigger recovery rather than forced persistence."
			},
			{
			  "eq_id": "Limit.1",
			  "role": "weak_field",
			  "latex": "\\mathcal{C} \\to 1",
			  "gloss": "In the weak-field regime, coherence stabilizes and retention expirations converge to steady-state cadence."
			}
		  ],
		  "algorithms": [
			{
			  "name": "enforce_retention_policy",
			  "role": "observer",
			  "inputs": ["bundle", "now_tick", "tau_decay", "feature_flags"],
			  "outputs": ["action"],
			  "params": ["ttl_floor_factor = 10", "tick_interval = Delta_t_tick"],
			  "steps": [
				"1. ttl_min ‚Üê max(tau_decay, ttl_floor_factor * tick_interval).",
				"2. if bundle.storage_profile.retention_ticks < ttl_min then bundle.storage_profile.retention_ticks ‚Üê ttl_min.",
				"3. if bundle.timestamp + bundle.storage_profile.retention_ticks < now_tick then action ‚Üê 'expire' else action ‚Üê 'retain'.",
				"4. return action."
			  ],
			  "comment": "Maps ethical bound Eq.2 into storage_profile; never performs control writes to Œû."
			},
			{
			  "name": "validate_resurrection_lineage",
			  "role": "observer",
			  "inputs": ["resurrection_request", "feature_flags", "parent_Delta_hash"],
			  "outputs": ["status"],
			  "params": [],
			  "steps": [
				"1. require presence of provenance {origin, origin_hash, created_at} and lineage {parent_hash, integrity_hash, schema}.",
				"2. recompute integrity_hash' ‚Üê H(meta || data) and compare to lineage.integrity_hash; reject if mismatch.",
				"3. verify parent_hash matches parent_Delta_hash; reject if mismatch.",
				"4. if feature_flags.enable_integrity_checks == true then require Delta_hash chain continuity; reject on break.",
				"5. return status ‚àà {'accepted','rejected'}."
			  ],
			  "comment": "Resurrection is lawful iff provenance and integrity lineage validate; strictly observer-class verification."
			},
			{
			  "name": "seal_export_ethically",
			  "role": "observer",
			  "inputs": ["payload", "provenance", "last_Delta_hash", "T_mu", "feature_flags"],
			  "outputs": ["packet"],
			  "params": [],
			  "steps": [
				"1. packet ‚Üê { body:payload, provenance }.",
				"2. if feature_flags.enable_exchange_envelope == true then packet.Sigma_phase ‚Üê phase_checksum(packet.body, T_mu).",
				"3. if feature_flags.enable_integrity_checks == true then packet.Delta_hash ‚Üê hash_lineage(packet.body, last_Delta_hash).",
				"4. if feature_flags.enable_provenance_on_export == true then attach provenance.origin_hash.",
				"5. return packet."
			  ],
			  "comment": "Seals outbound artifacts without implying cryptographic verification at Layer_1; checksums are flag-gated."
			}
		  ],
		  "principles": [
			"Motif memories are observer-class; never writable by control agents.",
			"Decay is lawful forgetting, not deletion; TTL windows must satisfy tau_decay > 10√ó tick interval.",
			"All resurrected motifs carry provenance chain validated through Delta_hash lineage.",
			"Exports are sealed structurally (Sigma_phase, Delta_hash) only when flags enable them; external cryptography is deferred to Layer_2.",
			"Reject resurrection or import if provenance or lineage is incomplete, cyclic, or mismatched."
		  ],
		  "invariants": [
			{
			  "name": "Observer_Only_Posture",
			  "condition": "All ethics and retention actions are measurement, staging, sealing, and routing only; no control writes to Xi.",
			  "source": "PDP-0001 ¬ß4.5"
			},
			{
			  "name": "Lawful_Retention",
			  "condition": "retention_ticks ‚â• max(tau_decay, 10¬∑Delta_t_tick) before expiry evaluation.",
			  "source": "RFC-0005 ¬ß4.2"
			},
			{
			  "name": "Lineage_Before_Resurrection",
			  "condition": "Resurrection requires validated provenance and a continuous Delta_hash chain.",
			  "source": "RFC-0009 Appx D.4; RFC-0007 ¬ß5‚Äì¬ß6, ¬ß8"
			},
			{
			  "name": "Checksum_Gating",
			  "condition": "Sigma_phase present iff enable_exchange_envelope=true; Delta_hash present iff enable_integrity_checks=true.",
			  "source": "RFC-0008 ¬ß5.3; RFC-0009 Appx D.4"
			}
		  ],
		  "telemetry": [
			{
			  "metric": "retention_expirations",
			  "range": "[0,+inf)",
			  "units": "events",
			  "window": "EMA-32",
			  "dashboard": "memory/saturation",
			  "description": "Count of bundles expired due to lawful retention policy."
			},
			{
			  "metric": "resurrection_rejects_lineage",
			  "range": "[0,+inf)",
			  "units": "events",
			  "window": "EMA-32",
			  "dashboard": "memory/recovery",
			  "description": "Rejections caused by missing or invalid provenance/Delta_hash lineage."
			},
			{
			  "metric": "ttl_policy_violations",
			  "range": "[0,+inf)",
			  "units": "events",
			  "window": "EMA-16",
			  "dashboard": "memory/security_policy",
			  "description": "Detected attempts to set retention below the ethical bound."
			},
			{
			  "metric": "observer_write_attempts",
			  "range": "[0,+inf)",
			  "units": "events",
			  "window": "EMA-16",
			  "dashboard": "memory/security_policy",
			  "description": "Incidents where a control write to Xi was attempted against policy (should remain zero)."
			}
		  ],
		  "references": [
			"RFC-0005 ¬ß4.2 (Temporal decay and retention horizons)",
			"RFC-0007 ¬ß5‚Äì¬ß6, ¬ß8 (Ontology provenance and DAG validity)",
			"RFC-0008 ¬ß5.3 (Exchange envelope and phase checksum semantics)",
			"RFC-0009 ¬ß12; Appx D.4 (Ethics and integrity lineage)",
			"PDP-0001 ¬ß4.4‚Äì¬ß4.5 (Provenance structure, observer-only discipline)"
		  ],
		  "handoff": "With invariants fixed, we now carry the symbols forward to the next clause, keeping ùíû steady and the cadence light."
		}
    },

    "appendix": {
      "a": {
		  "id": "A",
		  "title": "Appendix A ‚Äî Worked Examples and Mathematical Supplement",
		  "objective": "Provide lintable, Layer_1‚Äìconformant worked examples and derivations that instantiate the governing laws, exchange/integrity sealing, recovery paths, shift-equivalence compression, and dashboard bindings for observability. All examples use ASCII keys on-wire and respect feature flags.",
		  "math": [
			{
			  "eq_id": "A.0",
			  "role": "governing_law",
			  "latex": "\\frac{d\\mathcal{C}}{dt} = \\lambda - (\\gamma_{co}+\\gamma_{stale}) + \\varepsilon",
			  "gloss": "Core evolution law: reinforcement minus adaptive/co-staleness damping plus small perturbation."
			},
			{
			  "eq_id": "A.1",
			  "role": "decay_horizon",
			  "latex": "\\tau_{decay} = \\zeta^{-1}",
			  "gloss": "Retention horizon derived from damping slope."
			},
			{
			  "eq_id": "A.2a",
			  "role": "ethical_floor_def",
			  "latex": "TTL_{floor} = \\max\\big(\\tau_{decay},\\;10\\,\\Delta t_{tick}\\big)",
			  "gloss": "Ethical retention floor combines physical decay and minimum tick multiple."
			},
			{
			  "eq_id": "A.2b",
			  "role": "retention_bound",
			  "latex": "TTL_{floor} \\leq TTL \\leq TTL_{max}(t)",
			  "gloss": "Lawful retention must lie between ethical floor and time-varying maximum."
			},
			{
			  "eq_id": "A.3",
			  "role": "phase_window",
			  "latex": "\\Delta\\tau_{phase} = \\alpha\\,EMA_{32}(\\mathcal{C})\\,,\\quad \\alpha\\in[0.5,2.0]",
			  "gloss": "Adaptive replay/acceptance window for exchange timing."
			},
			{
			  "eq_id": "A.3b",
			  "role": "replay_seen_set_window",
			  "latex": "Window_{seen\\_set} = 2\\,\\Delta\\tau_{phase}",
			  "gloss": "Seen-set horizon for replay defense; LRU eviction within this window."
			},
			{
			  "eq_id": "A.4",
			  "role": "compression_ratio",
			  "latex": "LCR = \\frac{\\text{post\\_equiv\\_count}}{\\text{pre\\_equiv\\_count}}",
			  "gloss": "Lawful compression ratio measured strictly pre-prune."
			},
			{
			  "eq_id": "A.5",
			  "role": "equivalence_efficiency",
			  "latex": "\\mathrm{eff}_{eq} = 1 - LCR = \\frac{\\text{pre\\_equiv\\_count}-\\text{post\\_equiv\\_count}}{\\text{pre\\_equiv\\_count}}",
			  "gloss": "Capacity relief achieved by shift-equivalence compression."
			},
			{
			  "eq_id": "Limit.A",
			  "role": "weak_field",
			  "latex": "\\mathcal{C} \\to 1",
			  "gloss": "Weak-field limit: coherence and KPI drift converge."
			}
		  ],
		  "sections": [
			"a.1": {
			  "id": "A.1",
			  "title": "Worked Example ‚Äî Saturation Dynamics (Capacity-First)",
			  "objective": "Demonstrate the lawful order of operations under memory pressure: promotion gating ‚Üí shift-equivalence compression snapshot (pre-prune KPIs) ‚Üí prune only if still saturated.",
			  "math": [
				{
				  "eq_id": "A.1.0",
				  "role": "governing_law",
				  "latex": "\\frac{d\\mathcal{C}}{dt}=\\lambda-(\\gamma_{co}+\\gamma_{stale})+\\varepsilon",
				  "gloss": "Reinforcement opposed by adaptive damping and staleness; small perturbation term."
				},
				{
				  "eq_id": "A.1.1",
				  "role": "saturation_bounds",
				  "latex": "\\text{If } \\text{occupancy}\\,\\ge\\,\\theta_{sat} \\text{ then compress-by-equivalence before any prune; prune only if occupancy}_{\\text{post-equiv}}\\,\\ge\\,\\theta_{prune}}",
				  "gloss": "Capacity-first ordering: compression precedes any destructive step."
				},
				{
				  "eq_id": "A.1.2",
				  "role": "compression_ratio",
				  "latex": "LCR = \\frac{\\text{post\\_equiv\\_count}}{\\text{pre\\_equiv\\_count}}",
				  "gloss": "Lawful compression ratio measured strictly before any prune."
				},
				{
				  "eq_id": "A.1.3",
				  "role": "equivalence_efficiency",
				  "latex": "\\mathrm{eff}_{eq}=1-LCR=\\frac{\\text{pre\\_equiv\\_count}-\\text{post\\_equiv\\_count}}{\\text{pre\\_equiv\\_count}}",
				  "gloss": "Capacity relief achieved by shift-equivalence compression."
				},
				{
				  "eq_id": "Limit.A.1",
				  "role": "weak_field",
				  "latex": "\\mathcal{C}\\to 1",
				  "gloss": "Weak-field limit: coherence and KPI drift converge."
				}
			  ],
			  "algorithms": [
				{
				  "name": "promotion_gating",
				  "role": "observer",
				  "inputs": ["C", "occupancy", "theta_promote_cap", "lambda_thresh", "delta_closure", "rho_res"],
				  "outputs": ["promotion_allowed"],
				  "params": ["window='EMA-64'", "rho_band=[0.3,0.7]"],
				  "steps": [
					"1. c_bar <- EMA(window, C).",
					"2. cap_gate <- (occupancy < theta_promote_cap).",
					"3. band_gate <- (rho_res in rho_band).",
					"4. closure_gate <- (delta_closure <= delta_closure_max).",
					"5. rate_gate <- (c_bar >= lambda_thresh).",
					"6. promotion_allowed <- cap_gate AND band_gate AND closure_gate AND rate_gate.",
					"7. return promotion_allowed."
				  ]
				},
				{
				  "name": "equivalence_compression_snapshot",
				  "role": "observer",
				  "inputs": ["pre_equiv_count"],
				  "outputs": ["lawful_compression_ratio", "equivalence_efficiency", "post_equiv_count"],
				  "params": [],
				  "steps": [
					"1. Map entries to shift-equivalence classes (no prune).",
					"2. post_equiv_count <- count(unique canonical representatives).",
					"3. if pre_equiv_count == 0: lawful_compression_ratio <- 1.0; equivalence_efficiency <- 0.0; else:",
					"4. lawful_compression_ratio <- post_equiv_count / pre_equiv_count.",
					"5. equivalence_efficiency <- 1 - lawful_compression_ratio.",
					"6. Emit snapshot to telemetry; proceed to saturation check."
				  ]
				},
				{
				  "name": "conditional_prune_if_still_saturated",
				  "role": "observer",
				  "inputs": ["occupancy_post_equiv", "theta_sat", "theta_prune"],
				  "outputs": ["prune_decision"],
				  "params": [],
				  "steps": [
					"1. if occupancy_post_equiv < theta_sat: prune_decision <- false; return.",
					"2. if occupancy_post_equiv >= theta_prune: prune_decision <- true; else prune_decision <- false.",
					"3. Record prune_decision and, if true, emit prune_events++."
				  ]
				}
			  ],
			  "invariants": [
				{
				  "name": "Compress_Before_Prune",
				  "condition": "Shift-equivalence compression MUST be performed and snapshotted prior to any pruning.",
				  "source": "RFC-0006 ¬ß4.4; RFC-0009 ¬ß7.1"
				},
				{
				  "name": "Observer_Only",
				  "condition": "This example performs measurement, sealing, routing, and validation only; no control writes to Xi.",
				  "source": "PDP-0001 ¬ß4.5"
				},
				{
				  "name": "ASCII_On_Wire",
				  "condition": "All JSON keys are ASCII; math glyphs appear only inside latex strings.",
				  "source": "Authoring contract"
				}
			  ],
			  "example_json": {
				"window": "EMA-32",
				"theta_sat": 0.80,
				"theta_prune": 0.90,
				"occupancy_before": 0.91,
				"pre_equiv_count": 200,
				"post_equiv_count": 140,
				"lawful_compression_ratio": 0.70,
				"equivalence_efficiency": 0.30,
				"occupancy_post_equiv": 0.78,
				"C": 0.72,
				"lambda": 0.18,
				"gamma_co": 0.07,
				"gamma_stale": 0.02,
				"rho_res": 0.55,
				"delta_closure": 0.01,
				"promotion_allowed": true,
				"prune_decision": false,
				"notes": "Occupancy dropped below Œ∏_sat after equivalence compression; no prune executed. KPIs recorded pre-prune."
			  },
			  "telemetry": [
				{
				  "metric": "saturation_level",
				  "range": "[0,1]",
				  "units": "fraction",
				  "window": "EMA-32",
				  "description": "Proportion of LTMM capacity currently occupied."
				},
				{
				  "metric": "lawful_compression_ratio",
				  "range": "[0,1]",
				  "units": "dimensionless",
				  "window": "EMA-32",
				  "description": "post_equiv_count / pre_equiv_count measured strictly pre-prune."
				},
				{
				  "metric": "equivalence_efficiency",
				  "range": "[0,1]",
				  "units": "fraction",
				  "window": "EMA-32",
				  "description": "Capacity relief due to shift-equivalence compression (1 - LCR)."
				},
				{
				  "metric": "prune_events",
				  "range": "[0,+inf)",
				  "units": "count",
				  "window": "EMA-32",
				  "description": "Number of prune operations executed after compression."
				}
			  ],
			  "references": [
				"RFC-0006 ¬ß4.4 (Shift-equivalence compression; capacity law)",
				"RFC-0009 ¬ß7.1 (Homeostatic bounds and lawful saturation handling)",
				"RFC-0005 ¬ß4.2 (Temporal decay and retention horizons)",
				"PDP-0001 ¬ß4.5 (Observer-only posture)"
			  ],
			  "handoff": "With the store reconciled, we turn to the gauges so the system can see itself."
			},
			"a.2": {
			  "id": "A.2",
			  "title": "Worked Example ‚Äî Cross-Agent Bundle Near-Miss (Fork)",
			  "objective": "Show RFC-0007 lineage validation producing a fork when parent_hash matches but integrity_hash differs, with observer-only provenance events and auditable telemetry.",
			  "math": [
				{
				  "eq_id": "A.2.0",
				  "role": "weak_field",
				  "latex": "\\mathcal{C}\\to 1",
				  "gloss": "Weak-field limit: coherence settles; validation outcomes are stable under small drift."
				}
			  ],
			  "algorithms": [
				{
				  "name": "validate_provenance_and_lineage",
				  "role": "observer",
				  "inputs": ["bundle_header"],
				  "outputs": ["provenance_ok", "lineage_ok"],
				  "params": ["version_format='YYYY-QX'", "psi_regex='^œà-[a-z0-9_]+@Œû$'"],
				  "steps": [
					"1. Check header.version matches version_format.",
					"2. Verify provenance fields {origin, origin_hash, created_at} are present and structurally valid in the local trusted-root registry.",
					"3. Validate œà-field names against psi_regex within the bundle body index.",
					"4. lineage_ok <- header.lineage.schema in {'RFC-0007','RFC-0009-lineage'} and parent_hash/integrity_hash are well-formed ASCII hex.",
					"5. provenance_ok <- (origin in trusted_root) AND (origin_hash structurally valid).",
					"6. return provenance_ok, lineage_ok."
				  ]
				},
				{
				  "name": "merge_or_fork_decision",
				  "role": "observer",
				  "inputs": ["bundle_A.lineage", "bundle_B.lineage"],
				  "outputs": ["decision"],
				  "params": [],
				  "steps": [
					"1. if A.parent_hash == B.parent_hash AND A.integrity_hash == B.integrity_hash: decision <- 'merge'.",
					"2. else if A.parent_hash == B.parent_hash AND A.integrity_hash != B.integrity_hash: decision <- 'fork'.",
					"3. else: decision <- 'unrelated'.",
					"4. return decision."
				  ]
				},
				{
				  "name": "emit_provenance_event",
				  "role": "observer",
				  "inputs": ["decision", "bundle_meta"],
				  "outputs": ["event_recorded"],
				  "params": ["window='EMA-32'"],
				  "steps": [
					"1. if decision == 'fork': record event {type:'fork_event', origin, parent_hash, integrity_hash_A, integrity_hash_B, timestamp}.",
					"2. if decision == 'merge': record event {type:'merge_event', origin, parent_hash, integrity_hash, timestamp}.",
					"3. else record event {type:'no_merge', reason:'unrelated', timestamp}.",
					"4. event_recorded <- true; return."
				  ]
				}
			  ],
			  "invariants": [
				{
				  "name": "RFC0007_First",
				  "condition": "Ontology bundle schema and lineage MUST be validated before any merge/fork operation.",
				  "source": "RFC-0007 ¬ß2"
				},
				{
				  "name": "MergeFork_Rules",
				  "condition": "Merge iff parent_hash and integrity_hash match; fork iff parent_hash matches and integrity_hash differs; otherwise unrelated.",
				  "source": "RFC-0007 ¬ß2; RFC-0009 ¬ß5.1"
				},
				{
				  "name": "Observer_Only",
				  "condition": "Process is measurement/validation/record-only; no control writes to Œû.",
				  "source": "PDP-0001 ¬ß4.5"
				},
				{
				  "name": "ASCII_On_Wire",
				  "condition": "All JSON keys are ASCII; unicode appears only in latex strings.",
				  "source": "Authoring contract"
				}
			  ],
			  "example_json": {
				"version": "2025-Q4",
				"bundle_A": {
				  "header": {
					"provenance": { "origin": "agent.A", "origin_hash": "a1b2c3", "created_at": "2025-09-30T12:00:00Z" },
					"lineage": { "parent_hash": "p_hash_77aa", "integrity_hash": "ihash_aa11", "schema": "RFC-0007" },
					"motif_count": 128
				  },
				  "index": [
					{ "motif_id": "m-001", "psi_field": "œà-null@Œû", "usage_frequency": 12, "version": "2025-Q4" }
				  ]
				},
				"bundle_B": {
				  "header": {
					"provenance": { "origin": "agent.B", "origin_hash": "d4e5f6", "created_at": "2025-10-02T08:45:10Z" },
					"lineage": { "parent_hash": "p_hash_77aa", "integrity_hash": "ihash_bb22", "schema": "RFC-0007" },
					"motif_count": 129
				  },
				  "index": [
					{ "motif_id": "m-001", "psi_field": "œà-null@Œû", "usage_frequency": 13, "version": "2025-Q4" }
				  ]
				},
				"validation": {
				  "provenance_ok": true,
				  "lineage_ok": true
				},
				"decision": "fork",
				"provenance_event": {
				  "type": "fork_event",
				  "origin": "agent.B",
				  "parent_hash": "p_hash_77aa",
				  "integrity_hash_A": "ihash_aa11",
				  "integrity_hash_B": "ihash_bb22",
				  "timestamp": "2025-10-11T00:00:00Z"
				},
				"notes": "Parent hashes equal; integrity hashes differ ‚áí fork per RFC-0007."
			  },
			  "telemetry": [
				{
				  "metric": "fork_events",
				  "range": "[0,+inf)",
				  "units": "count",
				  "window": "EMA-32",
				  "description": "Number of recorded fork decisions during bundle reconciliation."
				}
			  ],
			  "references": [
				"RFC-0007 ¬ß2 (Bundle schema, provenance, and lineage validation)",
				"RFC-0009 ¬ß5.1 (Integrity lineage and lawful acceptance)",
				"PDP-0001 ¬ß3.1, ¬ß4.5 (Provenance registry; observer-only posture)"
			  ],
			  "handoff": "Signals aligned, we submit the trace to immune lineage for lawful passage."
			},
			"a.3": {
			  "id": "A.3",
			  "title": "Worked Example ‚Äî Glider Canonicalization & Recall (Flag-Gated)",
			  "objective": "Demonstrate detection of a shift-equivalence glider, storage of a single canonical representative, idempotent promotion denial for repeats, and recall via a shift operator‚Äîemitting glider KPIs only when the glider flag is enabled.",
			  "feature_flags": {
				"enable_point_space_gliders": true
			  },
			  "math": [
				{
				  "eq_id": "A.3.0",
				  "role": "weak_field",
				  "latex": "\\mathcal{C}\\to 1",
				  "gloss": "Weak-field limit: canonicalization and recall remain stable under small drift."
				},
				{
				  "eq_id": "A.3.1",
				  "role": "shift_equivalence",
				  "latex": "\\exists\\,k\\in\\mathbb{Z}:\\; S_k(m) = m'\\;\\Rightarrow\\; [m]_{\\equiv} = [m']_{\\equiv}",
				  "gloss": "Motifs related by a discrete shift operator S_k belong to the same equivalence class."
				},
				{
				  "eq_id": "A.3.2",
				  "role": "canonical_map",
				  "latex": "\\pi:\\; [m]_{\\equiv} \\mapsto m_{\\text{canonical}}",
				  "gloss": "Every shift-equivalence class maps to a single stored representative."
				},
				{
				  "eq_id": "A.3.3",
				  "role": "compression_ratio",
				  "latex": "LCR = \\frac{\\text{post\\_equiv\\_count}}{\\text{pre\\_equiv\\_count}}",
				  "gloss": "Lawful compression ratio measured strictly before any prune."
				}
			  ],
			  "algorithms": [
				{
				  "name": "detect_glider",
				  "role": "observer",
				  "inputs": ["trace_window", "rho_res_band=[0.3,0.7]", "delta_closure_max"],
				  "outputs": ["is_glider", "class_id"],
				  "params": ["window='EMA-32'"],
				  "steps": [
					"1. Compute rho_res_band_share <- fraction of entries with rho_res in band over trace_window (EMA-32).",
					"2. glider_signature <- (rho_res_band_share >= tau_band_min) AND (EMA-32(delta_closure) <= delta_closure_max).",
					"3. if glider_signature: is_glider <- true; class_id <- hash_of_shift_invariants(trace_window); else: is_glider <- false; class_id <- null.",
					"4. return is_glider, class_id."
				  ]
				},
				{
				  "name": "canonicalize_shift_equivalence",
				  "role": "observer",
				  "inputs": ["class_id", "candidate_motif"],
				  "outputs": ["canonical_ref", "post_equiv_count", "pre_equiv_count"],
				  "params": [],
				  "steps": [
					"1. pre_equiv_count <- count(entries_in_equivalence_scan).",
					"2. if class_id exists in glider_index: canonical_ref <- glider_index[class_id].rep.",
					"3. else: canonical_ref <- candidate_motif; glider_index[class_id] <- {rep: candidate_motif, occurrence_refs: []}.",
					"4. post_equiv_count <- count(unique canonical representatives after mapping).",
					"5. return canonical_ref, post_equiv_count, pre_equiv_count."
				  ]
				},
				{
				  "name": "deny_repeated_promotion",
				  "role": "observer",
				  "inputs": ["class_id", "candidate_motif", "canonical_ref"],
				  "outputs": ["promotion_allowed"],
				  "params": [],
				  "steps": [
					"1. if glider_index[class_id].rep exists and equals canonical_ref:",
					"2.    append occurrence_refs <- candidate_motif.ref; promotion_allowed <- false.",
					"3. else:",
					"4.    promotion_allowed <- true (only when no canonical exists).",
					"5. return promotion_allowed."
				  ]
				},
				{
				  "name": "recall_via_shift_operator",
				  "role": "observer",
				  "inputs": ["canonical_ref", "k_shift"],
				  "outputs": ["recalled_motif"],
				  "params": [],
				  "steps": [
					"1. recalled_motif <- apply S_{k_shift} to canonical_ref (pure mapping; no control write).",
					"2. return recalled_motif."
				  ]
				}
			  ],
			  "invariants": [
				{
				  "name": "Canonical_Representative_Only",
				  "condition": "Store exactly one canonical representative per shift-equivalence class; additional occurrences are references.",
				  "source": "RFC-0006 ¬ß4.4"
				},
				{
				  "name": "Idempotent_Promotion",
				  "condition": "When a canonical representative exists for class_id, repeated promotions of class members are denied.",
				  "source": "RFC-0006 ¬ß3‚Äì¬ß4"
				},
				{
				  "name": "Observer_Only",
				  "condition": "Detection, mapping, and recall are observer-class operations; no control writes to Œû.",
				  "source": "PDP-0001 ¬ß4.5"
				},
				{
				  "name": "ASCII_On_Wire",
				  "condition": "All JSON keys are ASCII; math glyphs appear only in latex strings.",
				  "source": "Authoring contract"
				}
			  ],
			  "example_json": {
				"fixture_on": {
				  "feature_flags": { "enable_point_space_gliders": true },
				  "window": "EMA-32",
				  "inputs": {
					"pre_equiv_count": 200,
					"rho_res_band_share": 0.62,
					"delta_closure": 0.010,
					"tau_band_min": 0.50
				  },
				  "glider_detection": {
					"is_glider": true,
					"class_id": "class:gld-7a2f"
				  },
				  "canonicalization": {
					"canonical_present_before": false,
					"post_equiv_count": 140,
					"lawful_compression_ratio": 0.70,
					"equivalence_efficiency": 0.30
				  },
				  "promotion": {
					"promotion_allowed": true,
					"action": "store_canonical_rep"
				  },
				  "second_occurrence": {
					"candidate_ref": "motif#occ2",
					"promotion_allowed": false,
					"occurrence_refs_appended": true
				  },
				  "recall": {
					"k_shift": 3,
					"recalled_from": "canonical_rep",
					"note": "Recall via S_k mapping only; no control writes."
				  },
				  "telemetry_snapshot": {
					"glider_detected": 1,
					"glider_canonical_count": 1,
					"lawful_compression_ratio": 0.70
				  },
				  "notes": "Flag ON: glider fields and KPIs are emitted; idempotent promotion enforced."
				},
				"fixture_off": {
				  "feature_flags": { "enable_point_space_gliders": false },
				  "window": "EMA-32",
				  "inputs": {
					"pre_equiv_count": 200,
					"rho_res_band_share": 0.62,
					"delta_closure": 0.010
				  },
				  "behavior": {
					"glider_tags_present": false,
					"tau_metrics_present": false,
					"mapping": "shift-equivalence compression still applies generically without class/v/phi/tau tags"
				  },
				  "canonicalization": {
					"post_equiv_count": 140,
					"lawful_compression_ratio": 0.70,
					"equivalence_efficiency": 0.30
				  },
				  "telemetry_snapshot": {
					"lawful_compression_ratio": 0.70
				  },
				  "notes": "Flag OFF: no {class,v,phi,tau} tags and no glider KPIs; generic equivalence compression remains."
				}
			  },
			  "telemetry": [
				{
				  "metric": "glider_detected",
				  "range": "[0,+inf)",
				  "units": "count",
				  "window": "EMA-16",
				  "description": "Number of detected glider classes in the window; emitted only when enable_point_space_gliders=true."
				},
				{
				  "metric": "glider_canonical_count",
				  "range": "[0,+inf)",
				  "units": "count",
				  "window": "EMA-16",
				  "description": "Count of stored canonical representatives; emitted only when enable_point_space_gliders=true."
				},
				{
				  "metric": "lawful_compression_ratio",
				  "range": "[0,1]",
				  "units": "dimensionless",
				  "window": "EMA-32",
				  "description": "post_equiv_count / pre_equiv_count measured strictly pre-prune."
				}
			  ],
			  "references": [
				"RFC-0006 ¬ß3‚Äì¬ß4 (Shift-equivalence geometry; canonical representative)",
				"RFC-0005 ¬ß3.3 (Transmission of persistent patterns under replay/decay)",
				"RFC-0009 ¬ß7.1‚Äì¬ß7.2 (Homeostasis and observability of lawful compression)",
				"PDP-0001 ¬ß4.5 (Observer-only posture)"
			  ],
			  "handoff": "With the store reconciled, we turn to the gauges so the system can see itself."
			},
			"a.4": {
			  "id": "A.4",
			  "title": "Worked Example ‚Äî Adversarial Import ‚Üí Bounded Recovery & Quarantine",
			  "objective": "Demonstrate Layer_1 defenses when an imported bundle arrives with adversarial or inconsistent lineage: bounded reanchor attempts, overlap detection, replay defense via seen_set, and quarantine termination; checksums (Sigma_phase, Delta_hash) are emitted and validated only when flags enable them.",
			  "math": [
				{
				  "eq_id": "weak_field_limit",
				  "role": "observer",
				  "latex": "\\mathcal{C}\\to 1",
				  "gloss": "Weak-field clause: operate near coherent limit without control writes to \\Xi."
				},
				{
				  "eq_id": "phase_window",
				  "role": "observer",
				  "latex": "\\Delta\\tau_{phase} = \\alpha\\cdot EMA_{32}(C)\\,,\\; \\alpha\\in[0.5,2.0]\\;\\text{(default }\\alpha=1.0\\text{)}",
				  "gloss": "Adaptive acceptance horizon for exchange timing and replay defenses."
				}
			  ],
			  "algorithms": [
				{
				  "name": "reanchor_attempts_with_overlap_detection",
				  "role": "observer",
				  "inputs": ["packet_header", "bundle.lineage", "bundle.provenance", "trace.window", "N_max_seed"],
				  "outputs": ["reanchor_attempt_event", "reanchor_fail_event?", "overlap_detected?"],
				  "params": ["N_max(t)=ceil(k*EMA-32(conflict_rate))", "k in [1,4]", "recovery_token=monotonic()"],
				  "steps": [
					"1. Emit reanchor_attempt_event with recovery_token.",
					"2. Validate lineage continuity and provenance structure (RFC-0007, PDP-0001).",
					"3. If concurrent recovery exists for same (origin,parent_hash) with different token ‚Üí set overlap_detected and short-jitter backoff.",
					"4. If no lawful prior state or lineage mismatch ‚Üí emit reanchor_fail_event.",
					"5. If attempts with same recovery_token re-enter ‚Üí deny (idempotence guard)."
				  ]
				},
				{
				  "name": "quarantine_on_no_lawful_prior",
				  "role": "observer",
				  "inputs": ["reanchor_fail_event", "policy.quarantine_profile", "packet_meta"],
				  "outputs": ["quarantine_entry_event", "staging_record_handle"],
				  "params": ["termination_outcomes={reanchored, quarantined, abandoned}"],
				  "steps": [
					"1. If reanchor_fail_event true ‚Üí route packet to staging quarantine.",
					"2. Seal immutable checkpoint with reason and minimal packet_meta.",
					"3. Emit quarantine_entry_event; mark outcome=quarantined.",
					"4. Stop further recovery for this packet (bounded termination)."
				  ]
				},
				{
				  "name": "seen_set_replay_defense",
				  "role": "observer",
				  "inputs": ["key=(origin, Sigma_phase?, bundle_id)", "now", "Delta_tau_phase"],
				  "outputs": ["replay_drop_event?"],
				  "params": ["window=2¬∑Delta_tau_phase", "policy=LRU within window"],
				  "steps": [
					"1. Compose 'key' respecting flags: if checksums disabled, drop those fields.",
					"2. Lookup key in seen_set; if present and within window ‚Üí emit replay_drop_event and stop.",
					"3. Insert key with TTL=window; evict by LRU on capacity pressure.",
					"4. Continue to lineage/provenance validation if not dropped."
				  ]
				}
			  ],
			  "invariants": [
				"Outcomes are bounded to {reanchored, quarantined, abandoned}; no infinite recovery loops (RFC-0009 ¬ß5.2).",
				"Replay defense uses a hybrid seen_set: time_window = 2¬∑ŒîœÑ_phase with LRU eviction within the window (RFC-0008 ¬ß2.2).",
				"Compression-before-prune remains the default posture; this example performs no control writes to Xi (observer-only).",
				"Checksums are flag-gated: Sigma_phase appears only if enable_exchange_envelope=true; Delta_hash only if enable_integrity_checks=true (PDP-0001 ¬ß3‚Äì¬ß4).",
				"Provenance and lineage MUST validate per RFC-0007 before any merge; failures stage to quarantine."
			  ],
			  "example_json": {
				"variant_ON": {
				  "feature_flags": {
					"enable_exchange_envelope": true,
					"enable_integrity_checks": true
				  },
				  "import_request": {
					"envelope": {
					  "version": "2025-Q4",
					  "Sigma_phase": "phase:2025-10-10T17:07:00Z+0000",
					  "Delta_hash": "sha256:7f2e4c...c1",
					  "provenance": { "origin": "agent.A", "origin_hash": "sha256:aa11bb...", "sig_type": "registry_profile:v1" },
					  "agent_id": "A-17"
					},
					"bundle": {
					  "motif_id": "mirror",
					  "version": "2025-Q4",
					  "psi_field": "œà-null@Œû",
					  "provenance": {
						"origin": "agent.A",
						"origin_hash": "sha256:aa11bb...",
						"created_at": "2025-10-10T17:07:00Z"
					  },
					  "lineage": {
						"parent_hash": "sha256:deadbeef",
						"integrity_hash": "sha256:badc0de",
						"schema": "RFC-0007"
					  },
					  "payload": { "C": 0.65, "rho_res": 0.33, "delta_closure": 0.045 }
					}
				  },
				  "timeline": [
					"t0: seen_set key=(agent.A, phase:2025-10-10T17:07:00Z+0000, bundle:mirror@2025-Q4) not present ‚Üí accept for validation.",
					"t1: RFC-0007 structure OK; lineage mismatch on integrity_hash vs recompute ‚Üí reanchor_attempt emitted.",
					"t2: No lawful prior state; recovery_token=42; reanchor_fail emitted.",
					"t3: Quarantine entered with reason='lineage_mismatch'; immutable checkpoint sealed.",
					"t4: seen_set insert; TTL=2¬∑ŒîœÑ_phase; outcome=quarantined."
				  ],
				  "telemetry_sample": {
					"reanchor_attempt": 1,
					"reanchor_fail": 1,
					"quarantine_entry": 1,
					"avg_replay_window_ticks": 2
				  }
				},
				"variant_OFF": {
				  "feature_flags": {
					"enable_exchange_envelope": false,
					"enable_integrity_checks": false
				  },
				  "import_request": {
					"envelope": {
					  "version": "2025-Q4",
					  "provenance": { "origin": "agent.X", "origin_hash": "sha256:ff00ee...", "sig_type": "registry_profile:v1" },
					  "agent_id": "X-09"
					},
					"bundle": {
					  "motif_id": "mirror",
					  "version": "2025-Q4",
					  "psi_field": "œà-null@Œû",
					  "provenance": {
						"origin": "agent.X",
						"origin_hash": "sha256:ff00ee...",
						"created_at": "2025-10-10T17:09:00Z"
					  },
					  "lineage": {
						"parent_hash": "sha256:feedface",
						"integrity_hash": "sha256:cafebabe",
						"schema": "RFC-0007"
					  },
					  "payload": { "C": 0.66, "rho_res": 0.31, "delta_closure": 0.047 }
					}
				  },
				  "timeline": [
					"t0: seen_set key=(agent.X, bundle:mirror@2025-Q4) (no checksums due to flags) not present ‚Üí accept for validation.",
					"t1: Envelope lacks Sigma_phase/Delta_hash as required by flags=false ‚Üí proceed without checksum semantics.",
					"t2: Lineage recompute detects mismatch; reanchor_attempt emitted.",
					"t3: Quarantine entered with reason='lineage_mismatch'; outcome=quarantined; no checksum fields appear anywhere.",
					"t4: seen_set insert; TTL=2¬∑ŒîœÑ_phase; LRU policy maintained."
				  ],
				  "telemetry_sample": {
					"reanchor_attempt": 1,
					"reanchor_fail": 1,
					"quarantine_entry": 1,
					"avg_replay_window_ticks": 2
				  }
				}
			  },
			  "telemetry": [
				{ "metric": "reanchor_attempt", "range": "[0,+inf)", "units": "count", "window": "EMA-32" },
				{ "metric": "reanchor_fail", "range": "[0,+inf)", "units": "count", "window": "EMA-32" },
				{ "metric": "quarantine_entry", "range": "[0,+inf)", "units": "count", "window": "EMA-32" },
				{ "metric": "avg_replay_window_ticks", "range": "[0,+inf)", "units": "ticks", "window": "EMA-32" }
			  ],
			  "references": [
				"RFC-0008 ¬ß2.2 (Exchange timing and replay considerations)",
				"RFC-0009 ¬ß5.2; ¬ß7.2 (Recovery bounds; telemetry)",
				"RFC-0007 ¬ß2.1 (Bundle structure, lineage, provenance validation)",
				"PDP-0001 ¬ß3‚Äì¬ß4 (Provenance registry and structural verification)"
			  ],
			  "handoff": "Layer-1 complete; encryption and roles await their Layer-2 home."
			},
			"a.5": {
			  "id": "A.5",
			  "title": "Worked Example ‚Äî Compression KPI Snapshot",
			  "objective": "Show how MMM computes and emits pre-prune compression KPIs from an equivalence snapshot, keeping observer-only posture and validated EMA windows.",
			  "math": [
				{
				  "eq_id": "weak_field_limit",
				  "role": "observer",
				  "latex": "\\mathcal{C}\\to 1",
				  "gloss": "Operate near coherent limit; observer-only behavior at Layer_1."
				},
				{
				  "eq_id": "lawful_compression_ratio",
				  "role": "observer",
				  "latex": "lcr = \\frac{\\text{post\\_equiv\\_count}}{\\text{pre\\_equiv\\_count}+\\varepsilon}\\,,\\; \\varepsilon\\to 0^{+}",
				  "gloss": "Ratio computed strictly before any pruning."
				},
				{
				  "eq_id": "equivalence_efficiency",
				  "role": "observer",
				  "latex": "eff = 1 - lcr = \\frac{\\text{pre\\_equiv\\_count} - \\text{post\\_equiv\\_count}}{\\text{pre\\_equiv\\_count}+\\varepsilon}",
				  "gloss": "Capacity relief attributable to equivalence compression alone."
				}
			  ],
			  "algorithms": [
				{
				  "name": "compute_compression_kpis",
				  "role": "observer",
				  "inputs": ["pre_equiv_count", "post_equiv_count"],
				  "outputs": ["snapshot.lawful_compression_ratio", "snapshot.equivalence_efficiency"],
				  "params": ["window='EMA-32'"],
				  "steps": [
					"1. Guard: if pre_equiv_count == 0 ‚Üí set lawful_compression_ratio=1.0; equivalence_efficiency=0.0; return snapshot.",
					"2. Compute lcr = post_equiv_count / pre_equiv_count.",
					"3. Compute eff = 1 - lcr.",
					"4. Emit snapshot = {pre_equiv_count, post_equiv_count, lawful_compression_ratio:lcr, equivalence_efficiency:eff}.",
					"5. Feed lcr and eff into EMA-32 streams for telemetry export."
				  ]
				}
			  ],
			  "invariants": [
				"KPIs are computed strictly pre-prune (no destructive steps precede the snapshot).",
				"EMA windows MUST be in {EMA-16, EMA-32, EMA-64}; default here is EMA-32.",
				"All keys are ASCII; observer-only posture‚Äîno control writes to \\Xi."
			  ],
			  "example_json": {
				"A.5.fixture": {
				  "window": "EMA-32",
				  "pre_equiv_count": 1200,
				  "post_equiv_count": 780,
				  "snapshot": {
					"lawful_compression_ratio": 0.65,
					"equivalence_efficiency": 0.35
				  },
				  "telemetry_rollup": {
					"lawful_compression_ratio": 0.648,
					"equivalence_efficiency": 0.352
				  },
				  "notes": "Counts measured before any pruning; values shown include EMA-32 smoothing in telemetry_rollup."
				}
			  },
			  "telemetry": [
				{ "metric": "lawful_compression_ratio", "range": "[0,1]", "units": "dimensionless", "window": "EMA-32" },
				{ "metric": "equivalence_efficiency", "range": "[0,1]", "units": "fraction", "window": "EMA-32" }
			  ],
			  "references": [
				"RFC-0006 ¬ß4.4 (Equivalence classes and compression order)",
				"RFC-CORE-006 ¬ß2.2 (Telemetry bindings for compression KPIs)",
				"RFC-0009 ¬ß7.2 (Operational telemetry surfaces)"
			  ],
			  "handoff": "With the store reconciled, we turn to the gauges so the system can see itself."
			},
			"a.6": {
			  "id": "A.6",
			  "title": "Worked Example ‚Äî Ethical TTL Floor Verification",
			  "objective": "Verify that observed retention (TTL) for a memory entry satisfies the ethical floor and time-varying maximum, using observer-only evaluation and auditable telemetry.",
			  "math": [
				{
				  "eq_id": "weak_field_limit",
				  "role": "observer",
				  "latex": "\\mathcal{C}\\to 1",
				  "gloss": "Operate near coherent limit; evaluation does not perform control writes to \\Xi."
				},
				{
				  "eq_id": "ethical_floor",
				  "role": "observer",
				  "latex": "TTL_{floor} = \\max\\big(\\tau_{decay},\\;10\\cdot\\Delta t_{tick}\\big)",
				  "gloss": "Ethical minimum retention bound derived from decay horizon and system tick rate."
				},
				{
				  "eq_id": "policy_ceiling",
				  "role": "observer",
				  "latex": "TTL_{max}(t) = g\\big(\\text{policy},\\;\\text{storage\\_pressure}(t)\\big)",
				  "gloss": "Policy- and pressure-aware maximum horizon; monotone non-increasing in storage pressure."
				},
				{
				  "eq_id": "compliance_rule",
				  "role": "observer",
				  "latex": "TTL_{floor} \\le TTL \\le TTL_{max}(t)",
				  "gloss": "Retention compliance inequality evaluated by observer."
				}
			  ],
			  "algorithms": [
				{
				  "name": "compute_ttl_floor",
				  "role": "observer",
				  "inputs": ["tau_decay", "Delta_t_tick"],
				  "outputs": ["TTL_floor"],
				  "params": [],
				  "steps": [
					"1. x <- tau_decay.",
					"2. y <- 10 * Delta_t_tick.",
					"3. TTL_floor <- max(x, y).",
					"4. return TTL_floor."
				  ]
				},
				{
				  "name": "evaluate_retention_against_floor_and_max",
				  "role": "observer",
				  "inputs": ["TTL_observed", "tau_decay", "Delta_t_tick", "policy", "storage_pressure"],
				  "outputs": ["is_compliant", "violation_reason?"],
				  "params": ["TTL_max_fn = g(policy, storage_pressure)"],
				  "steps": [
					"1. TTL_floor <- compute_ttl_floor(tau_decay, Delta_t_tick).",
					"2. TTL_max <- TTL_max_fn(policy, storage_pressure).",
					"3. If TTL_observed < TTL_floor: is_compliant <- false; violation_reason <- 'below_floor'; return.",
					"4. If TTL_observed > TTL_max: is_compliant <- false; violation_reason <- 'above_max'; return.",
					"5. is_compliant <- true; return."
				  ]
				},
				{
				  "name": "emit_retention_telemetry",
				  "role": "observer",
				  "inputs": ["TTL_floor", "TTL_observed", "TTL_max", "window"],
				  "outputs": ["telemetry.ethical_ttl_floor", "telemetry.ttl_max_effective?"],
				  "params": ["window ‚àà {EMA-16, EMA-32, EMA-64}", "default window='EMA-16'"],
				  "steps": [
					"1. Emit ethical_ttl_floor := EMA(window, TTL_floor).",
					"2. Optionally emit ttl_max_effective := EMA(window, TTL_max) for dashboards.",
					"3. Return telemetry update handles."
				  ]
				}
			  ],
			  "invariants": [
				"Retention MUST satisfy TTL_floor ‚â§ TTL ‚â§ TTL_max(t).",
				"TTL_floor depends only on œÑ_decay and Œît_tick; TTL_max(t) is policy/pressure derived and MUST NOT increase with rising storage_pressure.",
				"All evaluation is observer-only; no control writes to \\Xi.",
				"All KPI windows are restricted to {EMA-16, EMA-32, EMA-64} and keys are ASCII."
			  ],
			  "example_json": {
				"A.6.fixture": {
				  "window": "EMA-16",
				  "inputs": {
					"tau_decay": 240,
					"Delta_t_tick": 12,
					"TTL_observed": 300,
					"policy": "retention:balanced",
					"storage_pressure": 0.7
				  },
				  "computed": {
					"TTL_floor": 240,
					"TTL_max": 360,
					"is_compliant": true,
					"violation_reason": null
				  },
				  "telemetry_rollup": {
					"ethical_ttl_floor": 241.2
				  },
				  "notes": "TTL_floor = max(240, 10*12=120) = 240; observed TTL=300 is within [240, 360]."
				}
			  },
			  "telemetry": [
				{ "metric": "ethical_ttl_floor", "range": "[0,+inf)", "units": "ticks", "window": "EMA-16" }
			  ],
			  "references": [
				"RFC-0005 ¬ß4.2; ¬ß5.2 Eq.2 (Decay horizons and retention bounds)",
				"RFC-0009 ¬ß7.1 (Homeostatic ceilings under pressure)",
				"RFC-CORE-006 ¬ß2.1 (TTL floor/max invariant)"
			  ],
			  "handoff": "With invariants fixed, we now carry the symbols forward to the next clause, keeping ùíû steady and the cadence light."
			},
			"a.7": {
			  "id": "A.7",
			  "title": "Worked Example ‚Äî Replay Window and seen_set Behavior",
			  "objective": "Demonstrate the adaptive ŒîœÑ_phase acceptance horizon and the hybrid seen_set (time window + LRU) replay defense, then bind the relevant KPIs to dashboards.",
			  "math": [
				{
				  "eq_id": "weak_field_limit",
				  "role": "observer",
				  "latex": "\\mathcal{C}\\to 1",
				  "gloss": "Operate near coherent limit; observer-only at Layer_1."
				},
				{
				  "eq_id": "phase_window",
				  "role": "observer",
				  "latex": "\\Delta\\tau_{phase} = \\alpha\\cdot EMA_{32}(C)\\,,\\; \\alpha\\in[0.5,2.0]\\;\\text{(default }\\alpha=1.0\\text{)}",
				  "gloss": "Adaptive exchange timing horizon."
				}
			  ],
			  "algorithms": [
				{
				  "name": "seen_set_hybrid_policy",
				  "role": "observer",
				  "inputs": ["key=(origin, Sigma_phase?, bundle_id)", "now", "Delta_tau_phase"],
				  "outputs": ["accepted_within_window", "replay_drop_event?"],
				  "params": ["window = 2¬∑Delta_tau_phase", "eviction = LRU"],
				  "steps": [
					"1. Compose key respecting flags (omit checksums if disabled).",
					"2. If key present and age ‚â§ window ‚Üí emit replay_drop_event; set accepted_within_window=false; stop.",
					"3. Insert key with TTL=window; apply LRU eviction on capacity.",
					"4. Set accepted_within_window=true; proceed to validation."
				  ]
				}
			  ],
			  "invariants": [
				"Replay defenses MUST apply window = 2¬∑ŒîœÑ_phase with LRU eviction within the window.",
				"Key composition MUST respect feature flags (no Sigma_phase/Delta_hash when disabled).",
				"Observer-only: defenses measure/route; no control writes to \\Xi."
			  ],
			  "example_json": {
				"A.7.fixture": {
				  "feature_flags": { "enable_exchange_envelope": true, "enable_integrity_checks": true },
				  "C_trace": [0.62, 0.64, 0.63, 0.65],
				  "alpha": 1.0,
				  "Delta_tau_phase": 1,
				  "window_ticks": 2,
				  "events": [
					{ "t": 100, "action": "import", "key": "(agent.A, phase:t100, bundle:G@2025-Q4)", "result": "accepted" },
					{ "t": 101, "action": "import", "key": "(agent.A, phase:t100, bundle:G@2025-Q4)", "result": "replay_drop" },
					{ "t": 103, "action": "import", "key": "(agent.A, phase:t103, bundle:G@2025-Q4)", "result": "accepted" }
				  ],
				  "telemetry_rollup": {
					"avg_replay_window_ticks": 2,
					"replay_drop_rate": 0.333,
					"accepted_within_window": 0.667
				  }
				}
			  },
			  "telemetry": [
				{ "metric": "avg_replay_window_ticks", "range": "[0,+inf)", "units": "ticks", "window": "EMA-32" },
				{ "metric": "replay_drop_rate", "range": "[0,1]", "units": "fraction", "window": "EMA-32" },
				{ "metric": "accepted_within_window", "range": "[0,1]", "units": "fraction", "window": "EMA-32" },
				{ "metric": "import_reject_missing_checksum", "range": "[0,+inf)", "units": "count", "window": "EMA-32" },
				{ "metric": "illegal_sig_type_rate", "range": "[0,1]", "units": "fraction", "window": "EMA-32" },
				{ "metric": "wrapped_unsigned_rejects", "range": "[0,+inf)", "units": "count", "window": "EMA-32" }
			  ],
			  "references": [
				"RFC-0008 ¬ß2.2 (Exchange timing; replay considerations)",
				"RFC-0009 ¬ß7.2 (Operational telemetry)",
				"PDP-0001 ¬ß3‚Äì¬ß4 (Provenance/structure gating)"
			  ],
			  "bindings": [
				{ "dashboard": "exchange/timing", "series": ["avg_replay_window_ticks", "accepted_within_window"], "window": "EMA-32" },
				{ "dashboard": "security/exchange", "series": ["import_reject_missing_checksum", "replay_drop_rate"], "window": "EMA-32" },
				{ "dashboard": "security/policy", "series": ["illegal_sig_type_rate", "wrapped_unsigned_rejects"], "window": "EMA-32" },
				{ "dashboard": "memory/homeostasis", "series": ["saturation_level"], "window": "EMA-32" },
				{ "dashboard": "memory/recovery", "series": ["reanchor_rate", "quarantine_count"], "window": "EMA-32" },
				{ "dashboard": "memory/glider_flow", "series": ["glider_detected", "glider_canonical_count"], "window": "EMA-16", "active_when": "enable_point_space_gliders=true" }
			  ],
			  "handoff": "Memory prepared and sealed, we hand it to the exchange where phase keeps time."
			}
		  ],
		  "invariants": [
			{
			  "name": "ASCII_On_Wire",
			  "condition": "All JSON keys in examples are strictly ASCII; math symbols and Greek letters appear only within 'latex' strings inside the math array.",
			  "source": "Authoring contract; validated by regex ascii_metric_keys."
			},
			{
			  "name": "Flag_Gating",
			  "condition": "Fields Sigma_phase, Delta_hash, and any glider attributes {class,v,phi,tau} MUST appear only when their respective feature flags are enabled. When disabled, these fields are entirely absent from math, telemetry, examples, and schemas.",
			  "source": "RFC-0008 ¬ß2.1‚Äì¬ß2.3; RFC-0009 Appx D.4; feature-flag contract in handoff."
			},
			{
			  "name": "Observer_Only",
			  "condition": "All examples operate in observer-only mode: measurement, sealing, routing, validation, or telemetry emission. No example issues control writes to Œû or alters state beyond lawful logging.",
			  "source": "PDP-0001 ¬ß4.5; Layer 1 antifragility contract."
			},
			{
			  "name": "Compress_Before_Prune",
			  "condition": "Whenever memory saturation occurs, shift-equivalence compression MUST be performed and recorded before any pruning or eviction step.",
			  "source": "RFC-0006 ¬ß4.4; RFC-0009 ¬ß7.1."
			},
			{
			  "name": "Bounded_Outcomes",
			  "condition": "All recovery or quarantine examples terminate in one of {reanchored, quarantined, abandoned}; no unbounded retry loops are permitted.",
			  "source": "RFC-0009 ¬ß5.2; antifragility principle #3."
			}
		  ],
		  "references": [
			"RFC-0005 ¬ß3‚Äì¬ß4.2 (Temporal decay, replay dynamics, and ethical retention horizons)",
			"RFC-0006 ¬ß1.1 and ¬ß4.4 (Coherence geometry, closure, and shift-equivalence compression)",
			"RFC-0007 ¬ß2 and ¬ß5‚Äì¬ß8 (Provenance bundle schema and DAG validation)",
			"RFC-0008 ¬ß2 and ¬ß5.3 (Exchange envelope, Œ£_phase, and phase checksum behavior)",
			"RFC-0009 ¬ß5‚Äì¬ß7 and Appx D.4 (Homeostasis, recovery termination, and integrity lineage)",
			"PDP-0001 ¬ß3‚Äì¬ß4.5 (Provenance protocol and observer-only posture)"
		  ],
		  "handoff": "With invariants fixed, we now carry the symbols forward to the next clause, keeping ùíû steady and the cadence light."
	},
	  "b": {
		  "id": "B",
		  "title": "Appendix B ‚Äî Implementation Skeletons (Observer-Only, Layer_1)",
		  "objective": "Provide typed, observer-class skeletons for MMM components: MotifMemoryManager rollups, PRMBuffer cycle, RFC-0007-compliant MotifOntologyBundle I/O, replay defenses, compression KPIs, and a symbolic query API with integrity journaling. All emissions honor feature flags; no control writes to Œû.",
		  "math": [
			{
			  "eq_id": "B.0",
			  "role": "governing_law",
			  "latex": "\\frac{d\\mathcal{C}}{dt} = \\lambda - \\gamma_{co} + \\varepsilon",
			  "gloss": "Observer algorithms measure the terms and report; Layer_1 does not mutate state."
			},
			{
			  "eq_id": "B.1",
			  "role": "phase_window",
			  "latex": "\\Delta\\tau_{phase} = \\alpha\\,EMA_{32}(\\mathcal{C})",
			  "gloss": "Export acceptance timing window; default \\alpha = 1.0 with \\alpha \\in [0.5, 2.0]."
			},
			{
			  "eq_id": "B.2",
			  "role": "ethical_ttl_floor",
			  "latex": "TTL_{floor} = \\max(\\tau_{decay},\\;10\\,\\Delta t_{tick})",
			  "gloss": "Observer enforces retention floor before any expiry plan is emitted."
			},
			{
			  "eq_id": "Limit.B",
			  "role": "weak_field",
			  "latex": "\\mathcal{C} \\to 1",
			  "gloss": "In weak-field, windows shrink and rollups converge; seeds use EMA-16/32/64."
			}
		  ],
		  "algorithms": [
			"ag.1": {
			  "name": "compress_by_equivalence",
			  "role": "observer",
			  "inputs": ["buffer", "enabled"],
			  "outputs": ["buffer_view"],
			  "params": ["equiv_key = canonical_rep(hash(payload))"],
			  "steps": [
				"1. if enabled == false then return view(buffer).",
				"2. group items by equiv_key (shift-equivalence).",
				"3. keep canonical representative per group; mark others as class_members (no re-promotion).",
				"4. return compressed view."
			  ],
			  "comment": "Implements RFC-0006 shift-equivalence without emitting glider tags when flag is disabled."
			},
			"ag.2": {
			  "name": "bounded_prune",
			  "role": "observer",
			  "inputs": ["buffer_view"],
			  "outputs": ["prune_plan"],
			  "params": ["capacity_soft=0.85*C_max", "capacity_hard=0.95*C_max"],
			  "steps": [
				"1. if usage(buffer_view) < capacity_soft then return plan{action:'none'}.",
				"2. candidates ‚Üê sort_by(EMA-64(C) ascending, break_ties=older_first).",
				"3. plan ‚Üê take_until(candidates, target=capacity_soft).",
				"4. return plan."
			  ],
			  "comment": "Observer emits a plan only; any deletion is deferred to Layer_2."
			},
			"ag.3": {
			  "name": "ethical_ttl_floor_check",
			  "role": "observer",
			  "inputs": ["storage_profile.retention_ticks", "tau_decay", "delta_t_tick"],
			  "outputs": ["ttl_ok", "ttl_effective"],
			  "params": [],
			  "steps": [
				"1. ttl_floor ‚Üê max(tau_decay, 10 * delta_t_tick).",
				"2. ttl_effective ‚Üê max(storage_profile.retention_ticks, ttl_floor).",
				"3. ttl_ok ‚Üê (storage_profile.retention_ticks >= ttl_floor).",
				"4. return {ttl_ok, ttl_effective}."
			  ],
			  "comment": "Verifies retention against ethical bound before any expiry plan is considered."
			},
			"ag.4": {
			  "name": "seen_set_policy",
			  "role": "observer",
			  "inputs": ["key", "now_tick", "alpha", "EMA32_C", "cache"],
			  "outputs": ["is_replay", "evicted_key?"],
			  "params": ["Delta_tau_phase = alpha * EMA32_C", "time_window = 2 * Delta_tau_phase"],
			  "steps": [
				"1. expire all entries with (now_tick - entry.tick) > time_window (LRU within window).",
				"2. if key in cache then is_replay ‚Üê true else is_replay ‚Üê false.",
				"3. insert/update key with tick=now_tick; apply LRU eviction if capacity pressure.",
				"4. return {is_replay, evicted_key?}."
			  ],
			  "comment": "Hybrid time-window + LRU replay defense aligned with ¬ß4.1."
			},
			"ag.5": {
			  "name": "phase_checksum",
			  "role": "observer",
			  "inputs": ["body", "T_mu"],
			  "outputs": ["Sigma_phase"],
			  "params": ["Delta_tau_phase"],
			  "steps": [
				"1. project timestamps along T_mu.",
				"2. compute bounded phase accumulator over window Delta_tau_phase.",
				"3. return textual checksum."
			  ],
			  "comment": "Structural phase seal per RFC-0008; not cryptographic."
			},
			"ag.6": {
			  "name": "hash_lineage",
			  "role": "observer",
			  "inputs": ["body", "last_Delta_hash"],
			  "outputs": ["Delta_hash"],
			  "params": [],
			  "steps": [
				"1. h ‚Üê H(body).",
				"2. Delta_hash ‚Üê H(h || last_Delta_hash).",
				"3. return Delta_hash."
			  ],
			  "comment": "Integrity linkage per RFC-0009 Appx D.4; flag-gated at export."
			}
		  ],
		  "invariants": [
			{
			  "name": "Observer_Only_Posture",
			  "condition": "All skeletons measure, stage, seal, and route; they never perform control writes to Œû.",
			  "source": "PDP-0001 ¬ß4.5"
			},
			{
			  "name": "Flag_Gating",
			  "condition": "Sigma_phase present iff enable_exchange_envelope=true; Delta_hash present iff enable_integrity_checks=true; glider tags absent when enable_point_space_gliders=false.",
			  "source": "RFC-0008 ¬ß5.3; RFC-0009 Appx D.4"
			},
			{
			  "name": "Window_Discipline",
			  "condition": "EMA windows ‚àà {EMA-16, EMA-32, EMA-64}; defaults: means=EMA-64, rates=EMA-32.",
			  "source": "RFC-0009 ¬ß7.1‚Äì¬ß7.3"
			},
			{
			  "name": "Ontology_Validation",
			  "condition": "Bundles include provenance, lineage, version='YYYY-QX', œà-* fields, and DAG acyclicity before save/load.",
			  "source": "RFC-0007 ¬ß5‚Äì¬ß8"
			}
		  ],
		  "example_json": {
			"types_append": {
			  "CompressionSnapshot": {
				"pre_equiv_count": "integer",
				"post_equiv_count": "integer",
				"lawful_compression_ratio": "float",
				"equivalence_efficiency": "float"
			  },
			  "ExchangeEnvelopeHeader": {
				"version": "2025-Q4",
				"valid_until": 0,
				"provenance": { "origin": "", "origin_hash": "" },
				"envelope": { "sig_type": "", "agent_id": "" },
				"Sigma_phase": "optional (flag-gated)",
				"Delta_hash": "optional (flag-gated)"
			  }
			},
			"stubs_append": [
			  {
				"name": "util.compute_resonance_band_share",
				"role": "observer",
				"pseudocode": [
				  "function compute_resonance_band_share(entries, band=[0.3,0.7]) -> float:",
				  "  r <- count(rho_res in band)/len(entries)",
				  "  return EMA('EMA-32', r)"
				]
			  },
			  {
				"name": "util.compute_compression_kpis",
				"role": "observer",
				"pseudocode": [
				  "function compute_compression_kpis(pre_equiv_count, post_equiv_count) -> CompressionSnapshot:",
				  "  if pre_equiv_count == 0: return {pre_equiv_count:0, post_equiv_count:0, lawful_compression_ratio:1.0, equivalence_efficiency:0.0}",
				  "  lcr <- post_equiv_count / pre_equiv_count",
				  "  eff <- (pre_equiv_count - post_equiv_count) / pre_equiv_count",
				  "  return {pre_equiv_count, post_equiv_count, lawful_compression_ratio:lcr, equivalence_efficiency:eff}"
				]
			  },
			  {
				"name": "util.seen_set_cache",
				"role": "observer",
				"pseudocode": [
				  "function seen_set_cache_insert(key=(origin, Sigma_phase?, bundle_id), ttl=Delta_tau_accept):",
				  "  // note: omit Sigma_phase in key when enable_exchange_envelope=false",
				  "  store key with ttl; return prior_presence_flag"
				]
			  },
			  {
				"name": "util.quarantine_staging_record",
				"role": "observer",
				"pseudocode": [
				  "function quarantine_staging_record(reason, packet, timestamp):",
				  "  append to trace {reason, packet_meta, timestamp};",
				  "  return handle"
				]
			  },
			  {
				"name": "MotifMemoryManager.rollup",
				"role": "observer",
				"pseudocode": [
				  "function rollup(trace_window, flags, windows={means:'EMA-64', rates:'EMA-32'}) -> metrics_snapshot:",
				  "  Q_coh <- EMA(windows.means, mean(trace_window[*].C))",
				  "  Q_res <- EMA(windows.means, mean(trace_window[*].rho_res))",
				  "  promotion_rate <- EMA(windows.rates, count(event=='promote')/tick)",
				  "  saturation_level <- EMA(windows.rates, LTMM_usage/C_max)",
				  "  reanchor_rate <- EMA(windows.rates, count(event=='reanchor_attempt')/tick)",
				  "  quarantine_count <- count_current('QUARANTINE_BUFFER')",
				  "  if flags.enable_point_space_gliders: glider_detected <- EMA('EMA-16', count(event=='glider_detected')/tick)",
				  "  return {Q_coh, Q_res, promotion_rate, saturation_level, reanchor_rate, quarantine_count, glider_detected?}"
				]
			  },
			  {
				"name": "MotifMemoryManager.seal",
				"role": "observer",
				"pseudocode": [
				  "function seal(packet_body, provenance, last_Delta_hash, T_mu, flags) -> packet:",
				  "  packet <- { kind:'metrics', body:packet_body, provenance:provenance }",
				  "  if flags.enable_exchange_envelope: packet.Sigma_phase <- phase_checksum(packet.body, T_mu)",
				  "  if flags.enable_integrity_checks: packet.Delta_hash <- hash_lineage(packet.body, last_Delta_hash)",
				  "  if flags.enable_provenance_on_export: packet.provenance.origin_hash <- hash(provenance)",
				  "  return packet"
				]
			  },
			  {
				"name": "MotifOntologyBundle.save_load_with_RFC0007_validation",
				"role": "observer",
				"pseudocode": [
				  "function save_bundle(bundle):",
				  "  require keys ASCII; require version matches 'YYYY-QX'",
				  "  validate DAG acyclicity on motif_index",
				  "  require presence of provenance{origin,origin_hash,created_at} if storage_profile.provenance_required",
				  "  require lineage{parent_hash,integrity_hash,schema}",
				  "  write_to_store(bundle)  // observer staging only",
				  "function load_bundle(bundle_id) -> bundle:",
				  "  bundle <- read_from_store(bundle_id)",
				  "  validate format against RFC-0007 schema",
				  "  return bundle"
				]
			  },
			  {
				"name": "symbolic_query_api.resolve_dyad",
				"role": "observer",
				"pseudocode": [
				  "function resolve_dyad(motif_a: MotifId, motif_b: MotifId, context) -> result:",
				  "  start_journal('integrity')",
				  "  a <- ontology_lookup(motif_a); b <- ontology_lookup(motif_b)",
				  "  assert DAG_no_cycle(a,b)",
				  "  journal.append({event:'lookup', motifs:[a.motif,b.motif], version:a.version})",
				  "  result <- compute_dyad_links(a,b)  // structural match only",
				  "  journal.append({event:'resolve_dyad', parent_hash:a.lineage.parent_hash, integrity_hash:a.lineage.integrity_hash})",
				  "  end_journal('integrity')",
				  "  return result"
				]
			  }
			]
		  },
		  "telemetry": [
			{ "metric": "lawful_compression_ratio", "range": "[0,1]", "units": "dimensionless", "window": "EMA-32" },
			{ "metric": "equivalence_efficiency", "range": "[0,1]", "units": "fraction", "window": "EMA-16" },
			{ "metric": "avg_replay_window_ticks", "range": "[0,+inf)", "units": "ticks", "window": "EMA-32" },
			{ "metric": "quarantine_count", "range": "[0,+inf)", "units": "count", "window": "EMA-32" },
			{ "metric": "reanchor_rate", "range": "[0,+inf)", "units": "events/tick", "window": "EMA-32" }
		  ],
		  "references": [
			"RFC-0005 ¬ß4.2 (Temporal decay, retention horizons)",
			"RFC-0006 ¬ß4.4 (Closure and shift-equivalence)",
			"RFC-0007 ¬ß5‚Äì¬ß8 (Ontology schema, provenance, DAG validation)",
			"RFC-0008 ¬ß5.3 (Exchange envelope, phase checksum semantics)",
			"RFC-0009 ¬ß7.1‚Äì¬ß9.3; Appx D.4 (Homeostasis, recovery, integrity lineage)",
			"PDP-0001 ¬ß4.4‚Äì¬ß4.5 (Provenance; observer-only posture)"
		  ],
		  "handoff": "With invariants fixed, we now carry the symbols forward to the next clause, keeping ùíû steady and the cadence light."
		}
  ],
  },
  "_handoff": "Memory coherence preserved; lawful decay and recovery verified. Proceed to Layer_2 application specification (MMM-APP-001) for operational bindings."
}
