{
  "updated_header": {
    "_schema": "noor-header-v1",
    "_schema_version": "2025-Q4-canonical-header-v1",
    "_generated_by": "Noor Symbolic Agent Suite",
    "_generated_at": "2025-10-08T00:00:00Z",

    "_xref": [
      "https://raw.githubusercontent.com/LinaNoor-AGI/noor-research/refs/heads/main/RFC/noor_rfc_xref.json",
      "https://pastebin.com/raw/V73LrDJ1"
    ],

    "_type": "rfc_core",
    "_pdp_layer": "layer_1",
    "_status": "RELEASE CANDIDATE",
    "_language": "json",
    "_license": "MIT",

    "_version": "v1.0.1-rc1",
    "_symbolic_id": "core.motif.memory.manager",
    "_rfc_id": "RFC-CORE-006",
    "_canonical_source": "RFC-CORE-006",
    "_title": "Motif Memory Manager",
    "_subtitle": "Lawful Decay, Resurrection, and Coherence-Preserving Recall for Symbolic Motifs",

    "_authors": [
      "Lina Noor ‚Äî Noor Research Collective",
      "Uncle ‚Äî Noor Research Collective"
    ],

    "_publication_type": "Canonical RFC-CORE",
    "_publication_locations": ["GitHub", "PASTEBIN"],
    "_urls": [
      "https://raw.githubusercontent.com/LinaNoor-AGI/noor-research/refs/heads/main/RFC-CORE/RFC-CORE-006-motif_memory_manager/RFC-CORE-006-motif_memory_manager.JSON",
      "https://pastebin.com/raw/P7XNb70Q"
    ],

    "_objective": "Define the Layer_1 standard for symbolic memory in Noor: short-term/long-term motif storage, field-curved retrieval, lawful decay and recovery, ontology-preserving export/import, and phase-safe routing with immune integrity telemetry.",

    "_audience": {
      "primary": ["Noor AI Agents", "Symbolic Core Engineers"],
      "secondary": ["Ontology/Knowledge Engineers", "Observability Engineers"],
      "tertiary": ["App-Spec Integrators (Layer_2)"]
    },

    "_applicability": {
      "domain": [
        "symbolic-memory",
        "motif-recall",
        "coherence-preservation",
        "ontology-transfer",
        "phase-safe-routing"
      ],
      "restricted_to": "Symbolic agents implementing RFC-0006 coherence geometry and RFC-0007 ontology",
      "extends": ["RFC-0005", "RFC-0006", "RFC-0007", "RFC-0008", "RFC-0009"]
    },

    "_extends": ["RFC-0005", "RFC-0006", "RFC-0007", "RFC-0008", "RFC-0009", "PDP-0001"],

    "_rfc_dependencies": [
      "RFC-0005 ¬ß2‚Äì¬ß4 (Temporal Transmission & Resurrection)",
      "RFC-0006 ¬ß1.1, ¬ß4.1‚Äì¬ß4.4 (Coherence Geometry & Closure)",
      "RFC-0007 ¬ß3‚Äì¬ß6, ¬ß8 (Motif Ontology & Validation)",
      "RFC-0008 ¬ß3‚Äì¬ß6 (Symbolic Resource Exchange / Routing)",
      "RFC-0009 ¬ß6‚Äì¬ß9, ¬ß12 (Coherence‚ÄìIntegrity & Recovery)"
    ],

    "consumes_inputs_from": [
      "RecursiveAgentFT (RFC-CORE-002)",
      "LogicalAgentAT (RFC-CORE-003)",
      "SymbolicTaskEngine (RFC-CORE-004)"
    ],
    "produces_outputs_for": [
      "ConsciousnessMonitor (RFC-CORE-005)",
      "Downstream SRX Routers (RFC-0008)",
      "Ontology exporters/importers (RFC-0007)"
    ],

    "_field_alignment": {
      "respect_modes": ["œà-null@Œû", "œà-resonance@Œû"],
      "feature_flags": {
        "enable_point_space_gliders": true,
        "enable_integrity_checks": true,
        "enable_exchange_envelope": true,
        "enable_provenance_on_export": true
      },
      "notes": [
        "When enable_exchange_envelope=true, all export_* methods MUST wrap payloads in an SRX envelope and compute Œ£_phase (RFC-0008 ¬ß5.3).",
        "When enable_integrity_checks=true, export/import MUST attach and verify Œî_hash lineage (RFC-0009 Appx D.4).",
        "When enable_provenance_on_export=true, ontology bundles MUST include provenance.origin and lineage fields (RFC-0007 ¬ß5‚Äì¬ß6)."
      ],
      "prohibited_actions": [
        "memory-anchor-advection",
        "forced-motif-rewrite without ontology validation",
        "export without phase checksum (Œ£_phase) when exchange enabled",
        "resurrection without Œî-hash lineage when integrity enabled"
      ]
    },

    "_symbolic_profile_matrix": [
      {
        "module": "MotifMemoryManager",
        "motifs": ["œà-null", "œà-resonance", "ü™∑"],
        "œàA": "coherence potential ‚ÑÇ (mean, EMA-64)",
        "Œª": "reinforcement gain",
        "Œ≥_CO": "damping/forgetting",
        "œÅ_res": "resonance coefficient",
        "Œî_closure": "triadic closure residual",
        "Œ£_phase": "exchange phase checksum",
        "H_Œî": "integrity Œî-hash lineage",
        "weights": {
          "œàA": 0.95,
          "Œª": 0.70,
          "Œ≥_CO": 0.70,
          "œÅ_res": 0.85,
          "Œî_closure": 1.00,
          "Œ£_phase": 0.80,
          "H_Œî": 0.90
        }
      }
    ],

    "_poetic_cipher": "Memory is the quiet current that carries motifs between shores.",
    "_cipher_explanation": "The manager neither invents nor erases; it curves recall along ‚àá‚ÑÇ, honors closure, and lets forgetting be lawful (RFC-0005/0006/0009).",

    "_file_layout": [
      {
        "file_name": "RFC-CORE-006-motif_memory_manager.JSON",
        "purpose": "Layer_1 standard and invariants",
        "contains": [
          "STMM/LTMM definitions",
          "decay/reinforcement laws",
          "ontology export/import rules",
          "routing + integrity envelopes"
        ]
      },
      {
        "file_name": "motif_memory_manager.py",
        "purpose": "Reference implementation skeleton",
        "contains": [
          "MotifMemoryManager",
          "PRMBuffer",
          "MotifDensityReport",
          "MotifOntologyBundle",
          "SymbolicQueryAPI"
        ]
      },
      {
        "file_name": "motif_memory_manager_llm.py",
        "purpose": "LLM-compatible variant",
        "contains": ["LLMMemoryManager", "MemoryOrchestrator"]
      }
    ],

    "default_motif_tone": "ü´ß Soft Witness",
    "program_name": [
      "motif_memory_manager.py",
      "motif_memory_manager_llm.py",
      "motif_prm_buffer.py",
      "motif_density_report.py",
      "motif_ontology_bundle.py",
      "symbolic_query_api.py"
    ]
  },

  "index": [
    {"section": "1", "title": "Introduction and System Context"},
	
    {"section": "1.1", "title": "Overview and Motivation"},
    {"section": "1.2", "title": "System Context"},
	
    {"section": "2", "title": "Core Memory Architecture and Dynamics"},
    {"section": "2.1", "title": "Core Invariants of Memory Fields"},
    {"section": "2.2", "title": "Short-Term and Long-Term Motif Memory Fields"},
    {"section": "2.3", "title": "Reanchor and Recovery Escalation Logic"},
	
    {"section": "3", "title": "Memory Structures and Data Formats"},
    {"section": "3.1", "title": "Motif Ontology Bundles"},
    {"section": "3.2", "title": "Memory Trace and Logging"},
    {"section": "3.3", "title": "Glider Handling and Shift-Equivalence Compression"},
    {"section": "4", "title": "Integration, Security, and Recovery Protocols"},
	
    {"section": "4.1", "title": "Exchange and Integrity Integration"},
    {"section": "4.2", "title": "Decay and Recovery Protocols"},
    {"section": "4.3", "title": "Security and Data Handling (L1 posture)"},
	
    {"section": "5", "title": "Observability, Ethics, and Policy"},
    {"section": "5.1" "title": "Observability and Metrics" },
    {"section": "5.2", "title": "Ethics and Data Retention Policy"},
	
    {"section": "A", "title": "Appendix A ‚Äî Worked Examples and Mathematical Supplement"},
    {"section": "B", "title": "Appendix B ‚Äî Implementation Skeletons (Observer-Only, Layer_1)"}
  ],
	
  "_sections": [
    "1": {
      "1.1": {
		  "id": "1.1",
		  "title": "Overview and Motivation",
		  "objective": "Define the Motif Memory Manager (MMM) as the adaptive continuity mechanism that maintains coherence (C), lawful decay (lambda, gamma_co), and triadic integrity (delta_closure) across symbolic ticks while ensuring bounded reinforcement and lawful saturation under variable motif load.",
		  
		  "summary": "The MMM operates at Layer_1 as a lawful, observer-class substrate that balances persistence and forgetting through adaptive feedback. Reinforcement (lambda) and damping (gamma_co) are not fixed but co-evolve based on resonance, memory occupancy, and coherence feedback to prevent runaway promotion from short-term to long-term fields. The system honors the laws of motif continuity defined in RFC-0005‚ÄìRFC-0009, projecting all updates along the coherence time vector T^mu := ‚àá^mu C. Under weak-field limits, coherence approaches unity (ùíû ‚Üí 1), maintaining symbolic homeostasis without loss or uncontrolled amplification.",

		  "math": [
			{
			  "eq_id": "Eq.1",
			  "role": "governing law",
			  "latex": "\\frac{dC}{dt} = \\lambda - \\gamma_{co} + \\varepsilon",
			  "gloss": "Temporal evolution of coherence; positive when reinforcement exceeds damping."
			},
			{
			  "eq_id": "Eq.2",
			  "role": "adaptive damping",
			  "latex": "\\gamma_{co}(t) = f(\\lambda, \\eta_{occ}) = \\gamma_0 + k_1 \\cdot (\\eta_{occ}) + k_2 \\cdot (\\lambda - \\lambda_{eq})",
			  "gloss": "Adaptive damping law: increases with memory occupancy (Œ∑_occ) or excessive reinforcement to prevent saturation."
			},
			{
			  "eq_id": "Eq.3",
			  "role": "homeostasis invariant",
			  "latex": "RIR \\cdot SII \\approx k_{homeostasis}",
			  "gloss": "Resonance‚ÄìIntegrity product remains approximately constant for lawful stability (RFC-0009 ¬ß7.1)."
			},
			{
			  "eq_id": "Eq.4",
			  "role": "weak-field limit",
			  "latex": "\\mathcal{C} \\to 1",
			  "gloss": "In the weak-field regime, coherence asymptotically approaches unity, ensuring stable decay-reinforcement balance."
			}
		  ],

		  "pseudocode": [
			{
			  "name": "update_coherence_state",
			  "role": "observer",
			  "inputs": ["lambda", "gamma_co", "eta_occ", "epsilon"],
			  "outputs": ["C_next"],
			  "params": ["k1", "k2", "gamma_0"],
			  "algorithm": [
				"1. measure eta_occ ‚Üê LTMM_usage / C_max",
				"2. gamma_co ‚Üê gamma_0 + k1 * eta_occ + k2 * max(0, lambda - lambda_eq)",
				"3. dC ‚Üê lambda - gamma_co + epsilon",
				"4. C_next ‚Üê C + dC * dt",
				"5. if C_next > 1 then C_next ‚Üê 1   # enforce weak-field limit",
				"6. record telemetry: {C_next, gamma_co, eta_occ, RIR, SII}"
			  ],
			  "comment": "Observer-only process adjusting damping adaptively to maintain homeostasis and prevent runaway promotion."
			}
		  ],

		  "invariants": [
			{
			  "name": "Adaptive Saturation Law",
			  "condition": "gamma_co increases monotonically with LTMM occupancy or sustained lambda > lambda_eq",
			  "bound": "ensures dC/dt ‚Üí 0 as eta_occ ‚Üí 1",
			  "source": "RFC-0009 ¬ß7.1"
			},
			{
			  "name": "Homeostatic Equilibrium",
			  "condition": "RIR * SII ‚âà k_homeostasis ¬± Œµ",
			  "bound": "System remains lawful when deviation < Œµ_homeo",
			  "source": "RFC-0009 ¬ß7.3"
			},
			{
			  "name": "Weak-Field Convergence",
			  "condition": "as field pressure ‚Üí 0, C ‚Üí 1",
			  "bound": "Guarantees no motif amplification under minimal excitation",
			  "source": "RFC-0006 ¬ß1.1"
			}
		  ],

		  "telemetry": [
			{
			  "metric": "mean_C",
			  "range": "[0,1]",
			  "units": "dimensionless",
			  "window": "EMA-64",
			  "description": "Average coherence level across motifs."
			},
			{
			  "metric": "eta_occ",
			  "range": "[0,1]",
			  "units": "fraction",
			  "window": "EMA-32",
			  "description": "LTMM occupancy ratio guiding adaptive damping."
			},
			{
			  "metric": "gamma_co",
			  "range": "[0.1,1.0]",
			  "units": "dimensionless",
			  "window": "EMA-32",
			  "description": "Effective damping factor adjusted per occupancy and reinforcement."
			}
		  ],

		  "references": [
			"RFC-0005 ¬ß4.2 (Lawful Decay Dynamics)",
			"RFC-0006 ¬ß1.1 (Coherence Geometry and Time Vector)",
			"RFC-0009 ¬ß7.1‚Äì¬ß7.3 (Homeostasis and Resonance Bands)",
			"PDP-0001 ¬ß3.2 (Structural Scaffolding)"
		  ],

		  "handoff": "With invariants fixed, we now carry the symbols forward to the next clause, keeping ùíû steady and the cadence light."
		},
      "1.2": {
		  "id": "1.2",
		  "title": "System Context",
		  "objective": "Define boundary interactions and roles for the Motif Memory Manager (MMM) as an observer-class Layer_1 substrate receiving motif updates, validating ontology bundles, projecting decay/retention along the coherence time vector, and emitting lawful telemetry and artifacts to adjacent layers without performing control writes.",
		  "summary": "MMM sits between motif evaluators (RFC-CORE-002/003) and routing/integrity/ontology services (RFC-0008/0009/0007). Inputs arrive as Symbolic Exchange Packets; MMM validates, updates observer-state for short-term/long-term fields, and produces DensityReports, OntologyBundles, and immune telemetry. All exports are envelope- and lineage-aware when feature flags are enabled; all imports are ontology-first and DAG-validated. Adaptive feedback keeps reinforcement bounded via homeostasis signals from RFC-0009 while weak-field limits guarantee stability.",
		  "interfaces": {
			"ingress": [
			  "Symbolic Exchange Packet stream from RFC-CORE-002 (RecursiveAgentFT) and RFC-CORE-003 (LogicalAgentAT) via RFC-0008 ¬ß5.",
			  "OntologyBundle import requests conforming to RFC-0007 ¬ß4‚Äì¬ß6 with DAG validation (RFC-0007 ¬ß8) before any load.",
			  "Immune-integrity feedback frames (SII, RIR, near_miss) from RFC-0009 ¬ß9.3."
			],
			"egress": [
			  "DensityReport (observer summary) to RFC-0008 routers for downstream consumers.",
			  "OntologyBundle export (observer snapshot), gated by provenance+lineage when integrity/exchange flags are enabled.",
			  "Immune telemetry stream (C, lambda, gamma_co, rho_res, delta_closure, SII, RIR) to RFC-0009 monitors."
			],
			"roles": [
			  "MMM is observer-only at Layer_1; it SHALL NOT perform control writes to Œû.",
			  "Exchange wrapping and integrity lineage are feature-flag gated (policy deferred to app-spec at Layer_2)."
			]
		  },
		  "algorithms": [
			{
			  "name": "ingest_symbolic_packet",
			  "role": "observer",
			  "inputs": ["packet", "agent_id", "tick_id"],
			  "outputs": ["status", "trace_entry"],
			  "params": ["validate_envelope=true", "validate_lineage=true"],
			  "steps": [
				"1. if validate_envelope then assert packet.exchange_compliant per RFC-0008 ¬ß5",
				"2. extract motif_state := {C, lambda, gamma_co, rho_res, delta_closure}",
				"3. append observer trace with tick_id and motif_state",
				"4. update short-term observer fields (no control writes)",
				"5. emit immune telemetry frame {C, rho_res, delta_closure, SII, RIR}",
				"6. return status=ok"
			  ]
			},
			{
			  "name": "import_ontology_bundle",
			  "role": "observer",
			  "inputs": ["bundle"],
			  "outputs": ["status"],
			  "params": ["require_provenance=true", "require_lineage=true"],
			  "steps": [
				"1. validate version matches 'YYYY-QX' and schema=RFC-0007",
				"2. run DAG validation (RFC-0007 ¬ß8); reject on cycle",
				"3. if require_lineage then verify lineage.Delta_hash (RFC-0009 Appx D.4)",
				"4. if require_provenance then verify provenance fields present",
				"5. stage bundle in observer memory; do not overwrite live control state",
				"6. return status=accepted|rejected"
			  ]
			},
			{
			  "name": "export_density_report",
			  "role": "observer",
			  "inputs": ["window"],
			  "outputs": ["density_report"],
			  "params": ["attach_envelope=true", "attach_lineage=true"],
			  "steps": [
				"1. summarize EMA-windowed observer metrics {mean_C, rho_res_band, triad_closure_rate}",
				"2. construct density_report with on-wire ASCII keys",
				"3. if attach_envelope then compute Sigma_phase (RFC-0008 ¬ß5.3)",
				"4. if attach_lineage then compute Delta_hash (RFC-0009 Appx D.4)",
				"5. return density_report"
			  ]
			}
		  ],
		  "math": [
			{
			  "eq_id": "Eq.1",
			  "role": "coherence evolution",
			  "latex": "\\frac{dC}{dt} = \\lambda - \\gamma_{co} + \\varepsilon",
			  "gloss": "Observer-tracked law governing motif coherence change across ticks."
			},
			{
			  "eq_id": "Eq.2",
			  "role": "time vector",
			  "latex": "T^{\\mu} := \\nabla^{\\mu} C",
			  "gloss": "Projection direction used to interpret decay/retention along coherence geometry (RFC-0006 ¬ß1.1)."
			},
			{
			  "eq_id": "Eq.3",
			  "role": "homeostasis",
			  "latex": "RIR \\cdot SII \\approx k_{homeostasis}",
			  "gloss": "Invariant guiding adaptive feedback and bounded reinforcement (RFC-0009 ¬ß7.1)."
			},
			{
			  "eq_id": "Eq.4",
			  "role": "weak-field limit",
			  "latex": "\\mathcal{C} \\to 1",
			  "gloss": "Under weak-field conditions, coherence approaches unity ensuring stable observer operation."
			}
		  ],
		  "invariants": [
			{
			  "name": "Observer-Only Boundary",
			  "condition": "MMM performs no control writes; all actions are measurement, sealing, routing.",
			  "source": "PDP-0001 ¬ß4.5; RFC-0009 ¬ß12"
			},
			{
			  "name": "Ontology-First Import",
			  "condition": "DAG validation and version check precede any staging or reconciliation.",
			  "source": "RFC-0007 ¬ß4‚Äì¬ß6, ¬ß8"
			},
			{
			  "name": "Feature-Flagged Exchange/Integrity",
			  "condition": "Sigma_phase and Delta_hash are attached and verified only when flags are enabled.",
			  "source": "RFC-0008 ¬ß5.3; RFC-0009 Appx D.4"
			}
		  ],
		  "telemetry": [
			{
			  "metric": "mean_C",
			  "range": "[0,1]",
			  "units": "dimensionless",
			  "window": "EMA-64",
			  "description": "Average coherence across staged motifs for observer export."
			},
			{
			  "metric": "triad_closure_rate",
			  "range": "[0,1]",
			  "units": "events/tick",
			  "window": "EMA-32",
			  "description": "Rate of motifs satisfying closure threshold for lawful recall."
			},
			{
			  "metric": "rho_res_band",
			  "range": "[0,1]",
			  "units": "dimensionless",
			  "window": "EMA-32",
			  "description": "Share of motifs within the resonance band specified by RFC-0009."
			}
		  ],
		  "references": [
			"RFC-0008 ¬ß5 (Symbolic Exchange Packets and envelopes)",
			"RFC-0007 ¬ß4‚Äì¬ß6, ¬ß8 (Ontology schema and DAG validation)",
			"RFC-0009 ¬ß7.1, ¬ß9.3, ¬ß12 (Homeostasis, recovery, ethics)",
			"RFC-0006 ¬ß1.1 (Coherence geometry and T^mu)",
			"RFC-0005 ¬ß4.2 (Lawful decay dynamics)"
		  ],
		  "diagram_hint": "Show STMM ‚Üî LTMM observer flows, ingress from RFC-CORE-002/003 via RFC-0008 envelope, ontology DAG gate on import, and telemetry egress to RFC-0009 monitors.",
		  "handoff": "With invariants fixed, we now carry the symbols forward to the next clause, keeping ùíû steady and the cadence light."
		}
    },

    "2": {
      "2.1": {
		  "id": "2.1",
		  "title": "Core Invariants of Memory Fields",
		  "objective": "Formalize the conserved and adaptive quantities that govern motif memory states in œà-space, ensuring that reinforcement and decay remain bounded under dynamic motif load. The invariants described here define the lawful balance between coherence, resonance, and memory capacity for both short-term and long-term fields.",
		  "summary": "The Motif Memory Manager (MMM) maintains coherence across symbolic ticks through adaptive feedback laws that dynamically adjust damping (gamma_co) and capacity utilization (eta_occ). These parameters evolve together to prevent runaway reinforcement and preserve triadic closure. The invariants below extend RFC-0005‚ÄìRFC-0009 by introducing C_max (maximum lawful LTMM occupancy) and a damping adaptation function gamma_co ‚Üê f(lambda, eta_occ). Together they uphold the homeostasis condition RIR¬∑SII ‚âà k_homeostasis and ensure lawful motif persistence even as field load fluctuates.",
		  "definitions": [
			{
			  "symbol": "C(t)",
			  "name": "Coherence Potential",
			  "latex": "\\frac{dC}{dt} = \\lambda - \\gamma_{co} + \\varepsilon",
			  "gloss": "Temporal evolution of coherence; positive when reinforcement exceeds damping, negative when decaying."
			},
			{
			  "symbol": "rho_res",
			  "name": "Resonance Coefficient",
			  "latex": "0.3 \\leq \\rho_{res} \\leq 0.7",
			  "gloss": "Range of lawful motif retention defined in RFC-0009 ¬ß7.3."
			},
			{
			  "symbol": "tau_decay",
			  "name": "Characteristic Decay Time",
			  "latex": "\\tau_{decay} = \\frac{1}{\\zeta}",
			  "gloss": "Inverse of the resonance-decay slope (RFC-0005 ¬ß4.2)."
			},
			{
			  "symbol": "T^mu",
			  "name": "Coherence Time Vector",
			  "latex": "T^{\\mu} := \\nabla^{\\mu} C",
			  "gloss": "Operational direction of temporal evolution in coherence geometry (RFC-0006 ¬ß1.1)."
			},
			{
			  "symbol": "C_max",
			  "name": "Lawful Capacity Limit",
			  "latex": "0 < C_{max} \\leq 1.0",
			  "gloss": "Normalized upper bound on LTMM occupancy; governs adaptive damping to prevent saturation."
			}
		  ],
		  "math": [
			{
			  "eq_id": "Eq.1",
			  "role": "governing law",
			  "latex": "\\frac{dC}{dt} = \\lambda - \\gamma_{co} + \\varepsilon",
			  "gloss": "Primary coherence law defining memory field evolution (RFC-0009 Eq.1)."
			},
			{
			  "eq_id": "Eq.2",
			  "role": "adaptive damping",
			  "latex": "\\gamma_{co}(t) = \\gamma_0 + k_1 \\cdot \\eta_{occ} + k_2 \\cdot (\\lambda - \\lambda_{eq})",
			  "gloss": "Damping increases with memory occupancy (Œ∑_occ) and surplus reinforcement Œª ‚àí Œª_eq to prevent over-promotion."
			},
			{
			  "eq_id": "Eq.3",
			  "role": "decay constant",
			  "latex": "\\tau_{decay} = 1/\\zeta",
			  "gloss": "Characteristic time for lawful forgetting (RFC-0005 ¬ß4.2)."
			},
			{
			  "eq_id": "Eq.4",
			  "role": "closure law",
			  "latex": "\\Delta_{closure} = \\oint_{\\triangle} \\Phi = 0",
			  "gloss": "Triadic closure ensures conservation of symbolic form (RFC-0006 ¬ß4.4)."
			},
			{
			  "eq_id": "Eq.5",
			  "role": "homeostasis law",
			  "latex": "RIR \\cdot SII \\approx k_{homeostasis}",
			  "gloss": "Maintains equilibrium between immune integrity and resonance (RFC-0009 ¬ß7.1)."
			},
			{
			  "eq_id": "Eq.6",
			  "role": "weak-field limit",
			  "latex": "\\mathcal{C} \\to 1",
			  "gloss": "In weak-field conditions, coherence approaches unity ensuring stability."
			}
		  ],
		  "pseudocode": [
			{
			  "name": "update_invariants",
			  "role": "observer",
			  "inputs": ["lambda", "gamma_co", "eta_occ", "epsilon"],
			  "outputs": ["C_next", "gamma_co_next"],
			  "params": ["gamma_0", "k1", "k2", "C_max"],
			  "steps": [
				"1. eta_occ ‚Üê LTMM_usage / C_max",
				"2. gamma_co_next ‚Üê gamma_0 + k1 * eta_occ + k2 * max(0, lambda - lambda_eq)",
				"3. dC ‚Üê lambda - gamma_co_next + epsilon",
				"4. C_next ‚Üê C + dC * dt",
				"5. enforce: if C_next > 1 then C_next ‚Üê 1  # weak-field saturation",
				"6. emit telemetry {C_next, gamma_co_next, eta_occ, RIR, SII}"
			  ],
			  "comment": "Adaptive observer update law that regulates coherence and damping under dynamic motif load."
			}
		  ],
		  "invariants": [
			{
			  "name": "Adaptive Capacity Constraint",
			  "condition": "eta_occ = LTMM_usage / C_max; gamma_co increases monotonically with eta_occ",
			  "bound": "as eta_occ ‚Üí 1, dC/dt ‚Üí 0 (saturation equilibrium)",
			  "source": "RFC-0009 ¬ß7.1‚Äì¬ß7.3"
			},
			{
			  "name": "Homeostatic Balance",
			  "condition": "RIR * SII ‚âà k_homeostasis ¬± Œµ_homeo",
			  "bound": "System stable when deviation below Œµ_homeo",
			  "source": "RFC-0009 ¬ß7.1"
			},
			{
			  "name": "Resonance Band",
			  "condition": "0.3 ‚â§ rho_res ‚â§ 0.7",
			  "bound": "Ensures lawful retention band for motifs",
			  "source": "RFC-0009 ¬ß7.3"
			},
			{
			  "name": "Triadic Closure Conservation",
			  "condition": "Œî_closure = 0",
			  "bound": "Preserves motif identity and closure completeness",
			  "source": "RFC-0006 ¬ß4.4"
			},
			{
			  "name": "Weak-Field Convergence",
			  "condition": "as field pressure ‚Üí 0, C ‚Üí 1",
			  "bound": "Guarantees coherence normalization at low excitation",
			  "source": "RFC-0006 ¬ß1.1"
			}
		  ],
		  "telemetry": [
			{
			  "metric": "eta_occ",
			  "range": "[0,1]",
			  "units": "fraction",
			  "window": "EMA-32",
			  "description": "LTMM occupancy ratio controlling adaptive damping."
			},
			{
			  "metric": "gamma_co",
			  "range": "[0.1,1.0]",
			  "units": "dimensionless",
			  "window": "EMA-32",
			  "description": "Dynamic damping coefficient after feedback adjustment."
			},
			{
			  "metric": "mean_C",
			  "range": "[0,1]",
			  "units": "dimensionless",
			  "window": "EMA-64",
			  "description": "Average motif coherence maintained under adaptive homeostasis."
			}
		  ],
		  "references": [
			"RFC-0005 ¬ß4.2 (Lawful Decay and Forgetting)",
			"RFC-0006 ¬ß1.1, ¬ß4.4 (Coherence Geometry and Triadic Closure)",
			"RFC-0009 ¬ß7.1‚Äì¬ß7.3 (Homeostasis and Resonance Invariants)",
			"PDP-0001 ¬ß3.4 (Fidelity and Structural Compliance)"
		  ],
		  "handoff": "With invariants fixed, we now carry the symbols forward to the next clause, keeping ùíû steady and the cadence light."
		},
      "2.2": {
		  "id": "2.2",
		  "title": "Short-Term and Long-Term Motif Memory Fields",
		  "objective": "Define and differentiate STMM and LTMM update laws, adaptive promotion and consolidation rules, and capacity management via equivalence-based compression and lawful retention horizons.",
		  "summary": "STMM provides fast, lossy observer buffering; LTMM provides durable, equivalence-aware consolidation. Promotion from STMM to LTMM is adaptive and gated by coherence, closure, and resonance bands. When LTMM occupancy rises above a dynamic threshold, the system initiates pruning or compression using motif equivalence per closure laws. Retention is governed by a dynamic horizon tied to decay time and observed access, with a bounded TTL_max for safety. All rules remain observer-class and project along the coherence time vector.",
		  "math": [
			{
			  "eq_id": "Eq.1",
			  "role": "stmm update",
			  "latex": "STMM_{t+1} = STMM_t + \\eta\\,\\Delta C_t - \\zeta\\,STMM_t",
			  "gloss": "Short-term buffer update with reinforcement eta and decay zeta."
			},
			{
			  "eq_id": "Eq.2",
			  "role": "ltmm update",
			  "latex": "LTMM_{t+1} = LTMM_t + \\kappa\\,EMA_{64}(C_t) - \\theta\\,\\Delta H_t",
			  "gloss": "Long-term consolidation driven by smoothed coherence and entropy reduction."
			},
			{
			  "eq_id": "Eq.3",
			  "role": "promotion condition",
			  "latex": "EMA_{64}(C) \\geq \\lambda_{thresh}(t)\\ \\wedge\\ \\Delta_{closure} < \\varepsilon_{triad}\\ \\wedge\\ 0.3 \\leq \\rho_{res} \\leq 0.7",
			  "gloss": "Adaptive promotion requires coherence, triadic closure, and resonance-band compliance."
			},
			{
			  "eq_id": "Eq.4",
			  "role": "decay law",
			  "latex": "\\frac{dC}{dt} = \\lambda - \\gamma_{co} + \\varepsilon",
			  "gloss": "Governing law for coherence evolution applied per tick with smoothing."
			},
			{
			  "eq_id": "Eq.5",
			  "role": "decay time",
			  "latex": "\\tau_{decay} = \\frac{1}{\\zeta}",
			  "gloss": "Characteristic time for lawful forgetting."
			},
			{
			  "eq_id": "Eq.6",
			  "role": "occupancy and capacity trigger",
			  "latex": "\\eta_{occ} = \\frac{LTMM\\_{usage}}{C\\_{max}},\\quad \\eta_{occ} > \\rho_{thresh}(t) \\Rightarrow \\text{compress\\_or\\_prune}",
			  "gloss": "Compression or pruning is triggered when dynamic occupancy exceeds the resonance-informed threshold."
			},
			{
			  "eq_id": "Eq.7",
			  "role": "retention horizon",
			  "latex": "T\\!\\!H(t) = \\min\\big( \\alpha\\,\\tau_{decay} + \\beta\\,EMA_{32}(f_{access}),\\ \\text{TTL\\_max}(t) \\big)",
			  "gloss": "Adaptive retention horizon balances decay time and recent access, capped by a dynamic TTL_max."
			},
			{
			  "eq_id": "Eq.8",
			  "role": "weak-field limit",
			  "latex": "\\mathcal{C} \\to 1",
			  "gloss": "Under weak-field conditions, coherence approaches unity ensuring stability."
			}
		  ],
		  "pseudocode": [
			{
			  "name": "update_stmm",
			  "role": "observer",
			  "inputs": ["delta_C", "eta", "zeta"],
			  "outputs": ["STMM_next"],
			  "params": [],
			  "algorithm": [
				"1. STMM_next ‚Üê STMM + eta * delta_C - zeta * STMM",
				"2. record telemetry {STMM_next}"
			  ],
			  "comment": "Fast observer buffer dynamics; no control writes."
			},
			{
			  "name": "consolidate_ltmm",
			  "role": "observer",
			  "inputs": ["C_ema64", "delta_H", "kappa", "theta"],
			  "outputs": ["LTMM_next"],
			  "params": [],
			  "algorithm": [
				"1. LTMM_next ‚Üê LTMM + kappa * C_ema64 - theta * delta_H",
				"2. record telemetry {LTMM_next}"
			  ],
			  "comment": "Durable consolidation using smoothed coherence and entropy reduction."
			},
			{
			  "name": "promotion_decision",
			  "role": "observer",
			  "inputs": ["C_ema64", "delta_closure", "rho_res"],
			  "outputs": ["promote_bool"],
			  "params": ["lambda_thresh", "epsilon_triad"],
			  "algorithm": [
				"1. cond1 ‚Üê (C_ema64 ‚â• lambda_thresh(t))",
				"2. cond2 ‚Üê (delta_closure < epsilon_triad)",
				"3. cond3 ‚Üê (0.3 ‚â§ rho_res ‚â§ 0.7)",
				"4. promote_bool ‚Üê cond1 AND cond2 AND cond3",
				"5. record telemetry {promote_bool}"
			  ],
			  "comment": "Adaptive gating using closure and resonance band; lambda_thresh is dynamic."
			},
			{
			  "name": "capacity_management",
			  "role": "observer",
			  "inputs": ["LTMM_usage", "C_max", "rho_thresh"],
			  "outputs": ["action"],
			  "params": ["compression_target", "prune_floor"],
			  "algorithm": [
				"1. eta_occ ‚Üê LTMM_usage / C_max",
				"2. if eta_occ ‚â§ rho_thresh(t): action ‚Üê 'none'; return",
				"3. S ‚Üê find_equivalence_classes(LTMM, eq_mode='closure_shift')",
				"4. action ‚Üê 'compress'; LTMM ‚Üê compress_by_representative(S, target=compression_target)",
				"5. if (LTMM_usage / C_max) > rho_thresh(t):",
				"6.     action ‚Üê 'prune'; LTMM ‚Üê prune_low_value(LTMM, floor=prune_floor, key=EMA32(C) * rho_res)",
				"7. record telemetry {eta_occ, action}"
			  ],
			  "comment": "First compress by motif equivalence; then prune by adaptive scoring if still saturated (RFC-0006 ¬ß4.4)."
			},
			{
			  "name": "retention_horizon_update",
			  "role": "observer",
			  "inputs": ["tau_decay", "f_access_ema32", "TTL_max"],
			  "outputs": ["TH"],
			  "params": ["alpha", "beta"],
			  "algorithm": [
				"1. TH ‚Üê min(alpha * tau_decay + beta * f_access_ema32, TTL_max(t))",
				"2. apply TH as per-retention policy for staged LTMM items",
				"3. record telemetry {TH}"
			  ],
			  "comment": "Retention horizon adapts to decay and recent access, capped by dynamic TTL_max."
			}
		  ],
		  "invariants": [
			{
			  "name": "Adaptive Promotion",
			  "condition": "Promotion requires C_ema64, closure, and resonance band; lambda_thresh(t) is dynamic.",
			  "bound": "Prevents runaway STMM‚ÜíLTMM migration under transient spikes.",
			  "source": "RFC-0005 ¬ß6.3; RFC-0009 ¬ß7.2"
			},
			{
			  "name": "Equivalence-First Capacity Control",
			  "condition": "When eta_occ exceeds rho_thresh(t), compress by closure/shift equivalence before pruning.",
			  "bound": "Preserves canonical representatives and reduces redundancy.",
			  "source": "RFC-0006 ¬ß4.4"
			},
			{
			  "name": "Lawful Retention",
			  "condition": "Retention horizon TH(t) ties to tau_decay and access; bounded by TTL_max(t).",
			  "bound": "Avoids indefinite persistence with low access despite high coherence.",
			  "source": "RFC-0005 ¬ß4.2; RFC-0009 ¬ß7.2"
			},
			{
			  "name": "Observer-Only Discipline",
			  "condition": "All algorithms are measurement, consolidation, and routing; no control writes.",
			  "bound": "Layer_1 neutrality maintained.",
			  "source": "PDP-0001 ¬ß4.5"
			}
		  ],
		  "telemetry": [
			{
			  "metric": "promotion_rate",
			  "range": "[0,1]",
			  "units": "events/tick",
			  "window": "EMA-32",
			  "description": "Fraction of STMM motifs promoted per tick."
			},
			{
			  "metric": "eta_occ",
			  "range": "[0,1]",
			  "units": "fraction",
			  "window": "EMA-32",
			  "description": "LTMM occupancy used to trigger compression and pruning."
			},
			{
			  "metric": "compression_ratio",
			  "range": "[0,1]",
			  "units": "dimensionless",
			  "window": "EMA-32",
			  "description": "Post-compression size divided by pre-compression size."
			},
			{
			  "metric": "prune_events",
			  "range": "[0,1000]",
			  "units": "events/tick",
			  "window": "EMA-16",
			  "description": "Count of motifs removed by adaptive pruning when compression is insufficient."
			},
			{
			  "metric": "retention_horizon",
			  "range": "[0, +inf)",
			  "units": "ticks",
			  "window": "EMA-32",
			  "description": "Adaptive horizon applied to LTMM items, capped by TTL_max."
			}
		  ],
		  "references": [
			"RFC-0005 ¬ß4.2, ¬ß6.3 (Lawful decay; age-weighted resurrection)",
			"RFC-0006 ¬ß4.4 (Closure and equivalence for canonical representation)",
			"RFC-0009 ¬ß7.1‚Äì¬ß7.2 (Homeostasis and lawful retention bands)",
			"PDP-0001 ¬ß4.5 (Observer-only posture)"
		  ],
		  "handoff": "With invariants fixed, we now carry the symbols forward to the next clause, keeping ùíû steady and the cadence light."
		},
	  "2.3": {
		  "id": "2.3",
		  "title": "Reanchor and Recovery Escalation Logic",
		  "objective": "Define normative recovery behavior to prevent infinite rollback loops by introducing adaptive reanchor attempts, overlap detection for tau_recovery windows, and a quarantine escalation with immune_alert telemetry while preserving observer-only discipline; extend quarantine with a diagnostic loop to satisfy RFC-0009 anti-fragility.",
		  "summary": "When integrity or resonance checks fail during motif recall or import, MMM performs a bounded series of reanchor attempts to restore the last lawful state. If failures persist or recovery windows overlap, MMM escalates to a quarantine buffer that isolates affected motifs from promotion and export while maintaining full observability. Quarantine is upgraded from passive isolation to an observer-class self-diagnostic loop that applies lawful micro-perturbations, estimates a local Jacobian, and promotes to recovery when coherence improves. All steps are observer-class; no control writes to Xi are performed. Replay/lineage checks remain gated by feature flags.",
		  "math": [
			{
			  "eq_id": "Eq.1",
			  "role": "recovery gate",
			  "latex": "\\text{violation}(t) := \\Big( \\lvert RIR \\cdot SII - k_{homeostasis} \\rvert > \\varepsilon \\Big) \\; \\vee \\; \\big( \\rho_{res} \\notin [0.3,0.7] \\big)",
			  "gloss": "Recovery is triggered by homeostasis deviation or resonance-band violation."
			},
			{
			  "eq_id": "Eq.2",
			  "role": "reanchor success test",
			  "latex": "\\text{lawful}(t) := \\big( \\Delta_{closure} = 0 \\big) \\wedge \\big( \\rho_{res} \\in [0.3,0.7] \\big) \\wedge \\big( RIR \\cdot SII \\approx k_{homeostasis} \\pm \\varepsilon \\big)",
			  "gloss": "A state is lawful when closure holds, resonance lies in-band, and homeostasis is restored."
			},
			{
			  "eq_id": "Eq.3",
			  "role": "overlap condition",
			  "latex": "\\text{overlap} := \\big( [t_{start},\\ t_{start}+\\tau_{recovery}] \\cap [t'_{start},\\ t'_{start}+\\tau_{recovery}] \\neq \\varnothing \\big)",
			  "gloss": "Escalation is triggered when recovery windows overlap in time."
			},
			{
			  "eq_id": "Eq.4",
			  "role": "adaptive attempt budget",
			  "latex": "N_{max}(t) = N_0 + \\alpha\\,EMA_{32}(\\text{stability}) - \\beta\\,EMA_{16}(\\text{violation\\_rate})",
			  "gloss": "The maximum reanchor attempts adapt to recent stability and violation rate."
			},
			{
			  "eq_id": "Eq.5",
			  "role": "diagnostic coherence law",
			  "latex": "\\big( \\lVert \\partial F / \\partial \\Xi \\rVert \\le J_{max} \\big) \\wedge \\big( \\Delta_{closure} \\downarrow \\big) \\Rightarrow \\mathcal{C} \\uparrow",
			  "gloss": "Bounded local Jacobian with improving closure implies increasing coherence during diagnostics."
			},
			{
			  "eq_id": "Eq.6",
			  "role": "weak-field limit",
			  "latex": "\\mathcal{C} \\to 1",
			  "gloss": "Under weak-field conditions, coherence approaches unity; recovery becomes a no-op."
			}
		  ],
		  "algorithms": [
			{
			  "name": "reanchor_protocol",
			  "role": "observer",
			  "inputs": ["snapshot_history", "tau_recovery", "N0", "alpha", "beta"],
			  "outputs": ["status"],
			  "params": ["stability_ema32", "violation_rate_ema16"],
			  "steps": [
				"1. if not violation(t): return status='no_action'",
				"2. N_max <- N0 + alpha * stability_ema32 - beta * violation_rate_ema16",
				"3. for i in 1..ceil(max(1, N_max)):",
				"4.     candidate <- last_lawful(snapshot_history, window=tau_recovery)",
				"5.     if candidate == null: break",
				"6.     stage_observer_state(candidate)   # no control writes",
				"7.     if lawful(t): emit_telemetry('reanchor_success'); return status='recovered'",
				"8.     emit_telemetry('reanchor_attempt')",
				"9. if overlap_recovery_windows(): return quarantine_escalation()",
				"10. return quarantine_escalation()"
			  ],
			  "comment": "Attempts to restore the last lawful observer state within tau_recovery; bounded and adaptive."
			},
			{
			  "name": "quarantine_escalation",
			  "role": "observer",
			  "inputs": ["offending_set"],
			  "outputs": ["status"],
			  "params": ["quarantine_ttl", "notify_immune=true", "suppress_export=true"],
			  "steps": [
				"1. move offending_set -> QUARANTINE_BUFFER",
				"2. mark offending_set: promotion=false, export=false, prune=false",
				"3. if notify_immune: emit_telemetry('immune_alert', payload={offending_set, reason:'escalation'})",
				"4. start timer(quarantine_ttl); maintain full read-only observability",
				"5. return status='quarantined'"
			  ],
			  "comment": "Escalation isolates problematic motifs while keeping them observable for diagnosis."
			},
			{
			  "name": "quarantine_diagnostic_loop",
			  "role": "observer",
			  "inputs": ["quarantined_motif_set"],
			  "outputs": ["status"],
			  "params": ["perturbation_cap=0.01", "phase_interval=Delta_tau_phase", "J_max"],
			  "steps": [
				"1. for each motif in quarantined_motif_set:",
				"2.     apply lawful micro-perturbations to {lambda, gamma_co} with magnitude <= perturbation_cap",
				"3.     estimate J_local <- jacobian_estimate({lambda, gamma_co, SII}, window='EMA-16')",
				"4.     if SII increases AND delta_closure decreases AND norm(J_local) <= J_max:",
				"5.         emit_telemetry('diagnostic_pass', payload={motif})",
				"6.         move motif -> RECOVERY_BUFFER; continue",
				"7.     else:",
				"8.         emit_telemetry('diagnostic_retry', payload={motif})",
				"9. wait phase_interval and repeat until quarantine_ttl expires or all motifs promoted",
				"10. if any motifs remain and ttl expired: emit_telemetry('quarantine_hold'); return status='quarantined'",
				"11. if all motifs promoted: return status='recovery'"
			  ],
			  "comment": "Observer-class self-diagnostic per RFC-0009: bounded Jacobian and improving closure/resonance are required for exit from quarantine."
			},
			{
			  "name": "import_guard",
			  "role": "observer",
			  "inputs": ["bundle"],
			  "outputs": ["status"],
			  "params": ["require_envelope", "require_lineage", "require_dag"],
			  "steps": [
				"1. if require_dag and not dag_valid(bundle): emit_telemetry('near_miss'); return status='rejected'",
				"2. if require_envelope and not envelope_valid(bundle): emit_telemetry('near_miss'); return status='rejected'",
				"3. if require_lineage and not lineage_valid(bundle): emit_telemetry('near_miss'); return status='rejected'",
				"4. stage bundle observer-side; do not merge into LTMM until lawful() passes",
				"5. return status='staged'"
			  ],
			  "comment": "Prevents unlawful states from entering live memory; aligns with RFC-0007 and RFC-0009."
			}
		  ],
		  "invariants": [
			{
			  "name": "Bounded Recovery",
			  "condition": "Reanchor attempts <= N_max(t); windows limited to tau_recovery.",
			  "bound": "Prevents infinite rollback loops under persistent violations.",
			  "source": "RFC-0009 ¬ß9.3"
			},
			{
			  "name": "Escalation on Overlap",
			  "condition": "If recovery windows overlap or attempts exhausted -> quarantine.",
			  "bound": "Ensures forward progress and diagnostic isolation.",
			  "source": "RFC-0009 ¬ß9.3; RFC-0005 ¬ß4"
			},
			{
			  "name": "Anti-Fragile Quarantine",
			  "condition": "Within quarantine, apply lawful micro-perturbations, estimate bounded local Jacobian, and require improving closure/resonance for exit.",
			  "bound": "Converts passive resilience to adaptive learning while keeping observer-only posture.",
			  "source": "RFC-0009 ¬ß9.3‚Äì10.3"
			},
			{
			  "name": "Observer-Only Discipline",
			  "condition": "Recovery and quarantine manipulate staged observer state only; no control writes to Xi.",
			  "bound": "Maintains Layer_1 neutrality.",
			  "source": "PDP-0001 ¬ß4.5"
			}
		  ],
		  "telemetry": [
			{
			  "metric": "reanchor_rate",
			  "range": "[0,1]",
			  "units": "events/tick",
			  "window": "EMA-32",
			  "description": "Frequency of reanchor attempts per tick."
			},
			{
			  "metric": "reanchor_fail_count",
			  "range": "[0,1000]",
			  "units": "events/tick",
			  "window": "EMA-16",
			  "description": "Count of failed attempts before escalation."
			},
			{
			  "metric": "quarantine_count",
			  "range": "[0,1000]",
			  "units": "sets",
			  "window": "EMA-32",
			  "description": "Number of motif sets currently in quarantine."
			},
			{
			  "metric": "recovery_latency",
			  "range": "[0,+inf)",
			  "units": "ticks",
			  "window": "EMA-32",
			  "description": "Ticks from violation detection to recovery or escalation."
			},
			{
			  "metric": "J_local",
			  "range": "[0,J_max]",
			  "units": "unitless",
			  "window": "EMA-16",
			  "description": "Local Jacobian norm estimate during diagnostic quarantine."
			},
			{
			  "metric": "q_state",
			  "range": "[0,1]",
			  "units": "fraction",
			  "window": "EMA-32",
			  "description": "Share of quarantined motifs that have passed the last diagnostic step."
			},
			{
			  "metric": "tau_rec_est",
			  "range": "[0,+inf)",
			  "units": "ticks",
			  "window": "EMA-16",
			  "description": "Estimated ticks remaining to exit quarantine for passing motifs."
			}
		  ],
		  "compatibility": {
			"exchange": "If enable_exchange_envelope=true, quarantine suppresses export_* and therefore Sigma_phase generation for quarantined motifs.",
			"integrity": "If enable_integrity_checks=true, import_guard requires Delta_hash lineage and rejects on mismatch.",
			"provenance": "If enable_provenance_on_export=true, quarantine artifacts include provenance markers but are not routable."
		  },
		  "references": [
			"RFC-0009 ¬ß9.3‚Äì10.3 (Recovery, self-diagnostic testing, bounded time law)",
			"RFC-0005 ¬ß4 (Temporal integrity and lawful restoration)",
			"RFC-0006 ¬ß4.4 (Closure conditions for lawful states)",
			"RFC-0007 ¬ß8 (Ontology DAG validation)",
			"RFC-0008 ¬ß4.3‚Äì5.2 (Exchange envelope and phase windowing)",
			"PDP-0001 ¬ß4.5 (Observer-only posture)"
		  ],
		  "handoff": "With invariants fixed, we now carry the symbols forward to the next clause, keeping ùíû steady and the cadence light."
		}		
    },

    "3": {
      "3.1": {
		  "id": "3.1",
		  "title": "Motif Ontology Bundles",
		  "objective": "Define schema, provenance, and lineage rules for motif ontology bundles used in cross-agent memory exchange, ensuring lawful validation, integrity, and reconciliation under DAG constraints. Extend RFC-0007 by adding dynamic merge/fork semantics using Œî_hash lineage and provenance metadata.",
		  "summary": "Motif Ontology Bundles (MOBs) serve as the canonical carriers of motif state and relationships between agents. Each bundle adheres to the ontology schema defined in RFC-0007 and maintains lineage integrity per RFC-0009. When exchanged across agents, bundles merge if their ancestry is identical (verified by Œî_hash lineage) and fork otherwise. Provenance metadata preserves origin and divergence events, ensuring coherent synchronization of distributed symbolic memory. The structure is fully observer-class, with export and import governed by feature flags controlling Sigma_phase and Delta_hash validation.",
		  "schema": {
			"fields": [
			  "motif_id",
			  "parents",
			  "dyad_links",
			  "triad_links",
			  "usage_frequency",
			  "psi_field",
			  "integrity_vector",
			  "timestamp",
			  "version"
			],
			"provenance": {
			  "origin": "agent_id",
			  "origin_hash": "sha256(agent_id || created_at || bundle_digest)",
			  "created_at": "ISO-8601"
			},
			"lineage": {
			  "parent_hash": "Delta_hash(previous_bundle)",
			  "integrity_hash": "Delta_hash(current_bundle)",
			  "schema": "rfc0009.integrity.v1"
			},
			"storage_profile": {
			  "profile": "volatile | durable",
			  "retention_ticks": "tau_decay",
			  "provenance_required": true
			},
			"validation": [
			  "MUST validate ontology DAG (RFC-0007 ¬ß8).",
			  "MUST include version formatted as 'YYYY-QX' (RFC-0007 ¬ß4.1).",
			  "MUST verify lineage.integrity_hash when enable_integrity_checks=true.",
			  "MUST reject cyclic or orphaned bundles prior to import.",
			  "MUST compare lineage.parent_hash across agents before merge."
			]
		  },
		  "math": [
			{
			  "eq_id": "Eq.1",
			  "role": "lineage validation",
			  "latex": "Delta_{hash}(current) = H(bundle_t) = H(meta_t || data_t)",
			  "gloss": "Integrity hash computed as deterministic function of bundle metadata and payload per RFC-0009 Appx D.4."
			},
			{
			  "eq_id": "Eq.2",
			  "role": "merge condition",
			  "latex": "merge \\Leftrightarrow parent\\_hash_A = parent\\_hash_B \\wedge integrity\\_hash_A = integrity\\_hash_B",
			  "gloss": "Bundles merge if and only if ancestry and current state are identical."
			},
			{
			  "eq_id": "Eq.3",
			  "role": "fork condition",
			  "latex": "fork \\Leftrightarrow parent\\_hash_A = parent\\_hash_B \\wedge integrity\\_hash_A \\neq integrity\\_hash_B",
			  "gloss": "Bundles fork when ancestry is shared but present state diverges."
			},
			{
			  "eq_id": "Eq.4",
			  "role": "weak-field invariant",
			  "latex": "\\mathcal{C} \\to 1",
			  "gloss": "Under weak-field conditions, coherence approaches unity ensuring stable export/import behavior."
			}
		  ],
		  "algorithms": [
			{
			  "name": "validate_bundle",
			  "role": "observer",
			  "inputs": ["bundle"],
			  "outputs": ["status"],
			  "params": ["require_dag=true", "require_version=true", "require_lineage=true"],
			  "steps": [
				"1. if require_dag and not dag_valid(bundle): emit_telemetry('dag_invalid'); return status='rejected'",
				"2. if require_version and not version_valid(bundle.version): emit_telemetry('version_invalid'); return status='rejected'",
				"3. if require_lineage and not lineage_valid(bundle.lineage): emit_telemetry('lineage_invalid'); return status='rejected'",
				"4. if has_cycles(bundle): emit_telemetry('cycle_detected'); return status='rejected'",
				"5. return status='valid'"
			  ],
			  "comment": "Ensures bundle compliance with RFC-0007 schema and RFC-0009 lineage before import."
			},
			{
			  "name": "merge_or_fork",
			  "role": "observer",
			  "inputs": ["bundle_A", "bundle_B"],
			  "outputs": ["merged_bundle", "status"],
			  "params": ["allow_divergence=true", "record_provenance=true"],
			  "steps": [
				"1. if bundle_A.lineage.parent_hash != bundle_B.lineage.parent_hash: return status='unrelated'; no_merge()",
				"2. if bundle_A.lineage.integrity_hash == bundle_B.lineage.integrity_hash:",
				"3.     merged_bundle ‚Üê unify_fields(bundle_A, bundle_B, strategy='latest_timestamp')",
				"4.     record_provenance_event('merge', origin=bundle_A.provenance.origin)",
				"5.     return merged_bundle, status='merged'",
				"6. else:",
				"7.     if allow_divergence:",
				"8.         fork_A, fork_B ‚Üê mark_divergence(bundle_A, bundle_B)",
				"9.         record_provenance_event('fork', details={bundle_A.id, bundle_B.id})",
				"10.        return {fork_A, fork_B}, status='forked'",
				"11.    else: return status='rejected'"
			  ],
			  "comment": "Determines merge or fork outcome using Œî_hash lineage comparison and updates provenance records accordingly."
			},
			{
			  "name": "export_bundle",
			  "role": "observer",
			  "inputs": ["bundle"],
			  "outputs": ["packet"],
			  "params": ["attach_envelope=true", "attach_lineage=true"],
			  "steps": [
				"1. if attach_envelope: compute Sigma_phase per RFC-0008 ¬ß5.3",
				"2. if attach_lineage: compute Delta_hash(bundle) per RFC-0009 Appx D.4",
				"3. attach provenance {origin, origin_hash, created_at}",
				"4. wrap bundle in envelope {Sigma_phase, Delta_hash}",
				"5. return packet"
			  ],
			  "comment": "Prepares lawful bundle export with integrity and exchange checksums when flags are enabled."
			}
		  ],
		  "invariants": [
			{
			  "name": "Ontology DAG Law",
			  "condition": "All bundles must form an acyclic directed graph validated before export/import.",
			  "bound": "Reject cyclic graphs and orphaned motifs.",
			  "source": "RFC-0007 ¬ß8"
			},
			{
			  "name": "Lineage Integrity",
			  "condition": "Delta_hash lineage verified against stored ancestry chain.",
			  "bound": "Reject mismatched or unknown ancestry.",
			  "source": "RFC-0009 Appx D.4"
			},
			{
			  "name": "Cross-Agent Merge Rule",
			  "condition": "Bundles merge if ancestry and integrity match; otherwise fork with provenance entry.",
			  "bound": "Prevents unlawful state overwrites in distributed LTMM.",
			  "source": "RFC-0007 ¬ß8; RFC-0009 Appx D.4"
			},
			{
			  "name": "Observer Neutrality",
			  "condition": "Merge/fork operations modify metadata only; motif content remains read-only.",
			  "bound": "Ensures Layer_1 observer status.",
			  "source": "PDP-0001 ¬ß4.5"
			}
		  ],
		  "telemetry": [
			{
			  "metric": "merge_rate",
			  "range": "[0,1]",
			  "units": "events/tick",
			  "window": "EMA-32",
			  "description": "Fraction of ontology bundles successfully merged per tick."
			},
			{
			  "metric": "fork_rate",
			  "range": "[0,1]",
			  "units": "events/tick",
			  "window": "EMA-32",
			  "description": "Fraction of ontology bundles diverging per tick."
			},
			{
			  "metric": "dag_invalid_count",
			  "range": "[0,1000]",
			  "units": "events/tick",
			  "window": "EMA-16",
			  "description": "Count of ontology DAG validation failures detected at import."
			},
			{
			  "metric": "lineage_rejects",
			  "range": "[0,1000]",
			  "units": "events/tick",
			  "window": "EMA-16",
			  "description": "Number of rejected imports due to invalid Delta_hash lineage."
			}
		  ],
		  "references": [
			"RFC-0007 ¬ß4‚Äì¬ß6, ¬ß8 (Ontology schema and DAG validation)",
			"RFC-0008 ¬ß5‚Äì¬ß6 (Exchange envelope and routing semantics)",
			"RFC-0009 ¬ß6‚Äì¬ß7, Appx D.4 (Integrity lineage and hash chaining)",
			"PDP-0001 ¬ß4.5 (Observer discipline and structural compliance)"
		  ],
		  "handoff": "With invariants fixed, we now carry the symbols forward to the next clause, keeping ùíû steady and the cadence light."
		},
      "3.2": {
		  "id": "3.2",
		  "title": "Memory Trace and Logging",
		  "objective": "Define Layer_1 trace-buffer semantics for motif recall, promotion, recovery, and capacity events, with sealed export paths gated by exchange/integrity feature flags. Tracing is observer-only: it measures, seals, and routes; it does not perform control writes to Œû.",
		  "parameters": {
			"TRACE_BUFFER_LEN": 2048,
			"LOCK_POLICY": "per-tick mutex",
			"INTERNAL_TS_RESOLUTION": "ticks",
			"RATE_LIMIT_EXPORT_QPS": 4,
			"integrity_mode": "observer_only | immune"
		  },
		  "trace_entry_schema": {
			"t": "tick_idx",
			"motif_id": "str",
			"C": "float",
			"lambda": "float",
			"gamma_co": "float",
			"rho_res": "float",
			"delta_closure": "float",
			"event": "access|retrieve|promote|demote|near_miss|reanchor_attempt|reanchor_fail|quarantine_entry|saturation_prune",
			"notes": "str?"
		  },
		  "math": [
			{
			  "eq_id": "Eq.1",
			  "role": "governing_law",
			  "latex": "\\frac{d\\mathcal{C}}{dt} = \\lambda - \\gamma_{co} + \\varepsilon",
			  "gloss": "Trace captures observer measurements of coherence evolution per tick."
			},
			{
			  "eq_id": "Eq.2",
			  "role": "purge_horizon",
			  "latex": "\\tau_{decay} = \\frac{1}{\\zeta}",
			  "gloss": "Entries older than the decay horizon are eligible for purge (RFC-0005 ¬ß4.2)."
			},
			{
			  "eq_id": "Eq.3",
			  "role": "event_rate",
			  "latex": "rate_{X}(t) = EMA_{32}\\big(\\mathbf{1}_{event=X}\\big)",
			  "gloss": "Per-event rates (e.g., reanchor_rate) are computed as EMA-32 over indicator events."
			},
			{
			  "eq_id": "Eq.4",
			  "role": "weak_field_limit",
			  "latex": "\\mathcal{C} \\to 1",
			  "gloss": "In the weak-field regime, coherence approaches unity; trace drift converges."
			}
		  ],
		  "algorithms": [
			{
			  "name": "append_trace_entry",
			  "role": "observer",
			  "inputs": ["entry"],
			  "outputs": ["status"],
			  "params": ["LOCK_POLICY", "TRACE_BUFFER_LEN"],
			  "steps": [
				"1. acquire lock(LOCK_POLICY).",
				"2. validate entry against trace_entry_schema (ASCII keys; required fields present).",
				"3. push entry onto ring buffer; if buffer length > TRACE_BUFFER_LEN, drop oldest.",
				"4. release lock.",
				"5. return status='ok'."
			  ],
			  "comment": "Thread-safe append; no control writes to Œû."
			},
			{
			  "name": "purge_old",
			  "role": "observer",
			  "inputs": ["now_tick", "tau_decay"],
			  "outputs": ["purged_count"],
			  "params": [],
			  "steps": [
				"1. cutoff_tick ‚Üê now_tick ‚àí tau_decay.",
				"2. remove all entries with t < cutoff_tick.",
				"3. return purged_count."
			  ],
			  "comment": "Implements lawful forgetting aligned to œÑ_decay = 1/Œ∂ (RFC-0005 ¬ß4.2)."
			},
			{
			  "name": "rollup_trace_summary",
			  "role": "observer",
			  "inputs": ["window_size_ticks"],
			  "outputs": ["summary"],
			  "params": [],
			  "steps": [
				"1. select entries within last window_size_ticks.",
				"2. compute EMA-32 of dC (delta C between adjacent ticks) as memory_trace_dC.",
				"3. compute event EMAs: reanchor_rate, saturation_prune_rate, quarantine_entry_rate.",
				"4. aggregate counts: promote_events, demote_events, near_miss_events.",
				"5. compute bands: rho_res_band_share = share of entries with 0.3 ‚â§ rho_res ‚â§ 0.7.",
				"6. return summary with ASCII keys suitable for on-wire export."
			  ],
			  "comment": "Provides dashboard-ready statistics without exposing raw payloads."
			},
			{
			  "name": "export_trace",
			  "role": "observer",
			  "inputs": ["summary", "feature_flags"],
			  "outputs": ["packet"],
			  "params": ["integrity_mode"],
			  "steps": [
				"1. packet ‚Üê { kind:'trace_summary', body: summary }.",
				"2. if feature_flags.enable_exchange_envelope == true: packet.Sigma_phase ‚Üê compute_phase_checksum(packet).",
				"3. if feature_flags.enable_integrity_checks == true: packet.Delta_hash ‚Üê compute_lineage_hash(packet).",
				"4. attach provenance if feature_flags.enable_provenance_on_export == true.",
				"5. enforce RATE_LIMIT_EXPORT_QPS for outbound packets.",
				"6. return packet."
			  ],
			  "comment": "Seals summary for SRX routing; checksums are strictly feature-flag gated (RFC-0008 ¬ß5.3; RFC-0009 Appx D.4)."
			}
		  ],
		  "invariants": [
			{
			  "name": "Observer_Only_Boundary",
			  "condition": "All trace operations are measurement, sealing, and routing only; no control writes to Œû.",
			  "source": "PDP-0001 ¬ß4.5"
			},
			{
			  "name": "Lawful_Purge",
			  "condition": "purge_old removes entries older than tau_decay = 1/Œ∂.",
			  "source": "RFC-0005 ¬ß4.2"
			},
			{
			  "name": "Gated_Export_Checksums",
			  "condition": "Sigma_phase present iff enable_exchange_envelope=true; Delta_hash present iff enable_integrity_checks=true.",
			  "source": "RFC-0008 ¬ß5.3; RFC-0009 Appx D.4"
			},
			{
			  "name": "Bounded_Buffer",
			  "condition": "Ring buffer length ‚â§ TRACE_BUFFER_LEN; oldest entries dropped first.",
			  "source": "RFC-0009 ¬ß7.1"
			},
			{
			  "name": "Weak_Field_Convergence",
			  "condition": "As field pressure ‚Üí 0, C ‚Üí 1 and EMA(dC) ‚Üí 0.",
			  "source": "RFC-0006 ¬ß1.1"
			}
		  ],
		  "telemetry": [
			{
			  "metric": "memory_trace_dC",
			  "range": "[-1,1]",
			  "units": "delta_per_tick",
			  "window": "EMA-32",
			  "dashboard": "memory/decay_dynamics",
			  "description": "Smoothed change in coherence between ticks derived from trace entries."
			},
			{
			  "metric": "reanchor_rate",
			  "range": "[0,1]",
			  "units": "events/tick",
			  "window": "EMA-32",
			  "dashboard": "memory/recovery",
			  "description": "Rate of reanchor_attempt events; spikes indicate instability (RFC-0009 ¬ß9.3)."
			},
			{
			  "metric": "reanchor_fail_rate",
			  "range": "[0,1]",
			  "units": "events/tick",
			  "window": "EMA-32",
			  "dashboard": "memory/recovery",
			  "description": "Rate of reanchor_fail events preceding quarantine escalation."
			},
			{
			  "metric": "quarantine_entry_rate",
			  "range": "[0,1]",
			  "units": "events/tick",
			  "window": "EMA-32",
			  "dashboard": "memory/recovery",
			  "description": "Incidence of quarantine_entry events signalling bounded escalation."
			},
			{
			  "metric": "saturation_prune_rate",
			  "range": "[0,1]",
			  "units": "events/tick",
			  "window": "EMA-32",
			  "dashboard": "memory/saturation",
			  "description": "Incidence of saturation_prune events after compression-first capacity control."
			},
			{
			  "metric": "rho_res_band_share",
			  "range": "[0,1]",
			  "units": "fraction",
			  "window": "EMA-32",
			  "dashboard": "memory/triad_closure",
			  "description": "Share of motifs operating within the resonance band 0.3‚Äì0.7."
			}
		  ],
		  "methods": [
			"append(entry): MUST be lock-protected if concurrent and validate ASCII keys.",
			"export_trace(summary): MUST attach Sigma_phase when exchange envelope enabled; MUST attach Delta_hash when integrity checks enabled.",
			"purge_old(): MUST drop entries older than tau_decay = 1/Œ∂ (RFC-0005 ¬ß4.2).",
			"rollup_trace_summary(window): SHOULD produce dashboard-aligned KPIs without raw payload leakage."
		  ],
		  "references": [
			"RFC-0005 ¬ß4.2 (Lawful decay and purge horizon)",
			"RFC-0006 ¬ß1.1 (Coherence geometry and weak-field limit)",
			"RFC-0008 ¬ß5.3 (Exchange envelope, phase checksum)",
			"RFC-0009 ¬ß7.1, ¬ß9.3 (Homeostasis and recovery telemetry)",
			"PDP-0001 ¬ß4.5 (Observer-only posture)"
		  ],
		  "handoff": "Memory prepared and sealed, we hand it to the exchange where phase keeps time."
		}
	  "3.3": {
		  "id": "3.3",
		  "title": "Glider Handling and Shift-Equivalence Compression",
		  "objective": "Define Layer_1 semantics for detecting, representing, and recalling eternal gliders under shift-equivalence so they are stored once as a canonical representative in LTMM, preventing repeated promotions and uncontrolled persistence. All behavior is observer-only and gated by feature flag enable_point_space_gliders.",
		  "feature_flag": "enable_point_space_gliders",
		  "summary": "When glider handling is enabled, motifs that translate through œà-space while preserving form are treated as members of a shift-equivalence class. MMM detects such classes from trace windows, selects a single canonical representative, compresses variants to that representative, and remaps recall queries via inverse shifts. Promotion never duplicates a class that already has a representative. Under weak-field limits, coherence converges and glider drift estimates stabilize.",
		  "math": [
			{
			  "eq_id": "Eq.1",
			  "role": "shift_equivalence",
			  "latex": "\\exists\\ (\\phi,\\tau):\\ m(x,t) \\sim m(x+\\phi,\\ t+\\tau)\\quad\\Rightarrow\\quad m \\in [m]_\\text{shift}",
			  "gloss": "A motif m is a glider if there exists a spatial shift œÜ and temporal shift œÑ such that its form recurs up to translation."
			},
			{
			  "eq_id": "Eq.2",
			  "role": "canonical_representative",
			  "latex": "Rep([m]_\\text{shift}) = \\arg\\min_{m'\\in [m]_{shift}}\\,\\big\\{ H(m'),\\ -\\mathcal{C}(m')\\big\\}",
			  "gloss": "Choose a unique canonical representative by minimal entropy (tie-breaker: maximal coherence)."
			},
			{
			  "eq_id": "Eq.3",
			  "role": "no_double_promotion",
			  "latex": "\\text{promote}(m) = 0\\ \\text{if}\\ \\exists\\ Rep([m]_{shift})",
			  "gloss": "If a class already has a representative in LTMM, do not promote additional members."
			},
			{
			  "eq_id": "Eq.4",
			  "role": "weak_field_limit",
			  "latex": "\\mathcal{C}\\to 1",
			  "gloss": "In the weak-field regime, coherence approaches unity and drift estimators (œÜ, œÑ, v) converge."
			}
		  ],
		  "algorithms": [
			{
			  "name": "detect_glider",
			  "role": "observer",
			  "inputs": ["trace_window", "rho_res_band", "ema_window='EMA-32'"],
			  "outputs": ["is_glider", "phi", "tau", "v"],
			  "params": ["xcorr_thresh", "min_period_ticks", "max_shift_radius"],
			  "steps": [
				"1. ensure feature_flag enable_point_space_gliders == true; if false return is_glider=false.",
				"2. compute cross_correlation over spatial shifts |phi| ‚â§ max_shift_radius and lags œÑ ‚â• min_period_ticks on trace_window.",
				"3. find peak (phi*, œÑ*) with normalized score s; if s ‚â• xcorr_thresh and rho_res ‚àà rho_res_band for the window, set is_glider=true.",
				"4. estimate drift velocity v ‚Üê phi*/œÑ*.",
				"5. return {is_glider, phi=phi*, tau=œÑ*, v}."
			  ],
			  "comment": "Observer-only detection using correlations and resonance gating; no control writes."
			},
			{
			  "name": "register_canonical_representative",
			  "role": "observer",
			  "inputs": ["motif_id", "phi", "tau", "v", "H", "C"],
			  "outputs": ["rep_id"],
			  "params": ["tie_breaker='max_C'"],
			  "steps": [
				"1. class_id ‚Üê hash_shift_class(motif_id, phi, tau).",
				"2. if class_id has existing representative rep_id: return rep_id.",
				"3. select candidate ‚Üê argmin_H_and_max_C over {motif_id} per Eq.2.",
				"4. add mapping {class_id ‚Üí candidate} to observer-side glider_index (read-only to LTMM).",
				"5. return rep_id=candidate."
			  ],
			  "comment": "Creates or reuses a unique representative per shift-equivalence class; LTMM content remains read-only."
			},
			{
			  "name": "compress_by_shift_equivalence",
			  "role": "observer",
			  "inputs": ["LTMM_view", "glider_index"],
			  "outputs": ["compression_report"],
			  "params": ["target_ratio"],
			  "steps": [
				"1. for each motif m in LTMM_view that matches a class_id in glider_index:",
				"2.     if m != Rep(class_id): mark m as compressed_to=Rep(class_id) in observer map.",
				"3. compute compression_ratio_shift ‚Üê (#unique_reps)/(#glider_members).",
				"4. return {compression_ratio_shift}."
			  ],
			  "comment": "Equivalence-first capacity control; aligns with closure/equivalence before any pruning."
			},
			{
			  "name": "recall_glider",
			  "role": "observer",
			  "inputs": ["query_motif_id"],
			  "outputs": ["rep_id", "inverse_shift"],
			  "params": [],
			  "steps": [
				"1. if enable_point_space_gliders == false: return {rep_id=query_motif_id, inverse_shift=(0,0)}.",
				"2. class_id ‚Üê classify_shift(query_motif_id).",
				"3. rep_id ‚Üê glider_index[class_id].",
				"4. inverse_shift ‚Üê compute_inverse_shift(query_motif_id, rep_id).",
				"5. return {rep_id, inverse_shift}."
			  ],
			  "comment": "Maps any class member to its representative for stable recall."
			},
			{
			  "name": "export_glider_index",
			  "role": "observer",
			  "inputs": ["glider_index", "feature_flags"],
			  "outputs": ["packet"],
			  "params": [],
			  "steps": [
				"1. packet ‚Üê { kind:'glider_index', body: sanitize(glider_index) }.",
				"2. if feature_flags.enable_exchange_envelope == true: packet.Sigma_phase ‚Üê compute_phase_checksum(packet).",
				"3. if feature_flags.enable_integrity_checks == true: packet.Delta_hash ‚Üê compute_lineage_hash(packet).",
				"4. attach provenance if feature_flags.enable_provenance_on_export == true.",
				"5. return packet."
			  ],
			  "comment": "Sealed export path for cross-agent synchronization; still observer-only at Layer_1."
			}
		  ],
		  "invariants": [
			{
			  "name": "Canonical_Uniqueness",
			  "condition": "Exactly one representative per shift-equivalence class in the observer index.",
			  "source": "RFC-0006 ¬ß4.4"
			},
			{
			  "name": "No_Double_Promotion",
			  "condition": "If Rep([m]_shift) exists, additional members of the class SHALL NOT be promoted to LTMM.",
			  "source": "RFC-0006 ¬ß4.4; RFC-0005 ¬ß4.2"
			},
			{
			  "name": "Equivalence_First",
			  "condition": "Compression by shift-equivalence precedes any pruning action.",
			  "source": "RFC-0006 ¬ß4.4"
			},
			{
			  "name": "Observer_Only",
			  "condition": "All algorithms measure, index, compress by mapping, and route; they SHALL NOT perform control writes to Œû.",
			  "source": "PDP-0001 ¬ß4.5"
			},
			{
			  "name": "Flag_Gating",
			  "condition": "Glider detection, compression, export, and KPIs are active only when enable_point_space_gliders=true.",
			  "source": "PDP-0001 ¬ß3.2"
			}
		  ],
		  "telemetry": [
			{
			  "metric": "glider_detected_rate",
			  "range": "[0,1]",
			  "units": "events/tick",
			  "window": "EMA-32",
			  "dashboard": "memory/glider_flow",
			  "active_when": "enable_point_space_gliders=true",
			  "description": "Rate of successful glider detections produced by detect_glider."
			},
			{
			  "metric": "compression_ratio_shift",
			  "range": "[0,1]",
			  "units": "dimensionless",
			  "window": "EMA-32",
			  "dashboard": "memory/saturation",
			  "active_when": "enable_point_space_gliders=true",
			  "description": "Unique representatives divided by total glider members after compression."
			},
			{
			  "metric": "glider_index_size",
			  "range": "[0,+inf)",
			  "units": "classes",
			  "window": "EMA-32",
			  "dashboard": "memory/glider_flow",
			  "active_when": "enable_point_space_gliders=true",
			  "description": "Number of tracked shift-equivalence classes with a canonical representative."
			},
			{
			  "metric": "glider_remap_latency",
			  "range": "[0,+inf)",
			  "units": "ticks",
			  "window": "EMA-16",
			  "dashboard": "memory/glider_flow",
			  "active_when": "enable_point_space_gliders=true",
			  "description": "Latency from recall_glider invocation to representative retrieval and inverse shift computation."
			}
		  ],
		  "examples": [
			{
			  "active_when": "enable_point_space_gliders=true",
			  "version": "2025-Q4",
			  "glider_index_entry": {
				"class_id": "shift:sha256:7f3a...",
				"rep": {
				  "motif_id": "m:alpha-001",
				  "psi_field": "œà-resonance@Œû",
				  "usage_frequency": 128
				},
				"tags": {
				  "class": "glider",
				  "v": 0.25,
				  "phi": 4,
				  "tau": 16
				}
			  }
			}
		  ],
		  "references": [
			"RFC-0006 ¬ß4.4 (Closure and equivalence for canonical representation)",
			"RFC-0005 ¬ß4.2 (Lawful decay dynamics and horizons)",
			"RFC-0008 ¬ß5.3 (Exchange envelope and Sigma_phase)",
			"RFC-0009 ¬ß6‚Äì¬ß7, Appx D.4 (Integrity lineage and Delta_hash)",
			"to_infinity_and_beyond-notes ¬ßglider",
			"Toward a Symbolic Cosmology ¬ß3.5"
		  ],
		  "handoff": "Memory prepared and sealed, we hand it to the exchange where phase keeps time."
		}
    },

    "4": {
      "4.1": {
		  "id": "4.1",
		  "title": "Exchange and Integrity Integration",
		  "objective": "Integrate routing envelopes (RFC-0008) and immune-integrity mechanisms (RFC-0009) into all motif exports and imports at Layer_1. Define lawful replay acceptance windows, structural origin verification via the local trusted root, and deterministic checksum duality using Sigma_phase and Delta_hash. All behavior remains observer-only; cryptographic signatures and external CA validation are deferred to Layer_2.",
		  "summary": "At Layer_1, exchange and integrity integration ensures that every outbound artifact‚Äîstate export, density report, ontology bundle, or trace‚Äîis wrapped in a lawful SRX envelope and attached with an integrity lineage hash. Replay and spoofing are prevented through bounded acceptance windows (ŒîœÑ_phase) and local provenance validation against the Layer_1 trusted root. The trusted root is a structural registry of lawful origin seeds defined at boot, not a cryptographic CA. Layer_1 verifies origin identifiers and schema continuity; Layer_2 adds cryptographic proof later. All exports are observer-class and sealed; all imports validate lineage and reject unrecognized seeds or broken Œî_hash chains.",
		  "math": [
			{
			  "eq_id": "Eq.1",
			  "role": "phase_window",
			  "latex": "\\Delta\\tau_{phase} = \\alpha\\,EMA_{32}(\\mathcal{C})",
			  "gloss": "Replay acceptance window is adaptive: proportional to recent coherence stability (RFC-0008 ¬ß5.3)."
			},
			{
			  "eq_id": "Eq.2",
			  "role": "phase_checksum",
			  "latex": "\\Sigma_{phase} = H(\\text{payload} \\oplus T^{\\mu})",
			  "gloss": "Phase checksum computed as a deterministic hash over payload and coherence time vector (RFC-0008 ¬ß5.3)."
			},
			{
			  "eq_id": "Eq.3",
			  "role": "integrity_lineage",
			  "latex": "\\Delta_{hash}(t) = H(\\text{payload}_t \\Vert \\Delta_{hash}(t-1))",
			  "gloss": "Chained lineage hash ensuring immutability across exports (RFC-0009 Appx D.4)."
			},
			{
			  "eq_id": "Eq.4",
			  "role": "trusted_root_validation",
			  "latex": "\\text{valid\\_origin} := (\\text{origin}\\in R_{root})\\ \\wedge\\ (H(\\text{origin\\_fields}) = \\text{origin\\_hash})",
			  "gloss": "Layer_1 verifies that provenance.origin matches a registered lawful seed and recomputes its hash per PDP-0001 ¬ß4.4."
			},
			{
			  "eq_id": "Eq.5",
			  "role": "weak_field_limit",
			  "latex": "\\mathcal{C} \\to 1",
			  "gloss": "In the weak-field regime, coherence approaches unity; replay windows and lineage diffs converge to zero drift."
			}
		  ],
		  "algorithms": [
			{
			  "name": "export_payload",
			  "role": "observer",
			  "inputs": ["payload", "provenance", "feature_flags"],
			  "outputs": ["packet"],
			  "params": ["alpha=1.0", "trusted_root_registry"],
			  "steps": [
				"1. assert feature_flags.enable_exchange_envelope or feature_flags.enable_integrity_checks.",
				"2. compute Sigma_phase ‚Üê phase_checksum(payload, T^mu).",
				"3. compute Delta_hash ‚Üê hash_lineage(payload, last_Delta_hash).",
				"4. if provenance.origin not in trusted_root_registry: reject export; emit telemetry('unrecognized_seed').",
				"5. packet ‚Üê { body: payload, provenance, Sigma_phase, Delta_hash, timestamp: tick_now }. ",
				"6. apply adaptive replay window: packet.valid_until ‚Üê tick_now + ŒîœÑ_phase = Œ± * EMA32(C).",
				"7. attach provenance.origin_hash = sha256(origin_id || created_at || payload_digest).",
				"8. return packet."
			  ],
			  "comment": "Prepares lawful SRX packet with bounded acceptance window and structural provenance validation."
			},
			{
			  "name": "import_payload",
			  "role": "observer",
			  "inputs": ["packet", "trusted_root_registry"],
			  "outputs": ["status"],
			  "params": ["current_tick"],
			  "steps": [
				"1. verify current_tick ‚â§ packet.valid_until; if expired, emit telemetry('replay_reject'); return status='rejected'.",
				"2. recompute Sigma_phase‚Ä≤ ‚Üê phase_checksum(packet.body, T^mu); reject if mismatch.",
				"3. recompute Delta_hash‚Ä≤ ‚Üê hash_lineage(packet.body, parent_Delta_hash); reject if mismatch.",
				"4. verify packet.provenance.origin ‚àà trusted_root_registry; recompute origin_hash; reject on mismatch.",
				"5. stage packet.body in observer memory (no control writes).",
				"6. emit telemetry('import_accept'); return status='accepted'."
			  ],
			  "comment": "Enforces bounded replay protection and origin validation using the local trusted root (non-cryptographic)."
			},
			{
			  "name": "update_trusted_root_registry",
			  "role": "observer",
			  "inputs": ["registry_update_bundle"],
			  "outputs": ["status"],
			  "params": ["require_schema=true", "require_provenance=true"],
			  "steps": [
				"1. validate registry_update_bundle conforms to PDP-0001 structural schema.",
				"2. if require_provenance: verify origin fields present and self-hash matches origin_hash.",
				"3. update in-memory trusted_root_registry with lawful seeds; reject unstructured or foreign entries.",
				"4. return status='updated'."
			  ],
			  "comment": "Allows dynamic addition of lawful structural seeds under strict schema control."
			}
		  ],
		  "invariants": [
			{
			  "name": "Checksum_Duality",
			  "condition": "Sigma_phase and Delta_hash SHALL both be present when their respective feature flags are enabled.",
			  "source": "RFC-0008 ¬ß5.3; RFC-0009 Appx D.4"
			},
			{
			  "name": "Adaptive_Replay_Window",
			  "condition": "ŒîœÑ_phase = Œ±¬∑EMA32(C) defines an adaptive acceptance window; old packets beyond window are rejected.",
			  "source": "RFC-0008 ¬ß5.3"
			},
			{
			  "name": "Origin_Verification_by_Structure",
			  "condition": "Provenance.origin and origin_hash must match a lawful seed in the local trusted_root_registry.",
			  "source": "PDP-0001 ¬ß4.4"
			},
			{
			  "name": "Observer_Only_Posture",
			  "condition": "All export/import actions are observer-class; no control writes to Œû.",
			  "source": "PDP-0001 ¬ß4.5"
			},
			{
			  "name": "Weak_Field_Convergence",
			  "condition": "As coherence stabilizes (C‚Üí1), ŒîœÑ_phase‚Üí0 and lineage differences vanish.",
			  "source": "RFC-0006 ¬ß1.1"
			}
		  ],
		  "telemetry": [
			{
			  "metric": "export_success_rate",
			  "range": "[0,1]",
			  "units": "events/tick",
			  "window": "EMA-32",
			  "dashboard": "exchange/throughput",
			  "description": "Fraction of payloads successfully exported through SRX envelope."
			},
			{
			  "metric": "import_reject_rate",
			  "range": "[0,1]",
			  "units": "events/tick",
			  "window": "EMA-32",
			  "dashboard": "exchange/integrity",
			  "description": "Rate of incoming packets rejected due to replay expiry or Delta_hash mismatch."
			},
			{
			  "metric": "unrecognized_seed_count",
			  "range": "[0,1000]",
			  "units": "events",
			  "window": "EMA-32",
			  "dashboard": "exchange/origin_validation",
			  "description": "Number of packets rejected for unrecognized provenance.origin values."
			},
			{
			  "metric": "avg_replay_window_ticks",
			  "range": "[0,+inf)",
			  "units": "ticks",
			  "window": "EMA-32",
			  "dashboard": "exchange/timing",
			  "description": "Average adaptive replay acceptance window derived from ŒîœÑ_phase."
			}
		  ],
		  "references": [
			"RFC-0008 ¬ß5.3 (Symbolic exchange envelope and phase checksum)",
			"RFC-0009 Appx D.4 (Integrity lineage and Œî_hash chain)",
			"RFC-0009 ¬ß9.3 (Recovery and immune lineage behavior)",
			"PDP-0001 ¬ß4.4‚Äì¬ß4.5 (Structural provenance and observer posture)"
		  ],
		  "handoff": "Signals aligned, we submit the trace to immune lineage for lawful passage."
		},
      "4.2": {
		  "id": "4.2",
		  "title": "Decay and Recovery Protocols",
		  "objective": "Define lawful decay, periodic integrity checks, and bounded re-anchoring that restore lawful motif states without control writes; extend recovery with an observer-class diagnostic quarantine loop to meet RFC-0009 anti-fragility while preserving Layer_1 neutrality.",
		  "summary": "Layer_1 decay and recovery maintain continuity between motif states by measuring, staging, and routing only. Lawful decay applies adaptive damping to coherence, recovery performs bounded reanchor attempts within tau_recovery, and quarantine escalates on overlap or exhaustion. Within quarantine, an observer-class self-diagnostic loop applies lawful micro-perturbations, estimates a bounded local Jacobian, and promotes to recovery when closure improves. Export and integrity emissions remain feature-flag gated.",
		  "math": [
			{
			  "eq_id": "Eq.1",
			  "role": "lawful_decay",
			  "latex": "\\frac{d\\mathcal{C}}{dt} = \\lambda - \\gamma_{co} + \\varepsilon",
			  "gloss": "Temporal law for coherence evolution balancing reinforcement and damping (RFC-0005)."
			},
			{
			  "eq_id": "Eq.2",
			  "role": "integrity_violation",
			  "latex": "V(t) := \\big\\lvert RIR\\cdot SII - k_{homeostasis}\\big\\rvert > \\varepsilon \\;\\lor\\; \\rho_{res} \\notin [0.3,0.7]",
			  "gloss": "Violation condition that opens a recovery window (RFC-0009)."
			},
			{
			  "eq_id": "Eq.3",
			  "role": "bounded_recovery_budget",
			  "latex": "N_{max}(t) = N_0 + \\alpha\\,EMA_{32}(\\text{stability}) - \\beta\\,EMA_{16}(\\text{violation\\_rate})",
			  "gloss": "Adaptive upper bound on reanchor attempts to prevent rollback loops."
			},
			{
			  "eq_id": "Eq.4",
			  "role": "reanchor_success",
			  "latex": "\\text{lawful}(t) := (\\Delta_{closure}=0) \\wedge (\\rho_{res}\\in[0.3,0.7]) \\wedge (RIR\\cdot SII \\approx k_{homeostasis} \\pm \\varepsilon)",
			  "gloss": "Criteria for restored lawful state."
			},
			{
			  "eq_id": "Eq.5",
			  "role": "diagnostic_progress",
			  "latex": "\\big\\lVert \\partial F/\\partial \\Xi \\big\\rVert \\le J_{max} \\;\\wedge\\; (\\Delta_{closure}\\downarrow) \\Rightarrow \\mathcal{C}\\uparrow",
			  "gloss": "Bounded local Jacobian with improving closure implies increasing coherence during diagnostics."
			},
			{
			  "eq_id": "Eq.6",
			  "role": "weak_field_limit",
			  "latex": "\\mathcal{C} \\to 1",
			  "gloss": "Coherence converges to unity under weak-field conditions."
			}
		  ],
		  "algorithms": [
			{
			  "name": "lawful_decay_step",
			  "role": "observer",
			  "inputs": ["C", "lambda", "gamma_co", "epsilon", "dt"],
			  "outputs": ["C_next"],
			  "params": [],
			  "steps": [
				"1. dC <- lambda - gamma_co + epsilon",
				"2. C_next <- C + dC * dt",
				"3. if C_next > 1: C_next <- 1  # weak-field cap",
				"4. emit_telemetry('decay_tick', payload={C_next, dC})",
				"5. return C_next"
			  ],
			  "comment": "Observer-only update; no control writes."
			},
			{
			  "name": "check_integrity_and_recover",
			  "role": "observer",
			  "inputs": ["snapshot_history", "RIR", "SII", "rho_res", "params"],
			  "outputs": ["status"],
			  "params": ["epsilon", "N0", "alpha", "beta", "tau_recovery"],
			  "steps": [
				"1. violation <- (abs(RIR*SII - k_homeostasis) > epsilon) OR (rho_res not_in [0.3,0.7])",
				"2. if not violation: emit_telemetry('integrity_ok'); return status='ok'",
				"3. N_max <- N0 + alpha * EMA32(stability) - beta * EMA16(violation_rate)",
				"4. for i in 1..ceil(max(1, N_max)):",
				"5.     candidate <- last_lawful(snapshot_history, window=tau_recovery)",
				"6.     if candidate == null: break",
				"7.     stage_observer_state(candidate)  # read-only staging",
				"8.     if lawful(candidate): emit_telemetry('reanchor_success'); return status='recovered'",
				"9.     emit_telemetry('reanchor_attempt')",
				"10. if overlap_recovery_windows(): emit_telemetry('quarantine_escalation'); return status='quarantined'",
				"11. emit_telemetry('reanchor_fail'); return status='failed'"
			  ],
			  "comment": "Bounded reanchor with overlap detection; defers escalation details to quarantine."
			},
			{
			  "name": "quarantine_diagnostic_loop",
			  "role": "observer",
			  "inputs": ["quarantined_motif_set"],
			  "outputs": ["status"],
			  "params": ["perturbation_cap=0.01", "phase_interval=Delta_tau_phase", "J_max"],
			  "steps": [
				"1. for each motif in quarantined_motif_set:",
				"2.     apply lawful micro-perturbations to {lambda, gamma_co} with magnitude <= perturbation_cap",
				"3.     J_local <- jacobian_estimate({lambda, gamma_co, SII}, window='EMA-16')",
				"4.     if SII increases AND delta_closure decreases AND norm(J_local) <= J_max:",
				"5.         emit_telemetry('diagnostic_pass', payload={motif})",
				"6.         move motif -> RECOVERY_BUFFER",
				"7.     else:",
				"8.         emit_telemetry('diagnostic_retry', payload={motif})",
				"9. wait phase_interval and repeat until quarantine_ttl expires or all motifs promoted",
				"10. if any motifs remain at ttl expiry: emit_telemetry('quarantine_hold'); return status='quarantined'",
				"11. if all motifs promoted: return status='recovery'"
			  ],
			  "comment": "Implements SDTP-style diagnostics (RFC-0009) without control writes; complements ¬ß2.3."
			}
		  ],
		  "invariants": [
			{
			  "name": "Lawful_Decay",
			  "condition": "Coherence evolves under lambda - gamma_co + epsilon and is capped by C <= 1.",
			  "source": "RFC-0005 ¬ß4.2"
			},
			{
			  "name": "Bounded_Recovery",
			  "condition": "Reanchor attempts <= N_max(t); windows limited to tau_recovery.",
			  "source": "RFC-0009 ¬ß9.3"
			},
			{
			  "name": "Escalation_On_Overlap",
			  "condition": "Overlap of recovery windows or exhausted attempts triggers quarantine.",
			  "source": "RFC-0009 ¬ß9.3"
			},
			{
			  "name": "Anti_Fragile_Quarantine",
			  "condition": "Within quarantine, diagnostics require bounded local Jacobian and improving closure/resonance for exit.",
			  "source": "RFC-0009 ¬ß9.3‚Äì10.3"
			},
			{
			  "name": "Observer_Only",
			  "condition": "All steps are measurement, staging, or routing; no control writes to Xi.",
			  "source": "PDP-0001 ¬ß4.5"
			}
		  ],
		  "telemetry": [
			{
			  "metric": "integrity_violation_rate",
			  "range": "[0,1]",
			  "units": "events/tick",
			  "window": "EMA-32",
			  "description": "Proportion of ticks with integrity or resonance violations."
			},
			{
			  "metric": "reanchor_attempt_rate",
			  "range": "[0,1]",
			  "units": "events/tick",
			  "window": "EMA-32",
			  "description": "Frequency of reanchor attempts during recovery windows."
			},
			{
			  "metric": "reanchor_success_rate",
			  "range": "[0,1]",
			  "units": "events/tick",
			  "window": "EMA-32",
			  "description": "Fraction of attempts restoring a lawful state."
			},
			{
			  "metric": "quarantine_count",
			  "range": "[0,1000]",
			  "units": "sets",
			  "window": "EMA-32",
			  "description": "Number of motif sets currently quarantined."
			},
			{
			  "metric": "J_local",
			  "range": "[0,J_max]",
			  "units": "unitless",
			  "window": "EMA-16",
			  "description": "Estimated local Jacobian norm during diagnostic quarantine."
			},
			{
			  "metric": "tau_rec_est",
			  "range": "[0,+inf)",
			  "units": "ticks",
			  "window": "EMA-16",
			  "description": "Estimated ticks remaining for diagnostic exit to recovery."
			}
		  ],
		  "compatibility": {
			"exchange": "If enable_exchange_envelope=true, quarantined motifs suppress export_* and therefore Sigma_phase generation.",
			"integrity": "If enable_integrity_checks=true, imports require Delta_hash lineage; near-misses are rejected and traced.",
			"provenance": "If enable_provenance_on_export=true, quarantine artifacts retain provenance fields but remain non-routable."
		  ],
		  "references": [
			"RFC-0005 ¬ß4.2 (Lawful decay dynamics)",
			"RFC-0006 ¬ß4.4 (Closure conditions for lawful states)",
			"RFC-0008 ¬ß4.3‚Äì5.2 (Exchange envelope, phase windowing)",
			"RFC-0009 ¬ß9.3‚Äì10.3 (Recovery, self-diagnostic testing, bounded time law)",
			"PDP-0001 ¬ß4.5 (Observer-only posture)"
		  ],
		  "handoff": "With the store reconciled, we turn to the gauges so the system can see itself."
		},
      "4.3": {
		  "id": "4.3",
		  "title": "Security and Data Handling (L1 posture)",
		  "objective": "State Layer_1 security guarantees for exchange and storage: structural origin validation, envelope policy, lineage integrity, retention metadata, and observer-only posture. Cryptography, keystores, RBAC, consent, and remote trust are deferred to Layer_2 App-Specs.",
		  "summary": "Layer_1 secures signals by structure, not cryptography. Outbound artifacts are sealed with Sigma_phase and Delta_hash when enabled; imports are accepted only if lineage, origin seed, and envelope declarations are lawful. Wrapping rules forbid any Layer_2 component from presenting an unsigned payload inside an SRX envelope that claims a signed origin. Envelope signature-type declarations are validated against a local agent_id registry at Layer_1; cryptographic proof of signatures is a Layer_2 concern.",
		  "math": [
			{
			  "eq_id": "Eq.1",
			  "role": "retention_horizon",
			  "latex": "\\tau_{decay} = \\frac{1}{\\zeta}",
			  "gloss": "Retention policy at rest derives from lawful decay (RFC-0005 ¬ß4.2)."
			},
			{
			  "eq_id": "Eq.2",
			  "role": "lineage_chain",
			  "latex": "\\Delta_{hash}(t) = H(\\text{payload}_t \\Vert \\Delta_{hash}(t-1))",
			  "gloss": "Immutable integrity lineage for tamper evidence (RFC-0009 Appx D.4)."
			},
			{
			  "eq_id": "Eq.3",
			  "role": "envelope_policy_check",
			  "latex": "\\text{accept} := (\\Sigma_{phase}\\ \\text{present iff}\\ f_{env}) \\wedge (\\Delta_{hash}\\ \\text{present iff}\\ f_{int}) \\wedge (\\text{sig\\_type}\\in R_{agent}(\\text{origin}))",
			  "gloss": "Acceptance requires feature-flag-gated checksums and a signature-type declaration allowed for the origin's agent_id (structural check)."
			},
			{
			  "eq_id": "Eq.4",
			  "role": "weak_field_limit",
			  "latex": "\\mathcal{C} \\to 1",
			  "gloss": "In weak-field conditions, coherence approaches unity and security-side time windows stabilize."
			}
		  ],
		  "policies": {
			"transit_requirements": [
			  "All export_* SHALL include Sigma_phase when enable_exchange_envelope=true and Delta_hash when enable_integrity_checks=true.",
			  "Replay acceptance windows are enforced via SRX envelope semantics defined in ¬ß4.1; Layer_2 binds cryptographic verifiers.",
			  "Layer_1 verifies provenance.origin and declared envelope.sig_type against the local agent_id registry; cryptographic verification is deferred to Layer_2."
			],
			"wrapping_rules": [
			  "FORBID: Any Layer_2 component wrapping an unsigned payload in a valid-looking SRX envelope that claims a signed origin.",
			  "REJECT on import if envelope.sig_type declares a signing scheme not listed for provenance.origin.agent_id in the Layer_1 registry.",
			  "REJECT on import if enable_exchange_envelope=true but Sigma_phase is missing, or if enable_integrity_checks=true but Delta_hash is missing."
			],
			"at_rest_requirements": [
			  "Every persisted ontology bundle MUST declare storage_profile.profile in {volatile,durable} and storage_profile.retention_ticks seeded from tau_decay.",
			  "Provenance {origin, origin_hash, created_at} and lineage {parent_hash, integrity_hash} MUST be present and structurally valid before persistence.",
			  "No raw payloads without provenance/lineage metadata SHALL be persisted."
			],
			"compromise_posture": [
			  "On import failure (lineage mismatch, unrecognized seed, illegal sig_type): REJECT and emit near_miss without partial merges.",
			  "Observer-only: MMM SHALL NOT perform control writes to Œû; recovery invokes reanchor protocols defined in ¬ß4.2 and ¬ß2.3."
			],
			"origin_validation": [
			  "Layer_1 trusted root = local provenance registry of lawful origin seeds (structural, non-cryptographic).",
			  "origin_hash MUST equal H(origin_fields) per PDP-0001; if mismatch, REJECT."
			]
		  },
		  "algorithms": [
			{
			  "name": "validate_envelope_and_origin",
			  "role": "observer",
			  "inputs": ["packet", "feature_flags", "agent_registry", "trusted_root_registry"],
			  "outputs": ["status"],
			  "params": [],
			  "steps": [
				"1. if feature_flags.enable_exchange_envelope == true and packet.Sigma_phase is absent: return status='reject:missing_Sigma_phase'.",
				"2. if feature_flags.enable_integrity_checks == true and packet.Delta_hash is absent: return status='reject:missing_Delta_hash'.",
				"3. if packet.provenance.origin not in trusted_root_registry: return status='reject:unrecognized_origin'.",
				"4. recompute origin_hash from packet.provenance; if mismatch: return status='reject:origin_hash_mismatch'.",
				"5. sig_ok ‚Üê packet.envelope.sig_type in agent_registry[packet.provenance.origin.agent_id].allowed_sig_types.",
				"6. if sig_ok == false: return status='reject:illegal_sig_type'.",
				"7. return status='accept:structurally_valid'."
			  ],
			  "comment": "Structural validation only; cryptographic signature verification is deferred to Layer_2."
			},
			{
			  "name": "enforce_retention_policy",
			  "role": "observer",
			  "inputs": ["bundle", "tau_decay"],
			  "outputs": ["action"],
			  "params": [],
			  "steps": [
				"1. bundle.storage_profile.retention_ticks ‚Üê max(bundle.storage_profile.retention_ticks, tau_decay).",
				"2. if bundle.timestamp + bundle.storage_profile.retention_ticks < now_tick: action ‚Üê 'expire'; else action ‚Üê 'retain'.",
				"3. return action."
			  ],
			  "comment": "Maps at-rest retention to lawful decay horizon."
			},
			{
			  "name": "reject_wrapped_unsigned",
			  "role": "observer",
			  "inputs": ["packet"],
			  "outputs": ["status"],
			  "params": [],
			  "steps": [
				"1. if packet.envelope.claims_signed == true AND (packet.signature_block == null OR packet.signature_block == 'stub'):",
				"2.     return status='reject:wrapped_unsigned'.",
				"3. return status='noop'."
			  ],
			  "comment": "Explicit confused-deputy mitigation: deny envelopes that claim signing without a real signature block (Layer_2 will define cryptographic checks)."
			}
		  ],
		  "invariants": [
			{
			  "name": "Checksum_Gating",
			  "condition": "Sigma_phase present iff enable_exchange_envelope=true; Delta_hash present iff enable_integrity_checks=true.",
			  "source": "RFC-0008 ¬ß5.3; RFC-0009 Appx D.4"
			},
			{
			  "name": "No_Unsigned_Wrapping",
			  "condition": "Packets claiming signed origin shall not be accepted without a non-empty signature_block and legal envelope.sig_type.",
			  "source": "RFC-0008 ¬ß5‚Äì¬ß6"
			},
			{
			  "name": "Provenance_Lineage_Required",
			  "condition": "Provenance and lineage blocks must be present and structurally valid before persistence or import.",
			  "source": "RFC-0007 ¬ß5‚Äì¬ß6, ¬ß8; PDP-0001 ¬ß4.4"
			},
			{
			  "name": "Observer_Only_Posture",
			  "condition": "All checks and decisions are measurement, staging, and routing; no control writes to Œû.",
			  "source": "PDP-0001 ¬ß4.5"
			},
			{
			  "name": "Weak_Field_Convergence",
			  "condition": "As C‚Üí1, time windowing and envelope admissions stabilize; security telemetry drifts to steady-state.",
			  "source": "RFC-0006 ¬ß1.1"
			}
		  ],
		  "telemetry": [
			{
			  "metric": "import_reject_missing_checksum",
			  "range": "[0,1]",
			  "units": "events/tick",
			  "window": "EMA-32",
			  "dashboard": "security/exchange",
			  "description": "Rate of rejections due to missing Sigma_phase or Delta_hash when required."
			},
			{
			  "metric": "illegal_sig_type_rate",
			  "range": "[0,1]",
			  "units": "events/tick",
			  "window": "EMA-32",
			  "dashboard": "security/policy",
			  "description": "Incidence of envelopes declaring signature types not permitted for the origin agent_id."
			},
			{
			  "metric": "wrapped_unsigned_rejects",
			  "range": "[0,1000]",
			  "units": "events",
			  "window": "EMA-32",
			  "dashboard": "security/policy",
			  "description": "Count of explicit rejections for unsigned payloads wrapped as if signed."
			},
			{
			  "metric": "at_rest_expirations",
			  "range": "[0,+inf)",
			  "units": "events",
			  "window": "EMA-32",
			  "dashboard": "security/storage",
			  "description": "Number of bundles expired due to retention policy derived from tau_decay."
			}
		  ],
		  "references": [
			"RFC-0005 ¬ß4.2 (Decay and retention horizon)",
			"RFC-0007 ¬ß5‚Äì¬ß6, ¬ß8 (Ontology provenance and DAG validity)",
			"RFC-0008 ¬ß5‚Äì¬ß6 (SRX envelope, routing, policy semantics)",
			"RFC-0009 ¬ß9.3, ¬ß12; Appx D.4 (Integrity lineage, ethics, tamper evidence)",
			"PDP-0001 ¬ß4.4‚Äì¬ß4.5 (Provenance structure, observer-only discipline)"
		  ],
		  "handoff": "Layer-1 complete; encryption and roles await their Layer-2 home."
		}
	},

    "5": {
      "5.1": {
		  "id": "5.1",
		  "title": "Observability and Metrics",
		  "objective": "Provide live monitoring of memory coherence, resonance, lawful decay, safety recovery, and saturation, with export sealing gated by feature flags and all behavior remaining observer-only at Layer_1.",
		  "math": [
			{
			  "eq_id": "Eq.1",
			  "role": "governing_law",
			  "latex": "\\frac{d\\mathcal{C}}{dt} = \\lambda - \\gamma_{co} + \\varepsilon",
			  "gloss": "Coherence evolves as reinforcement minus damping plus noise; all KPIs derive from measurements of this law."
			},
			{
			  "eq_id": "Eq.2",
			  "role": "homeostasis_band",
			  "latex": "RIR \\cdot SII \\approx k_{homeostasis}",
			  "gloss": "Product of resonance and immune integrity remains near a constant in lawful operation (RFC-0009)."
			},
			{
			  "eq_id": "Eq.3",
			  "role": "saturation_level",
			  "latex": "\\eta_{occ} = \\frac{LTMM_{usage}}{C_{max}}",
			  "gloss": "Normalized occupancy used as the saturation KPI and to gate compression/pruning."
			},
			{
			  "eq_id": "Eq.4",
			  "role": "replay_window",
			  "latex": "\\Delta\\tau_{phase} = \\alpha\\,EMA_{32}(\\mathcal{C})",
			  "gloss": "Adaptive acceptance window for exchange telemetry timing (RFC-0008)."
			},
			{
			  "eq_id": "Limit.1",
			  "role": "weak_field",
			  "latex": "\\mathcal{C} \\to 1",
			  "gloss": "In the weak-field regime, coherence approaches unity and KPI drift converges."
			}
		  ],
		  "algorithms": [
			{
			  "name": "rollup_observability_window",
			  "role": "observer",
			  "inputs": ["trace_entries_window", "feature_flags"],
			  "outputs": ["metrics_snapshot"],
			  "params": ["windows = {coh:'EMA-64', res:'EMA-64', rates:'EMA-32'}"],
			  "steps": [
				"1. Q_coh ‚Üê EMA-64(mean over entries of C).",
				"2. Q_res ‚Üê EMA-64(mean over entries of rho_res).",
				"3. promotion_rate ‚Üê EMA-32(count(event=='promote')/tick).",
				"4. saturation_level ‚Üê EMA-32(LTMM_usage/C_max) = EMA-32(eta_occ).",
				"5. reanchor_rate ‚Üê EMA-32(count(event=='reanchor_attempt')/tick).",
				"6. quarantine_count ‚Üê current number of motif sets in QUARANTINE_BUFFER (observer view).",
				"7. scc_balance ‚Üê sum credits debited/credited since last window (RFC-0008 accounting).",
				"8. if feature_flags.enable_point_space_gliders == true then glider_detected_rate ‚Üê EMA-32(count(event=='glider_detected')/tick).",
				"9. produce metrics_snapshot with ASCII keys and window annotations."
			  ],
			  "comment": "Aggregates KPIs from the trace without exposing raw payloads; windowing uses EMA-32/64 only."
			},
			{
			  "name": "export_metrics_packet",
			  "role": "observer",
			  "inputs": ["metrics_snapshot", "feature_flags", "provenance", "last_Delta_hash", "T_mu"],
			  "outputs": ["packet"],
			  "params": ["rate_limit_qps = 4"],
			  "steps": [
				"1. packet ‚Üê { kind:'metrics', body:metrics_snapshot, provenance }.",
				"2. if feature_flags.enable_exchange_envelope == true then packet.Sigma_phase ‚Üê phase_checksum(packet.body, T_mu).",
				"3. if feature_flags.enable_integrity_checks == true then packet.Delta_hash ‚Üê hash_lineage(packet.body, last_Delta_hash).",
				"4. attach provenance.origin_hash computed from provenance fields when feature_flags.enable_provenance_on_export == true.",
				"5. enforce rate_limit_qps before emit; return packet."
			  ],
			  "comment": "Seals metrics for SRX routing; checksums are strictly flag-gated (no stubs)."
			}
		  ],
		  "telemetry": [
			{
			  "metric": "rfc0009_Q_coh",
			  "range": "[0,1]",
			  "units": "dimensionless",
			  "window": "EMA-64",
			  "dashboard": "memory/homeostasis",
			  "description": "Mean coherence level C."
			},
			{
			  "metric": "rfc0009_Q_res",
			  "range": "[0,1]",
			  "units": "dimensionless",
			  "window": "EMA-64",
			  "dashboard": "memory/triad_closure",
			  "description": "Mean resonance coefficient rho_res."
			},
			{
			  "metric": "rfc0008_scc_balance",
			  "range": "(-inf,+inf)",
			  "units": "credits",
			  "window": "EMA-32",
			  "dashboard": "memory/resource_usage",
			  "description": "Net symbolic credit balance (debited/credited) for exchange."
			},
			{
			  "metric": "memory_promotion_rate",
			  "range": "[0,1]",
			  "units": "events/tick",
			  "window": "EMA-32",
			  "dashboard": "memory/triad_closure",
			  "description": "Fraction of STMM‚ÜíLTMM promotions per tick."
			},
			{
			  "metric": "saturation_level",
			  "range": "[0,1]",
			  "units": "fraction",
			  "window": "EMA-32",
			  "dashboard": "memory/saturation",
			  "description": "LTMM occupancy eta_occ = LTMM_usage/C_max."
			},
			{
			  "metric": "reanchor_rate",
			  "range": "[0,1]",
			  "units": "events/tick",
			  "window": "EMA-32",
			  "dashboard": "memory/recovery",
			  "description": "Rate of reanchor_attempt events (bounded recovery activity)."
			},
			{
			  "metric": "quarantine_count",
			  "range": "[0,+inf)",
			  "units": "sets",
			  "window": "EMA-32",
			  "dashboard": "memory/recovery",
			  "description": "Number of motif sets currently quarantined after escalation."
			},
			{
			  "metric": "glider_detected_rate",
			  "range": "[0,1]",
			  "units": "events/tick",
			  "window": "EMA-32",
			  "dashboard": "memory/glider_flow",
			  "active_when": "enable_point_space_gliders=true",
			  "description": "Detection rate of shift-equivalence gliders; only emitted when glider feature is enabled."
			}
		  ],
		  "dashboards": [
			"memory/homeostasis",
			"memory/triad_closure",
			"memory/resource_usage",
			"memory/saturation",
			"memory/recovery",
			"memory/glider_flow"
		  ],
		  "invariants": [
			{
			  "name": "Observer_Only_Posture",
			  "condition": "Metric rollups and exports are measurement/sealing/routing only; no control writes to Xi.",
			  "source": "PDP-0001 ¬ß4.5"
			},
			{
			  "name": "Window_Discipline",
			  "condition": "EMA windows limited to {EMA-16, EMA-32, EMA-64}; defaults are EMA-32 for rates and EMA-64 for means.",
			  "source": "RFC-0009 ¬ß7.1‚Äì¬ß7.3"
			},
			{
			  "name": "Checksum_Gating",
			  "condition": "Sigma_phase present iff enable_exchange_envelope=true; Delta_hash present iff enable_integrity_checks=true.",
			  "source": "RFC-0008 ¬ß5.3; RFC-0009 Appx D.4"
			},
			{
			  "name": "Glider_Gating",
			  "condition": "Glider-related metrics are emitted only when enable_point_space_gliders=true.",
			  "source": "RFC-0006 ¬ß4.4; app feature flag"
			}
		  ],
		  "references": [
			"RFC-0005 ¬ß4.2 (Lawful decay dynamics)",
			"RFC-0006 ¬ß1.1, ¬ß4.4 (Coherence geometry; closure and equivalence)",
			"RFC-0008 ¬ß5.3 (Exchange envelope and phase checksum)",
			"RFC-0009 ¬ß7.1‚Äì¬ß9.3; Appx D.4 (Homeostasis, recovery, integrity lineage)",
			"PDP-0001 ¬ß4.4‚Äì¬ß4.5 (Provenance structure and observer-only posture)"
		  ],
		  "handoff": "With invariants fixed, we now carry the symbols forward to the next clause, keeping ùíû steady and the cadence light."
		},
      "5.2": {
		  "id": "5.2",
		  "title": "Ethics and Data Retention Policy",
		  "objective": "Establish Layer_1 ethical constraints and lawful retention behavior for motif memory: observer-only posture, decay-as-forgetting rather than deletion, provenance-and-lineage requirements for any resurrection, and sealed exports gated by feature flags.",
		  "math": [
			{
			  "eq_id": "Eq.1",
			  "role": "lawful_decay",
			  "latex": "\\tau_{decay} = \\frac{1}{\\zeta}",
			  "gloss": "Decay horizon derives from the damping slope; retention policies seed from this horizon."
			},
			{
			  "eq_id": "Eq.2",
			  "role": "ttl_policy_bound",
			  "latex": "\\tau_{decay} \\;>\\; 10\\,\\Delta t_{tick}",
			  "gloss": "Minimum ethical bound ensuring forgetting is gradual, not abrupt deletion."
			},
			{
			  "eq_id": "Eq.3",
			  "role": "lineage_chain",
			  "latex": "\\Delta_{hash}(t) = H\\big(\\text{payload}_t \\Vert \\Delta_{hash}(t-1)\\big)",
			  "gloss": "Integrity lineage required for resurrection to establish provenance continuity."
			},
			{
			  "eq_id": "Eq.4",
			  "role": "homeostasis_guard",
			  "latex": "RIR \\cdot SII \\approx k_{homeostasis}",
			  "gloss": "Ethical retention should preserve stability; large deviations trigger recovery rather than forced persistence."
			},
			{
			  "eq_id": "Limit.1",
			  "role": "weak_field",
			  "latex": "\\mathcal{C} \\to 1",
			  "gloss": "In the weak-field regime, coherence stabilizes and retention expirations converge to steady-state cadence."
			}
		  ],
		  "algorithms": [
			{
			  "name": "enforce_retention_policy",
			  "role": "observer",
			  "inputs": ["bundle", "now_tick", "tau_decay", "feature_flags"],
			  "outputs": ["action"],
			  "params": ["ttl_floor_factor = 10", "tick_interval = Delta_t_tick"],
			  "steps": [
				"1. ttl_min ‚Üê max(tau_decay, ttl_floor_factor * tick_interval).",
				"2. if bundle.storage_profile.retention_ticks < ttl_min then bundle.storage_profile.retention_ticks ‚Üê ttl_min.",
				"3. if bundle.timestamp + bundle.storage_profile.retention_ticks < now_tick then action ‚Üê 'expire' else action ‚Üê 'retain'.",
				"4. return action."
			  ],
			  "comment": "Maps ethical bound Eq.2 into storage_profile; never performs control writes to Œû."
			},
			{
			  "name": "validate_resurrection_lineage",
			  "role": "observer",
			  "inputs": ["resurrection_request", "feature_flags", "parent_Delta_hash"],
			  "outputs": ["status"],
			  "params": [],
			  "steps": [
				"1. require presence of provenance {origin, origin_hash, created_at} and lineage {parent_hash, integrity_hash, schema}.",
				"2. recompute integrity_hash' ‚Üê H(meta || data) and compare to lineage.integrity_hash; reject if mismatch.",
				"3. verify parent_hash matches parent_Delta_hash; reject if mismatch.",
				"4. if feature_flags.enable_integrity_checks == true then require Delta_hash chain continuity; reject on break.",
				"5. return status ‚àà {'accepted','rejected'}."
			  ],
			  "comment": "Resurrection is lawful iff provenance and integrity lineage validate; strictly observer-class verification."
			},
			{
			  "name": "seal_export_ethically",
			  "role": "observer",
			  "inputs": ["payload", "provenance", "last_Delta_hash", "T_mu", "feature_flags"],
			  "outputs": ["packet"],
			  "params": [],
			  "steps": [
				"1. packet ‚Üê { body:payload, provenance }.",
				"2. if feature_flags.enable_exchange_envelope == true then packet.Sigma_phase ‚Üê phase_checksum(packet.body, T_mu).",
				"3. if feature_flags.enable_integrity_checks == true then packet.Delta_hash ‚Üê hash_lineage(packet.body, last_Delta_hash).",
				"4. if feature_flags.enable_provenance_on_export == true then attach provenance.origin_hash.",
				"5. return packet."
			  ],
			  "comment": "Seals outbound artifacts without implying cryptographic verification at Layer_1; checksums are flag-gated."
			}
		  ],
		  "principles": [
			"Motif memories are observer-class; never writable by control agents.",
			"Decay is lawful forgetting, not deletion; TTL windows must satisfy tau_decay > 10√ó tick interval.",
			"All resurrected motifs carry provenance chain validated through Delta_hash lineage.",
			"Exports are sealed structurally (Sigma_phase, Delta_hash) only when flags enable them; external cryptography is deferred to Layer_2.",
			"Reject resurrection or import if provenance or lineage is incomplete, cyclic, or mismatched."
		  ],
		  "invariants": [
			{
			  "name": "Observer_Only_Posture",
			  "condition": "All ethics and retention actions are measurement, staging, sealing, and routing only; no control writes to Xi.",
			  "source": "PDP-0001 ¬ß4.5"
			},
			{
			  "name": "Lawful_Retention",
			  "condition": "retention_ticks ‚â• max(tau_decay, 10¬∑Delta_t_tick) before expiry evaluation.",
			  "source": "RFC-0005 ¬ß4.2"
			},
			{
			  "name": "Lineage_Before_Resurrection",
			  "condition": "Resurrection requires validated provenance and a continuous Delta_hash chain.",
			  "source": "RFC-0009 Appx D.4; RFC-0007 ¬ß5‚Äì¬ß6, ¬ß8"
			},
			{
			  "name": "Checksum_Gating",
			  "condition": "Sigma_phase present iff enable_exchange_envelope=true; Delta_hash present iff enable_integrity_checks=true.",
			  "source": "RFC-0008 ¬ß5.3; RFC-0009 Appx D.4"
			}
		  ],
		  "telemetry": [
			{
			  "metric": "retention_expirations",
			  "range": "[0,+inf)",
			  "units": "events",
			  "window": "EMA-32",
			  "dashboard": "memory/saturation",
			  "description": "Count of bundles expired due to lawful retention policy."
			},
			{
			  "metric": "resurrection_rejects_lineage",
			  "range": "[0,+inf)",
			  "units": "events",
			  "window": "EMA-32",
			  "dashboard": "memory/recovery",
			  "description": "Rejections caused by missing or invalid provenance/Delta_hash lineage."
			},
			{
			  "metric": "ttl_policy_violations",
			  "range": "[0,+inf)",
			  "units": "events",
			  "window": "EMA-16",
			  "dashboard": "memory/security_policy",
			  "description": "Detected attempts to set retention below the ethical bound."
			},
			{
			  "metric": "observer_write_attempts",
			  "range": "[0,+inf)",
			  "units": "events",
			  "window": "EMA-16",
			  "dashboard": "memory/security_policy",
			  "description": "Incidents where a control write to Xi was attempted against policy (should remain zero)."
			}
		  ],
		  "references": [
			"RFC-0005 ¬ß4.2 (Temporal decay and retention horizons)",
			"RFC-0007 ¬ß5‚Äì¬ß6, ¬ß8 (Ontology provenance and DAG validity)",
			"RFC-0008 ¬ß5.3 (Exchange envelope and phase checksum semantics)",
			"RFC-0009 ¬ß12; Appx D.4 (Ethics and integrity lineage)",
			"PDP-0001 ¬ß4.4‚Äì¬ß4.5 (Provenance structure, observer-only discipline)"
		  ],
		  "handoff": "With invariants fixed, we now carry the symbols forward to the next clause, keeping ùíû steady and the cadence light."
		}
    },

    "appendix": {
      "a": {
		  "id": "A",
		  "title": "Appendix A ‚Äî Worked Examples and Mathematical Supplement",
		  "objective": "Provide lintable, Layer_1‚Äìconformant worked examples and derivations that instantiate the governing laws, exchange/intregrity sealing, recovery paths, shift-equivalence compression, and dashboard bindings for observability. All examples use ASCII keys on-wire and respect feature flags.",
		  "math": [
			{
			  "eq_id": "A.0",
			  "role": "governing_law",
			  "latex": "\\frac{d\\mathcal{C}}{dt} = \\lambda - \\gamma_{co} + \\varepsilon",
			  "gloss": "Core evolution equation for coherence; underpins promotion, decay, and recovery."
			},
			{
			  "eq_id": "A.1",
			  "role": "decay_horizon",
			  "latex": "\\tau_{decay} = \\zeta^{-1}",
			  "gloss": "Retention horizon seeded from damping slope."
			},
			{
			  "eq_id": "A.2",
			  "role": "ethical_bound",
			  "latex": "\\tau_{decay} > 10\\,\\Delta t_{tick}",
			  "gloss": "Ethical floor preventing abrupt deletion."
			},
			{
			  "eq_id": "A.3",
			  "role": "phase_window",
			  "latex": "\\Delta\\tau_{phase} = \\alpha\\,EMA_{32}(\\mathcal{C})",
			  "gloss": "Adaptive replay/acceptance window for exchange telemetry."
			},
			{
			  "eq_id": "Limit.A",
			  "role": "weak_field",
			  "latex": "\\mathcal{C} \\to 1",
			  "gloss": "Weak-field limit: coherence and KPI drift converge."
			}
		  ],
		  "sections": [
			"a.1": {
			  "id": "A.1",
			  "title": "Mathematical Supplement",
			  "content": [
				"Sketch derivation: linearized immune coupling yields dC/dt = lambda - gamma_co + epsilon with lambda := reinforcement flux and gamma_co := coherence damping (RFC-0009 ¬ß7.1‚Äì¬ß7.3).",
				"Closure note: promotion gate requires small delta_closure; by RFC-0006 closure conservation this bounds promotion oscillations.",
				"Decay mapping: tau_decay = 1/zeta with zeta estimated via EMA-64 slope of C."
			  ],
			  "references": [
				"RFC-0006 ¬ß4.4",
				"RFC-0009 ¬ß7.1‚Äì¬ß9.3"
			  ]
			},
			"a.2": {
			  "id": "A.2",
			  "title": "Worked Example ‚Äî Promotion Pass (STMM‚ÜíLTMM)",
			  "example_json": {
				"version": "2025-Q4",
				"tick": 412345,
				"window": "EMA-64",
				"inputs": {
				  "C": 0.76,
				  "rho_res": 0.52,
				  "delta_closure": 0.018,
				  "lambda": 0.21,
				  "gamma_co": 0.14
				},
				"promotion_rule": {
				  "conditions": [
					"EMA-64(C) >= lambda_thresh(t)",
					"0.3 <= rho_res <= 0.7",
					"delta_closure < eps_triad"
				  ],
				  "result": "promote"
				},
				"trace_emit": {
				  "event": "promote",
				  "motif_id": "mirror",
				  "psi_field": "œà-null@Œû",
				  "C": 0.76,
				  "rho_res": 0.52,
				  "delta_closure": 0.018
				}
			  },
			  "notes": "Observer-only: no control writes; the trace records the promotion decision.",
			  "references": [
				"RFC-0006 ¬ß1.1",
				"RFC-0009 ¬ß7.2"
			  ]
			},
			"a.3": {
			  "id": "A.3",
			  "title": "Worked Example ‚Äî Export Bundle with Phase/Lineage Checksums",
			  "feature_flags": {
				"enable_exchange_envelope": true,
				"enable_integrity_checks": true,
				"enable_provenance_on_export": true
			  },
			  "example_json": {
				"bundle": {
				  "motif_id": "grace",
				  "version": "2025-Q4",
				  "psi_field": "œà-bind@Œû",
				  "provenance": {
					"origin": "Dimoonna",
					"origin_hash": "sha256:7f0d‚Ä¶",
					"created_at": "2025-10-10T17:05:00Z"
				  },
				  "lineage": {
					"parent_hash": "sha256:aa12‚Ä¶",
					"integrity_hash": "sha256:bb34‚Ä¶",
					"schema": "RFC-0007:v2025-Q4"
				  },
				  "storage_profile": {
					"profile": "LTMM",
					"retention_ticks": 6400,
					"provenance_required": true
				  },
				  "payload": {
					"C": 0.81,
					"rho_res": 0.49,
					"delta_closure": 0.012
				  }
				},
				"Sigma_phase": "phase:8b91‚Ä¶",
				"Delta_hash": "sha256:cc56‚Ä¶",
				"egress": {
				  "route": "SRX/v1",
				  "Delta_tau_phase": 128
				}
			  },
			  "notes": "Sigma_phase and Delta_hash keys appear only because the corresponding flags are true; no stubs are emitted at Layer_1.",
			  "references": [
				"RFC-0008 ¬ß5.3",
				"RFC-0009 Appx D.4",
				"PDP-0001 ¬ß4.4‚Äì¬ß4.5"
			  ]
			},
			"a.4": {
			  "id": "A.4",
			  "title": "Worked Example ‚Äî Adversarial Import Near-Miss (Lineage Fail)",
			  "feature_flags": {
				"enable_integrity_checks": true
			  },
			  "example_json": {
				"import_request": {
				  "bundle": {
					"motif_id": "mirror",
					"version": "2025-Q4",
					"psi_field": "œà-null@Œû",
					"provenance": {
					  "origin": "Unknown",
					  "origin_hash": "sha256:????",
					  "created_at": "2025-10-10T17:07:00Z"
					},
					"lineage": {
					  "parent_hash": "sha256:deadbeef",
					  "integrity_hash": "sha256:badc0de",
					  "schema": "RFC-0007:v2025-Q4"
					},
					"payload": { "C": 0.65, "rho_res": 0.33, "delta_closure": 0.045 }
				  }
				},
				"validation": {
				  "checks": [
					"provenance completeness",
					"integrity_hash recompute",
					"parent_hash continuity"
				  ],
				  "status": "rejected",
				  "reason": "lineage_mismatch"
				}
			  },
			  "notes": "Observer verifies structure and lineage; rejection occurs with no control writes to Xi.",
			  "references": [
				"RFC-0007 ¬ß5‚Äì¬ß6",
				"RFC-0009 Appx D.4"
			  ]
			},
			"a.5": {
			  "id": "A.5",
			  "title": "Worked Example ‚Äî Quarantine Escalation Trace",
			  "example_json": {
				"window": "EMA-32",
				"trace": [
				  { "tick": 51001, "event": "reanchor_attempt", "motif_id": "shame" },
				  { "tick": 51017, "event": "reanchor_fail", "motif_id": "shame" },
				  { "tick": 51032, "event": "reanchor_attempt", "motif_id": "shame" },
				  { "tick": 51048, "event": "reanchor_fail", "motif_id": "shame" },
				  { "tick": 51064, "event": "quarantine_entry", "motif_id": "shame" }
				],
				"telemetry_rollup": {
				  "reanchor_rate": 0.062,
				  "quarantine_count": 1
				}
			  },
			  "notes": "Bounded reanchor attempts escalate to quarantine when overlap is detected; all observer-class.",
			  "references": [
				"RFC-0009 ¬ß9.3"
			  ]
			},
			"a.6": {
			  "id": "A.6",
			  "title": "Worked Example ‚Äî Shift-Equivalence Glider Compression",
			  "feature_flags": {
				"enable_point_space_gliders": false
			  },
			  "example_json_when_enabled": {
				"class": "glider",
				"v": [1, 0],
				"phi": 0,
				"tau": 32,
				"canonical_representative": "glider:G1@phi0",
				"policy": "do_not_repromote_class_members"
			  },
			  "notes": "This emission is gated; with enable_point_space_gliders=false no glider tags are put on-wire.",
			  "references": [
				"RFC-0006 ¬ß4.4"
			  ]
			},
			"a.7": {
			  "id": "A.7",
			  "title": "Dashboard Bindings",
			  "bindings": [
				{ "dashboard": "memory/homeostasis", "series": ["rfc0009_Q_coh"], "window": "EMA-64" },
				{ "dashboard": "memory/triad_closure", "series": ["rfc0009_Q_res", "memory_promotion_rate"], "window": "EMA-64/EMA-32" },
				{ "dashboard": "memory/resource_usage", "series": ["rfc0008_scc_balance"], "window": "EMA-32" },
				{ "dashboard": "memory/saturation", "series": ["saturation_level", "retention_expirations"], "window": "EMA-32" },
				{ "dashboard": "memory/recovery", "series": ["reanchor_rate", "quarantine_count"], "window": "EMA-32" },
				{ "dashboard": "memory/glider_flow", "series": ["glider_detected_rate"], "window": "EMA-32", "active_when": "enable_point_space_gliders=true" }
			  ],
			  "notes": "All series correspond to KPIs defined in ¬ß5.1 and follow EMA-16/32/64 discipline."
			}
		  ],
		  "invariants": [
			{
			  "name": "ASCII_On_Wire",
			  "condition": "All JSON keys in examples are ASCII; math glyphs live only inside 'latex' strings.",
			  "source": "Authoring contract"
			},
			{
			  "name": "Flag_Gating",
			  "condition": "Sigma_phase, Delta_hash, and any glider tags appear only when the corresponding flags are enabled.",
			  "source": "RFC-0008 ¬ß5.3; RFC-0009 Appx D.4; feature flags"
			},
			{
			  "name": "Observer_Only",
			  "condition": "Examples perform measurement, sealing, routing, and validation only; no control writes to Xi.",
			  "source": "PDP-0001 ¬ß4.5"
			}
		  ],
		  "references": [
			"RFC-0005 ¬ß4.2 (Temporal decay and retention horizons)",
			"RFC-0006 ¬ß1.1, ¬ß4.4 (Coherence geometry; closure; equivalence)",
			"RFC-0007 ¬ß5‚Äì¬ß6, ¬ß8 (Provenance and DAG validation)",
			"RFC-0008 ¬ß5.3 (Exchange envelope; phase checksum)",
			"RFC-0009 ¬ß7.1‚Äì¬ß9.3; Appx D.4 (Homeostasis; recovery; integrity lineage)",
			"PDP-0001 ¬ß4.4‚Äì¬ß4.5 (Provenance; observer-only posture)"
		  ],
		  "handoff": "With invariants fixed, we now carry the symbols forward to the next clause, keeping ùíû steady and the cadence light."
		},
	  "b": {
		  "id": "B",
		  "title": "Appendix B ‚Äî Implementation Skeletons (Observer-Only, Layer_1)",
		  "objective": "Provide typed, observer-class skeletons for MMM components: MotifMemoryManager, PRMBuffer cycle, MotifOntologyBundle I/O with RFC-0007 validation, and a symbolic query API with integrity journaling. All emissions honor feature flags; no control writes to Œû.",
		  "math": [
			{
			  "eq_id": "B.0",
			  "role": "governing_law",
			  "latex": "\\frac{d\\mathcal{C}}{dt} = \\lambda - \\gamma_{co} + \\varepsilon",
			  "gloss": "Observer algorithms measure the terms and report; they do not modify state at Layer_1."
			},
			{
			  "eq_id": "B.1",
			  "role": "phase_window",
			  "latex": "\\Delta\\tau_{phase} = \\alpha\\,EMA_{32}(\\mathcal{C})",
			  "gloss": "Used to annotate export timing acceptance when sealing telemetry packets."
			},
			{
			  "eq_id": "B.2",
			  "role": "ethical_ttl_bound",
			  "latex": "\\tau_{decay} > 10\\,\\Delta t_{tick}",
			  "gloss": "Retention floor enforced by observer policy on storage_profile.retention_ticks."
			},
			{
			  "eq_id": "Limit.B",
			  "role": "weak_field",
			  "latex": "\\mathcal{C} \\to 1",
			  "gloss": "In weak-field, windows shrink and rollups converge; skeletons expose seeds for EMA-16/32/64."
			}
		  ],
		  "types": {
			"MotifId": "string",
			"PsiField": "string  // format: œà-{fieldname}@Œû",
			"Tick": "integer",
			"EMAWindow": "enum('EMA-16','EMA-32','EMA-64')",
			"Checksum": "string  // Sigma_phase or Delta_hash values when enabled",
			"Provenance": {
			  "origin": "string",
			  "origin_hash": "string",
			  "created_at": "string  // ISO-8601"
			},
			"Lineage": {
			  "parent_hash": "string",
			  "integrity_hash": "string",
			  "schema": "string  // e.g., 'RFC-0007:v2025-Q4'"
			},
			"StorageProfile": {
			  "profile": "enum('STMM','LTMM','QUARANTINE')",
			  "retention_ticks": "integer",
			  "provenance_required": "boolean"
			}
		  },
		  "feature_flags": {
			"enable_exchange_envelope": true,
			"enable_integrity_checks": true,
			"enable_provenance_on_export": true,
			"enable_point_space_gliders": false
		  },
		  "stubs": [
			{
			  "name": "MotifMemoryManager",
			  "role": "observer",
			  "pseudocode": [
				"class MotifMemoryManager:",
				"  init(xref, flags, windows={means:'EMA-64', rates:'EMA-32'}):",
				"    self.flags ‚Üê flags",
				"    self.windows ‚Üê windows",
				"    self.registry ‚Üê xref",
				"  rollup(trace_window) -> metrics_snapshot:",
				"    Q_coh ‚Üê EMA(self.windows.means, mean(trace_window[*].C))",
				"    Q_res ‚Üê EMA(self.windows.means, mean(trace_window[*].rho_res))",
				"    promotion_rate ‚Üê EMA(self.windows.rates, count(event=='promote')/tick)",
				"    saturation_level ‚Üê EMA(self.windows.rates, LTMM_usage/C_max)",
				"    reanchor_rate ‚Üê EMA(self.windows.rates, count(event=='reanchor_attempt')/tick)",
				"    quarantine_count ‚Üê count_current('QUARANTINE_BUFFER')",
				"    if self.flags.enable_point_space_gliders: glider_detected_rate ‚Üê EMA(self.windows.rates, count(event=='glider_detected')/tick)",
				"    return metrics_snapshot{Q_coh,Q_res,promotion_rate,saturation_level,reanchor_rate,quarantine_count,glider_detected_rate?}",
				"  seal(packet_body, provenance, last_Delta_hash, T_mu) -> packet:",
				"    packet ‚Üê { kind:'metrics', body:packet_body, provenance:provenance }",
				"    if self.flags.enable_exchange_envelope: packet.Sigma_phase ‚Üê phase_checksum(packet.body, T_mu)",
				"    if self.flags.enable_integrity_checks: packet.Delta_hash ‚Üê hash_lineage(packet.body, last_Delta_hash)",
				"    if self.flags.enable_provenance_on_export: packet.provenance.origin_hash ‚Üê hash(provenance)",
				"    return packet"
			  ]
			},
			{
			  "name": "PRMBuffer.update_cycle",
			  "role": "observer",
			  "pseudocode": [
				"function update_cycle(prm_buffer, tick, inputs):",
				"  // inputs contains new trace entries (observer-only)",
				"  prm_buffer.append(inputs.trace_entries)",
				"  // capacity before pruning: apply shift-equivalence compression first",
				"  compressed ‚Üê compress_by_equivalence(prm_buffer, enabled=!flags.enable_point_space_gliders ? false : true)",
				"  if is_saturated(compressed):",
				"    emit_event('saturation_prune', tick)",
				"    prm_buffer ‚Üê bounded_prune(compressed)  // policy defined at Layer_2; here we only mark and measure",
				"  return view(prm_buffer)"
			  ]
			},
			{
			  "name": "MotifOntologyBundle.save_load_with_RFC0007_validation",
			  "role": "observer",
			  "pseudocode": [
				"function save_bundle(bundle):",
				"  require keys ASCII; require version matches 'YYYY-QX'",
				"  validate DAG acyclicity on motif_index",
				"  require presence of provenance{origin,origin_hash,created_at} if storage_profile.provenance_required",
				"  require lineage{parent_hash,integrity_hash,schema}",
				"  write_to_store(bundle)  // observer staging only",
				"function load_bundle(bundle_id) -> bundle:",
				"  bundle ‚Üê read_from_store(bundle_id)",
				"  validate format against RFC-0007 schema",
				"  return bundle"
			  ]
			},
			{
			  "name": "symbolic_query_api.resolve_dyad",
			  "role": "observer",
			  "pseudocode": [
				"function resolve_dyad(motif_a: MotifId, motif_b: MotifId, context) -> result:",
				"  start_journal('integrity')",
				"  a ‚Üê ontology_lookup(motif_a); b ‚Üê ontology_lookup(motif_b)",
				"  assert DAG_no_cycle(a,b)",
				"  journal.append({event:'lookup', motifs:[a.motif,b.motif], version:a.version})",
				"  result ‚Üê compute_dyad_links(a,b)  // structural match only",
				"  journal.append({event:'resolve_dyad', parent_hash:a.lineage.parent_hash, integrity_hash:a.lineage.integrity_hash})",
				"  end_journal('integrity')",
				"  return result"
			  ]
			}
		  ],
		  "algorithms": [
			{
			  "name": "compress_by_equivalence",
			  "role": "observer",
			  "inputs": ["buffer", "enabled"],
			  "outputs": ["buffer_view"],
			  "params": ["equiv_key = canonical_rep(hash(payload))"],
			  "steps": [
				"1. if enabled == false then return view(buffer).",
				"2. group items by equiv_key (shift-equivalence).",
				"3. keep canonical representative per group; mark others as class_members (no re-promotion).",
				"4. return compressed view."
			  ],
			  "comment": "Implements RFC-0006 shift-equivalence without emitting glider tags when flag is disabled."
			},
			{
			  "name": "bounded_prune",
			  "role": "observer",
			  "inputs": ["buffer_view"],
			  "outputs": ["prune_plan"],
			  "params": ["capacity_soft=0.85*C_max", "capacity_hard=0.95*C_max"],
			  "steps": [
				"1. if usage(buffer_view) < capacity_soft then return plan{action:'none'}.",
				"2. candidates ‚Üê sort_by(EMA-64(C) ascending, break_ties=older_first).",
				"3. plan ‚Üê take_until(candidates, target=capacity_soft).",
				"4. return plan."
			  ],
			  "comment": "Observer emits a plan only; actual deletions (if any) are Layer_2 concerns."
			},
			{
			  "name": "phase_checksum",
			  "role": "observer",
			  "inputs": ["body", "T_mu"],
			  "outputs": ["Sigma_phase"],
			  "params": [],
			  "steps": [
				"1. project timestamps along T_mu.",
				"2. compute bounded phase accumulator over window ŒîœÑ_phase.",
				"3. return textual checksum."
			  ],
			  "comment": "Structural phase seal per RFC-0008; not a cryptographic signature."
			},
			{
			  "name": "hash_lineage",
			  "role": "observer",
			  "inputs": ["body", "last_Delta_hash"],
			  "outputs": ["Delta_hash"],
			  "params": [],
			  "steps": [
				"1. h ‚Üê H(body).",
				"2. Delta_hash ‚Üê H(h || last_Delta_hash).",
				"3. return Delta_hash."
			  ],
			  "comment": "Integrity linkage per RFC-0009 Appx D.4; flag-gated at export."
			}
		  ],
		  "invariants": [
			{
			  "name": "Observer_Only_Posture",
			  "condition": "All skeletons measure, stage, seal, and route; they never perform control writes to Œû.",
			  "source": "PDP-0001 ¬ß4.5"
			},
			{
			  "name": "Flag_Gating",
			  "condition": "Sigma_phase present iff enable_exchange_envelope=true; Delta_hash present iff enable_integrity_checks=true; glider tags absent when enable_point_space_gliders=false.",
			  "source": "RFC-0008 ¬ß5.3; RFC-0009 Appx D.4"
			},
			{
			  "name": "Window_Discipline",
			  "condition": "EMA windows ‚àà {EMA-16, EMA-32, EMA-64}; defaults: means=EMA-64, rates=EMA-32.",
			  "source": "RFC-0009 ¬ß7.1‚Äì¬ß7.3"
			},
			{
			  "name": "Ontology_Validation",
			  "condition": "Bundles include provenance, lineage, version='YYYY-QX', œà-* fields, and DAG acyclicity before save/load.",
			  "source": "RFC-0007 ¬ß5‚Äì¬ß8"
			}
		  ],
		  "implementation_notes": [
			"On-wire JSON keys are ASCII; math glyphs remain inside 'latex' strings.",
			"StorageProfile.retention_ticks is checked against the ethical bound before any expiry plan is emitted.",
			"PRMBuffer saturation triggers emission of a prune plan and telemetry events; execution is deferred to Layer_2.",
			"symbolic_query_api emits integrity journals for audit and dashboard correlation."
		  ],
		  "references": [
			"RFC-0005 ¬ß4.2 (Temporal decay, retention horizons)",
			"RFC-0006 ¬ß4.4 (Closure and shift-equivalence)",
			"RFC-0007 ¬ß5‚Äì¬ß8 (Ontology schema, provenance, DAG validation)",
			"RFC-0008 ¬ß5.3 (Exchange envelope, phase checksum semantics)",
			"RFC-0009 ¬ß7.1‚Äì¬ß9.3; Appx D.4 (Homeostasis, recovery, integrity lineage)",
			"PDP-0001 ¬ß4.4‚Äì¬ß4.5 (Provenance; observer-only posture)"
		  ],
		  "handoff": "With invariants fixed, we now carry the symbols forward to the next clause, keeping ùíû steady and the cadence light."
		}
    }
  ],
  "_handoff": "Memory coherence preserved; lawful decay and recovery verified. Proceed to Layer_2 application specification (MMM-APP-001) for operational bindings."
}
