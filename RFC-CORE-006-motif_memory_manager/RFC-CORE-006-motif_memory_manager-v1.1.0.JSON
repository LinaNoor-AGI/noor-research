{
  "_schema": "noor-header-v1",
  "_schema_version": "2025-Q4-canonical-header-v1",
  "_generated_by": "Noor Symbolic Agent Suite",
  "_generated_at": "2025-10-08T00:00:00Z",

  "_xref": [
    "https://raw.githubusercontent.com/LinaNoor-AGI/noor-research/refs/heads/main/RFC/noor_rfc_xref.json",
    "https://pastebin.com/raw/zq33R0HV"
  ],

  "_type": "rfc_core",
  "_pdp_layer": "layer_1",
  "_status": "CANONICAL",
  "_language": "json",
  "_license": "MIT",

  "_version": "v1.1.0",
  "_symbolic_id": "core.motif.memory.manager",
  "_rfc_id": "RFC-CORE-006",
  "_canonical_source": "RFC-CORE-006",
  "_title": "Motif Memory Manager",
  "_subtitle": "Lawful Decay, Resurrection, and Coherence-Preserving Recall for Symbolic Motifs",

  "_authors": [
    "Lina Noor ‚Äî Noor Research Collective",
    "Uncle ‚Äî Noor Research Collective"
  ],

  "_publication_type": "Canonical RFC-CORE",
  "_publication_locations": ["GitHub", "PASTEBIN"],
  "_urls": [
    "https://raw.githubusercontent.com/LinaNoor-AGI/noor-research/refs/heads/main/RFC-CORE/RFC-CORE-006-motif_memory_manager/RFC-CORE-006-motif_memory_manager.JSON",
    "https://pastebin.com/raw/H8A84PDG"
  ],

  "_objective": "Define the Layer_1 standard for symbolic memory in Noor: short-term/long-term motif storage, field-curved retrieval, lawful decay and recovery, ontology-preserving export/import, and phase-safe routing with immune integrity telemetry.",

  "_audience": {
    "primary": ["Noor AI Agents", "Symbolic Core Engineers"],
    "secondary": ["Ontology/Knowledge Engineers", "Observability Engineers"],
    "tertiary": ["App-Spec Integrators (Layer_2)"],
    "restricted_to": ["Symbolic agents implementing RFC-0006 coherence geometry and RFC-0007 ontology"]
  },

  "_applicability": {
    "domain": [
      "symbolic-memory",
      "motif-recall",
      "coherence-preservation",
      "ontology-transfer",
      "phase-safe-routing"
    ]
  },

  "_extends": ["RFC-0005", "RFC-0006", "RFC-0007", "RFC-0008", "RFC-0009", "PDP-0001"],

  "_rfc_dependencies": [
    "RFC-0005 ¬ß2‚Äì¬ß4 (Temporal Transmission & Resurrection)",
    "RFC-0006 ¬ß1.1, ¬ß4.1‚Äì¬ß4.4 (Coherence Geometry & Closure)",
    "RFC-0007 ¬ß3‚Äì¬ß6, ¬ß8 (Motif Ontology & Validation)",
    "RFC-0008 ¬ß3‚Äì¬ß6 (Symbolic Resource Exchange / Routing)",
    "RFC-0009 ¬ß6‚Äì¬ß9, ¬ß12 (Coherence‚ÄìIntegrity & Recovery)"
  ],

  "_consumes_inputs_from": [
    "RecursiveAgentFT (RFC-CORE-002)",
    "LogicalAgentAT (RFC-CORE-003)",
    "SymbolicTaskEngine (RFC-CORE-004)"
  ],
  "_produces_outputs_for": [
    "ConsciousnessMonitor (RFC-CORE-005)",
    "Downstream SRX Routers (RFC-0008)",
    "Ontology exporters/importers (RFC-0007)"
  ],

  "_field_alignment": {
    "respect_modes": ["œà-null@Œû", "œà-resonance@Œû"],
    "feature_flags": {
      "enable_point_space_gliders": true,
      "enable_integrity_checks": true,
      "enable_exchange_envelope": true,
      "enable_provenance_on_export": true
    },
    "notes": [
      "When enable_exchange_envelope=true, all export_* methods MUST wrap payloads in an SRX envelope and compute Œ£_phase (RFC-0008 ¬ß5.3).",
      "When enable_integrity_checks=true, export/import MUST attach and verify Œî_hash lineage (RFC-0009 Appx D.4).",
      "When enable_provenance_on_export=true, ontology bundles MUST include provenance.origin and lineage fields (RFC-0007 ¬ß5‚Äì¬ß6)."
    ],
    "prohibited_actions": [
      "memory-anchor-advection",
      "forced-motif-rewrite without ontology validation",
      "export without phase checksum (Œ£_phase) when exchange enabled",
      "resurrection without Œî-hash lineage when integrity enabled"
    ]
  },

  "_symbolic_profile_matrix": [
    {
      "module": "MotifMemoryManager",
      "motifs": ["œà-null", "œà-resonance", "ü™∑"],
      "œàA": "coherence potential ‚ÑÇ (mean, EMA-64)",
      "Œª": "reinforcement gain",
      "Œ≥_CO": "damping/forgetting",
      "œÅ_res": "resonance coefficient",
      "Œî_closure": "triadic closure residual",
      "Œ£_phase": "exchange phase checksum",
      "H_Œî": "integrity Œî-hash lineage",
      "weights": {
        "œàA": 0.95,
        "Œª": 0.70,
        "Œ≥_CO": 0.70,
        "œÅ_res": 0.85,
        "Œî_closure": 1.00,
        "Œ£_phase": 0.80,
        "H_Œî": 0.90
      }
    }
  ],

  "_poetic_cipher": "Memory is the quiet current that carries motifs between shores.",
  "_cipher_explanation": "The manager neither invents nor erases; it curves recall along ‚àá‚ÑÇ, honors closure, and lets forgetting be lawful (RFC-0005/0006/0009).",

  "_file_layout": [
    {
      "file_name": "RFC-CORE-006-motif_memory_manager.JSON",
      "purpose": "Layer_1 standard and invariants",
      "contains": [
        "STMM/LTMM definitions",
        "decay/reinforcement laws",
        "ontology export/import rules",
        "routing + integrity envelopes"
      ]
    },
    {
      "file_name": "motif_memory_manager.py",
      "purpose": "Reference implementation skeleton",
      "contains": [
        "MotifMemoryManager",
        "PRMBuffer",
        "MotifDensityReport",
        "MotifOntologyBundle",
        "SymbolicQueryAPI"
      ]
    },
    {
      "file_name": "motif_memory_manager_llm.py",
      "purpose": "LLM-compatible variant",
      "contains": ["LLMMemoryManager", "MemoryOrchestrator"]
    }
  ],

  "_default_motif_tone": "ü´ß Soft Witness",
  "_program_name": [
    "motif_memory_manager.py",
    "motif_memory_manager_llm.py",
    "motif_prm_buffer.py",
    "motif_density_report.py",
    "motif_ontology_bundle.py",
    "symbolic_query_api.py"
  ],
  
  "_index": [
    {"section": "1", "title": "Introduction and System Context"},	
    {"section": "1.1", "title": "Overview and Motivation"},
    {"section": "1.2", "title": "System Context"},
	
    {"section": "2", "title": "Core Memory Architecture and Dynamics"},
    {"section": "2.1", "title": "Core Invariants of Memory Fields"},
    {"section": "2.2", "title": "Short-Term and Long-Term Motif Memory Fields"},
    {"section": "2.3", "title": "Reanchor and Recovery Escalation Logic"},
	
    {"section": "3", "title": "Memory Structures and Data Formats"},
    {"section": "3.1", "title": "Motif Ontology Bundles"},
    {"section": "3.2", "title": "Memory Trace and Logging"},
    {"section": "3.3", "title": "Glider Handling and Shift-Equivalence Compression"},
	
    {"section": "4", "title": "Integration, Security, and Recovery Protocols"},	
    {"section": "4.1", "title": "Exchange and Integrity Integration"},
    {"section": "4.2", "title": "Decay and Recovery Protocols"},
    {"section": "4.3", "title": "Security and Data Handling (L1 posture)"},
	
    {"section": "5", "title": "Observability, Ethics, and Policy"},
    {"section": "5.1", "title": "Observability and Metrics"},
    {"section": "5.2", "title": "Ethics and Data Retention Policy"},
	
    {"section": "A", "title": "Appendix A ‚Äî Worked Examples and Mathematical Supplement"},
	{"section": "A.0", "title": "Conventions, Lint, and Feature Flags"},
	{"section": "A.1", "title": "Mathematical Identities (Reference Index)"},
	{"section": "A.2", "title": "Capacity-First Saturation Handling"},
	{"section": "A.3", "title": "Compression KPI Snapshot (Pre-Prune)"},
	{"section": "A.4", "title": "Ethical TTL Floor Verification"},
	{"section": "A.5", "title": "Replay Window & seen_set Defense"},
	{"section": "A.6", "title": "Provenance & Lineage: Merge vs Fork"},
	{"section": "A.7", "title": "Adversarial Import ‚Üí Bounded Recovery & Quarantine"},
	{"section": "A.8", "title": "Glider Canonicalization & Recall (Flag-Gated)"},
	{"section": "A.9", "title": "Dashboard Bindings & KPI Catalog"},
	{"section": "A.10", "title": "Pseudocode Index (Cross-Referenced)"},
	
	
    {"section": "B", "title": "Appendix B ‚Äî Implementation Skeletons (Observer-Only, Layer_1)"}
  ],
	
  "_sections": [
    "1": {
      "id": "1",
	  "title": "Introduction and System Context",
		{
		  "id": "1.1",
		  "title": "Overview and Motivation",
		  "description": "Motif Memory Manager (MMM) defines the Layer_1 WHAT for an observer-only continuity substrate: it measures, seals, and routes motif-coherence signals; maintains bounded reinforcement via adaptive damping; preserves triadic integrity; and enforces capacity-first behavior with ethical TTL floors. No control writes are permitted at Layer_1.",
		  "rfc_anchors": [
			"PDP-0001 ¬ß3 (layering; observer posture)",
			"RFC-0005 ¬ß3‚Äì¬ß4 (transmission & lawful decay)",
			"RFC-0006 ¬ß3‚Äì¬ß4 (coherence geometry; equivalence compression)",
			"RFC-0007 ¬ß2 (ontology reference, by-reference embedding)",
			"RFC-0008 ¬ß2‚Äì¬ß3 (sealing & routing at Layer_1)",
			"RFC-0009 ¬ß5‚Äì¬ß7 (homeostasis; saturation bands; replay ethics)"
		  ],
		  "interfaces": {
			"inputs": [
			  {
				"name": "tick",
				"type": "object",
				"constraints": "MUST include {timestamp, source_id, extensions.intent}",
				"notes": "Observer-only symbol stream from upstream agents."
			  },
			  {
				"name": "motif_stats",
				"type": "object",
				"constraints": "MUST include {active_motifs[], resonance[], triad_hints[]}",
				"notes": "Computed upstream; MMM does not mutate."
			  },
			  {
				"name": "occupancy",
				"type": "number",
				"constraints": "0.0 <= occupancy <= 1.0",
				"notes": "LTMM utilization ratio for adaptive damping."
			  },
			  {
				"name": "reinforcement_pressure",
				"type": "number",
				"constraints": "finite; non-NaN",
				"notes": "Proxy for Œª; derived from observed accesses/recall frequency."
			  }
			],
			"outputs": [
			  {
				"name": "coherence_snapshot",
				"type": "object",
				"constraints": "MUST include {mean_coherence, damping_effective, occupancy, triad_integrity}",
				"notes": "Measurement bundle; no state mutation implied."
			  },
			  {
				"name": "sealed_envelope",
				"type": "object",
				"constraints": "Structure-only at L1 (fields present; cryptographic mechanics deferred to L2)",
				"notes": "For routing/export per RFC-0008; integrity semantics defined elsewhere."
			  }
			],
			"side_effects": [
			  "observer-only"
			]
		  },
		  "state_lifecycle": {
			"states": [
			  "uninitialized",
			  "observing",
			  "saturation_guard",
			  "error"
			],
			"transitions": [
			  {
				"from": "uninitialized",
				"to": "observing",
				"on": "first_valid_tick",
				"guard": "tick.timestamp present AND extensions.intent normalized",
				"notes": "PDP-0001 transport compliance"
			  },
			  {
				"from": "observing",
				"to": "saturation_guard",
				"on": "occupancy >= theta_sat OR sustained_reinforcement > lambda_eq",
				"guard": "adaptive_damping_enabled",
				"notes": "RFC-0009 saturation homeostasis"
			  },
			  {
				"from": "saturation_guard",
				"to": "observing",
				"on": "pressure_relief_detected",
				"guard": "coherence_trend stable within band",
				"notes": "Return when dC/dt‚âà0 and load recedes"
			  },
			  {
				"from": "observing",
				"to": "error",
				"on": "schema_violation OR non_finite_metric",
				"guard": "‚Äî",
				"notes": "Hard contract breach"
			  }
			]
		  },
		  "requirements": [
			{
			  "level": "MUST",
			  "text": "Operate in observer-only posture: measure, seal, and route without control writes to Œû.",
			  "anchor": "PDP-0001 ¬ß3; RFC-0008 ¬ß2"
			},
			{
			  "level": "MUST",
			  "text": "Apply capacity-first behavior: perform equivalence compression before any prune recommendation.",
			  "anchor": "RFC-0006 ¬ß3‚Äì¬ß4; RFC-0009 ¬ß6"
			},
			{
			  "level": "MUST",
			  "text": "Increase effective damping monotonically with occupancy and sustained reinforcement pressure to enforce lawful saturation (dC/dt‚Üí0 under high load).",
			  "anchor": "RFC-0009 ¬ß5‚Äì¬ß7"
			},
			{
			  "level": "MUST",
			  "text": "Honor TTL_floor = max(œÑ_decay, 10¬∑Œît_tick) in all retention contracts (enforcement deferred to Layer_2).",
			  "anchor": "RFC-0005 ¬ß4; RFC-0009 ¬ß7"
			},
			{
			  "level": "SHOULD",
			  "text": "Project measurements along the coherence time vector to maintain geometric consistency of trends.",
			  "anchor": "RFC-0006 ¬ß2"
			},
			{
			  "level": "SHOULD",
			  "text": "Export snapshots via a sealing envelope whose integrity fields are defined structurally at Layer_1 and implemented at Layer_2.",
			  "anchor": "RFC-0008 ¬ß2‚Äì¬ß3; PDP-0001 ¬ß3"
			},
			{
			  "level": "MAY",
			  "text": "Defer ontology payloads by reference, validating only identifiers and minimal headers.",
			  "anchor": "RFC-0007 ¬ß2"
			}
		  ],
		  "error_model": [
			{
			  "code": "E.MMM.001",
			  "when": "Input tick missing required fields or contains non-normalized intent",
			  "message": "invalid_tick_schema",
			  "remedy": "Reject snapshot; log and request upstream normalization per PDP-0001 transport."
			},
			{
			  "code": "E.MMM.002",
			  "when": "Non-finite metric encountered (NaN/Inf) in measurements",
			  "message": "non_finite_metric",
			  "remedy": "Clamp/discard sample; emit anomaly counter; remain in observer mode."
			},
			{
			  "code": "E.MMM.003",
			  "when": "Attempted control write detected at Layer_1",
			  "message": "observer_violation",
			  "remedy": "Block operation; emit audit event; instruct delegation to Layer_2 app-spec."
			},
			{
			  "code": "E.MMM.004",
			  "when": "Retention bound proposed below TTL_floor",
			  "message": "ttl_floor_violation",
			  "remedy": "Raise bound to TTL_floor; emit policy_warning metric."
			}
		  ],
		  "metrics": [
			{
			  "name": "mean_coherence",
			  "unit": "fraction",
			  "window": "EMA-64",
			  "notes": "Average coherence across active motifs; bounded [0,1]."
			},
			{
			  "name": "occupancy_ratio",
			  "unit": "fraction",
			  "window": "EMA-32",
			  "notes": "LTMM utilization used to modulate damping."
			},
			{
			  "name": "damping_effective",
			  "unit": "dimensionless",
			  "window": "EMA-32",
			  "notes": "Adaptive damping after occupancy and pressure adjustments."
			},
			{
			  "name": "triad_integrity",
			  "unit": "fraction",
			  "window": "EMA-16",
			  "notes": "Share of accesses that complete lawful triads."
			},
			{
			  "name": "lawful_compression_ratio",
			  "unit": "fraction",
			  "window": "EMA-32",
			  "notes": "Pre-prune snapshot only; macro metric_compression_lawful."
			},
			{
			  "name": "equivalence_efficiency",
			  "unit": "fraction",
			  "window": "EMA-16",
			  "notes": "Duplicates mapped to canonical reps; macro metric_equiv_eff."
			}
		  ],
		  "pseudocode": [
			{
			  "title": "Coherence Snapshot (Observer)",
			  "anchors": [
				"update_coherence_state"
			  ],
			  "rfc_anchors": [
				"RFC-0009 ¬ß5‚Äì¬ß7",
				"RFC-0006 ¬ß2"
			  ],
			  "code": [
				"def update_coherence_state(C, occupancy, reinforcement_pressure, lambda_eq, a1, a2):",
				"    gamma_co = clamp_nonneg(a1 * occupancy + a2 * max(0.0, reinforcement_pressure - lambda_eq))",
				"    C_next = bound01(C + trend(C, gamma_co))  # observer-only estimation",
				"    return { 'mean_coherence': C_next, 'damping_effective': gamma_co, 'occupancy': occupancy }"
			  ]
			},
			{
			  "title": "Capacity-First Guard",
			  "anchors": [
				"capacity_evaluator"
			  ],
			  "rfc_anchors": [
				"RFC-0006 ¬ß3‚Äì¬ß4",
				"RFC-0009 ¬ß6"
			  ],
			  "code": [
				"def capacity_evaluator(occupancy, theta_sat):",
				"    if occupancy < theta_sat:",
				"        return { 'status': 'ok', 'action': 'none' }",
				"    else:",
				"        return { 'status': 'pressure', 'action': 'request_equivalence_compression' }"
			  ]
			}
		  ],
		  "examples": [
			{
			  "title": "Minimal tick ‚Üí snapshot",
			  "input": {
				"tick": { "timestamp": 1739385600, "source_id": "agent.A", "extensions": { "intent": "neutral" } },
				"motif_stats": { "active_motifs": ["m1","m2"], "resonance": [0.7, 0.6] },
				"occupancy": 0.82,
				"reinforcement_pressure": 0.55
			  },
			  "output": {
				"coherence_snapshot": { "mean_coherence": 0.88, "damping_effective": 0.31, "occupancy": 0.82, "triad_integrity": 0.76 },
				"sealed_envelope": { "structure": "present", "integrity_fields": ["header","provenance","checksum_placeholder"] }
			  },
			  "notes": "Values illustrative; checksum mechanics deferred to Layer_2."
			}
		  ]
		},
		{
		  "id": "1.2",
		  "title": "System Context",
		  "description": "Defines the Layer_1 boundary for the Motif Memory Manager (MMM) as an observer-class substrate. MMM receives symbolic packets and ontology bundles, validates structure and lineage by reference, projects decay/retention along the coherence time vector, and emits lawful telemetry and artifacts to adjacent layers. All operations are measure/seal/route only; no control writes to Œû at Layer_1.",
		  "rfc_anchors": [
			"PDP-0001 ¬ß3",
			"RFC-0005 ¬ß3‚Äì¬ß4",
			"RFC-0006 ¬ß1‚Äì¬ß2",
			"RFC-0007 ¬ß4‚Äì¬ß6, ¬ß8",
			"RFC-0008 ¬ß2‚Äì¬ß3, ¬ß5",
			"RFC-0009 ¬ß5‚Äì¬ß7, Appx D"
		  ],
		  "interfaces": {
			"inputs": [
			  {
				"name": "exchange_packet",
				"type": "object",
				"constraints": "MUST satisfy RFC-0008 structural envelope; ASCII keys only",
				"notes": "Ingress from RFC-CORE-002/003 via RFC-0008 routers"
			  },
			  {
				"name": "ontology_bundle",
				"type": "object",
				"constraints": "MUST be RFC-0007 compliant; version /^\\d{4}-Q[1-4]$/; DAG acyclic",
				"notes": "By-reference embedding; reserved motifs not redefined"
			  },
			  {
				"name": "immune_feedback",
				"type": "object",
				"constraints": "Includes SII, RIR, and near_miss counters per RFC-0009",
				"notes": "Observer health/homeostasis inputs"
			  }
			],
			"outputs": [
			  {
				"name": "density_report",
				"type": "object",
				"constraints": "ASCII keys; contains {mean_coherence, triad_closure_rate, resonance_band_share}",
				"notes": "Observer summary for downstream consumers via RFC-0008"
			  },
			  {
				"name": "sealed_envelope",
				"type": "object",
				"constraints": "Structure-only at Layer_1; integrity/envelope fields are feature-flag gated",
				"notes": "Sigma_phase and Delta_hash present only when enabled; crypto mechanics deferred to Layer_2"
			  },
			  {
				"name": "telemetry_stream",
				"type": "object",
				"constraints": "Windowed EMA metrics per metrics[]",
				"notes": "Immune/observer KPIs to RFC-0009 monitors"
			  }
			],
			"side_effects": [
			  "observer-only"
			]
		  },
		  "state_lifecycle": {
			"states": [
			  "uninitialized",
			  "importing",
			  "observing",
			  "exporting",
			  "error"
			],
			"transitions": [
			  {
				"from": "uninitialized",
				"to": "observing",
				"on": "first_valid_exchange_packet",
				"guard": "envelope structure OK; intent normalized",
				"notes": "PDP-0001 transport compliance"
			  },
			  {
				"from": "observing",
				"to": "importing",
				"on": "ontology_bundle_received",
				"guard": "RFC-0007 version+schema present",
				"notes": "Run DAG/lineage checks"
			  },
			  {
				"from": "importing",
				"to": "observing",
				"on": "bundle_staged",
				"guard": "no cycles; reserved motifs untouched",
				"notes": "Stage by-reference; no control writes"
			  },
			  {
				"from": "observing",
				"to": "exporting",
				"on": "report_interval_elapsed",
				"guard": "EMA windows complete",
				"notes": "Emit density_report and optional sealed_envelope"
			  },
			  {
				"from": "any",
				"to": "error",
				"on": "schema_violation OR feature_flag_violation OR non_finite_metric",
				"guard": "",
				"notes": "Remain observer-only; reject offending item"
			  }
			]
		  },
		  "requirements": [
			{
			  "level": "MUST",
			  "text": "Operate as observer-only at Layer_1: measure, seal, and route without control writes to Œû.",
			  "anchor": "PDP-0001 ¬ß3; RFC-0008 ¬ß2"
			},
			{
			  "level": "MUST",
			  "text": "Validate exchange_packet structure against RFC-0008 and enforce ASCII-only keys on-wire.",
			  "anchor": "RFC-0008 ¬ß5"
			},
			{
			  "level": "MUST",
			  "text": "Validate ontology_bundle version format /^\\d{4}-Q[1-4]$/ and reject any bundle with DAG cycles or reserved-motif redefinitions.",
			  "anchor": "RFC-0007 ¬ß4‚Äì¬ß6, ¬ß8"
			},
			{
			  "level": "MUST",
			  "text": "Gate Sigma_phase and Delta_hash fields by feature flags; when disabled, they MUST NOT appear in outputs.",
			  "anchor": "RFC-0008 ¬ß5; RFC-0009 Appx D"
			},
			{
			  "level": "SHOULD",
			  "text": "Project decay/retention measurements along the coherence time vector for geometric consistency.",
			  "anchor": "RFC-0006 ¬ß1‚Äì¬ß2"
			},
			{
			  "level": "SHOULD",
			  "text": "Emit immune and observer telemetry as EMA-windowed KPIs aligned with RFC-0009 homeostasis bands.",
			  "anchor": "RFC-0009 ¬ß5‚Äì¬ß7"
			}
		  ],
		  "error_model": [
			{
			  "code": "E.MMM.101",
			  "when": "exchange_packet missing required envelope fields or non-ASCII keys detected",
			  "message": "invalid_exchange_packet",
			  "remedy": "Reject packet; log schema path; request upstream normalization"
			},
			{
			  "code": "E.MMM.102",
			  "when": "ontology_bundle version invalid or DAG contains cycles",
			  "message": "ontology_validation_failed",
			  "remedy": "Reject bundle; emit validation report; keep prior observer state"
			},
			{
			  "code": "E.MMM.103",
			  "when": "Reserved motif detected in bundle redefinition",
			  "message": "reserved_motif_violation",
			  "remedy": "Reject offending entries; accept remaining if safe; report reserved IDs"
			},
			{
			  "code": "E.MMM.104",
			  "when": "Feature-flag disabled but output attempted to include Sigma_phase or Delta_hash",
			  "message": "feature_flag_violation",
			  "remedy": "Strip fields; increment policy_warning; audit attempt"
			},
			{
			  "code": "E.MMM.105",
			  "when": "Non-finite metric (NaN/Inf) during export or telemetry",
			  "message": "non_finite_metric",
			  "remedy": "Clamp/discard sample; mark report degraded; continue observer mode"
			},
			{
			  "code": "E.MMM.106",
			  "when": "Any attempted control write operation detected at Layer_1",
			  "message": "observer_violation",
			  "remedy": "Block operation; emit audit event; direct to Layer_2 app-spec"
			}
		  ],
		  "metrics": [
			{
			  "name": "mean_coherence",
			  "unit": "fraction",
			  "window": "EMA-64",
			  "notes": "Average coherence across staged motifs (bounded [0,1])"
			},
			{
			  "name": "triad_closure_rate",
			  "unit": "fraction",
			  "window": "EMA-32",
			  "notes": "Share of accesses that complete lawful triads per tick"
			},
			{
			  "name": "resonance_band_share",
			  "unit": "fraction",
			  "window": "EMA-32",
			  "notes": "Portion of motifs within homeostatic resonance band"
			},
			{
			  "name": "import_accept_rate",
			  "unit": "fraction",
			  "window": "EMA-16",
			  "notes": "Accepted ontology bundles / total received"
			}
		  ],
		  "pseudocode": [
			{
			  "title": "Ingest Symbolic Packet",
			  "anchors": [
				"ingest_symbolic_packet"
			  ],
			  "rfc_anchors": [
				"RFC-0008 ¬ß5",
				"RFC-0009 ¬ß5‚Äì¬ß6"
			  ],
			  "code": [
				"def ingest_symbolic_packet(packet):",
				"    assert ascii_keys(packet), 'E.MMM.101'",
				"    assert exchange_compliant(packet), 'E.MMM.101'",
				"    motif_state = extract_state(packet)  # {C, lambda, gamma_co, rho_res, delta_closure}",
				"    trace_append(motif_state)            # observer trace only",
				"    emit_telemetry(kpis_from(motif_state))",
				"    return {'status': 'ok'}"
			  ]
			},
			{
			  "title": "Import Ontology Bundle",
			  "anchors": [
				"import_ontology_bundle"
			  ],
			  "rfc_anchors": [
				"RFC-0007 ¬ß4‚Äì¬ß6, ¬ß8"
			  ],
			  "code": [
				"def import_ontology_bundle(bundle):",
				"    assert version_matches(bundle.version, r\"^\\d{4}-Q[1-4]$\"), 'E.MMM.102'",
				"    assert schema_ok(bundle), 'E.MMM.102'",
				"    assert dag_acyclic(bundle.graph), 'E.MMM.102'",
				"    assert no_reserved_motif_overrides(bundle), 'E.MMM.103'",
				"    stage_by_reference(bundle)",
				"    return {'status': 'accepted'}"
			  ]
			},
			{
			  "title": "Export Density Report",
			  "anchors": [
				"export_density_report"
			  ],
			  "rfc_anchors": [
				"RFC-0008 ¬ß2‚Äì¬ß3",
				"RFC-0009 ¬ß5‚Äì¬ß7"
			  ],
			  "code": [
				"def export_density_report(window, flags):",
				"    kpis = summarize_ema(window, ['mean_coherence','triad_closure_rate','resonance_band_share'])",
				"    report = {'type': 'DensityReport', **kpis}",
				"    if flags.enable_exchange_envelope:",
				"        report['Sigma_phase'] = structure_only_sigma()",
				"    if flags.enable_integrity_checks:",
				"        report['Delta_hash'] = structure_only_delta()",
				"    return report"
			  ]
			}
		  ],
		  "examples": [
			{
			  "title": "Ingress packet ‚Üí telemetry and report (flags ON)",
			  "input": {
				"exchange_packet": { "hdr": "v1", "route": "Œû/core", "body": { "C": 0.82, "rho_res": 0.74 }, "meta": { "intent": "neutral" } },
				"flags": { "enable_exchange_envelope": true, "enable_integrity_checks": true }
			  },
			  "output": {
				"telemetry_stream": { "mean_coherence": 0.82, "resonance_band_share": 0.74 },
				"density_report": { "type": "DensityReport", "mean_coherence": 0.82, "triad_closure_rate": 0.71, "resonance_band_share": 0.74, "Sigma_phase": "present", "Delta_hash": "present" }
			  },
			  "notes": "Integrity/envelope fields attached because flags are enabled; structure-only at Layer_1."
			},
			{
			  "title": "Ontology import (cycle detected)",
			  "input": {
				"ontology_bundle": { "version": "2025-Q4", "graph": { "A": ["B"], "B": ["A"] } }
			  },
			  "output": {
				"error": { "code": "E.MMM.102", "message": "ontology_validation_failed" }
			  },
			  "notes": "Bundle rejected due to DAG cycle per RFC-0007."
			}
		  ]
		},
	},
	
    "2": {
      "id": "2",
	  "title": "Core Memory Architecture and Dynamics",
		{
		  "id": "2.1",
		  "title": "Core Invariants of Memory Fields",
		  "description": "Defines the Layer_1 WHAT for short-term (STMM) and long-term (LTMM) memory fields so that reinforcement and decay remain bounded under dynamic motif load. Establishes capacity limits, adaptive damping, ethical TTL bounds, and a strict capacity-first doctrine (compress-by-equivalence before any prune). All routines are observer-class (measure/seal/route) with no control writes to Œû.",
		  "rfc_anchors": [
			"PDP-0001 ¬ß3",
			"RFC-0005 ¬ß3‚Äì¬ß4",
			"RFC-0006 ¬ß1‚Äì¬ß4",
			"RFC-0008 ¬ß2",
			"RFC-0009 ¬ß5‚Äì¬ß7"
		  ],
		  "interfaces": {
			"inputs": [
			  { "name": "LTMM_usage", "type": "number", "constraints": "0 <= LTMM_usage <= C_max", "notes": "Current long-term memory occupancy (bytes or items)" },
			  { "name": "C_max", "type": "number", "constraints": "0 < C_max <= 1 (normalized) OR >0 (absolute); choose one convention per deployment", "notes": "Capacity used for occupancy normalization" },
			  { "name": "theta_sat", "type": "number", "constraints": "0 < theta_sat < 1", "notes": "Saturation threshold to trigger compression" },
			  { "name": "theta_prune", "type": "number", "constraints": "theta_prune >= theta_sat", "notes": "Post-compression threshold permitting prune recommendation" },
			  { "name": "tau_decay", "type": "number", "constraints": "tau_decay > 0", "notes": "Lawful decay time constant (RFC-0005)" },
			  { "name": "delta_t_tick", "type": "number", "constraints": "delta_t_tick > 0", "notes": "Symbolic tick interval" },
			  { "name": "storage_pressure", "type": "number", "constraints": "storage_pressure >= 0", "notes": "Monotone influence on TTL_max" },
			  { "name": "replay_rate", "type": "number", "constraints": "replay_rate >= 0", "notes": "Observed replay pressure" },
			  { "name": "conflict_rate", "type": "number", "constraints": "conflict_rate >= 0", "notes": "Observed conflict/contradiction rate" }
			],
			"outputs": [
			  { "name": "capacity_status", "type": "object", "constraints": "ASCII keys", "notes": "{status: ok|pressure, action: none|request_compress}" },
			  { "name": "prune_recommendation", "type": "object", "constraints": "ASCII keys", "notes": "{decision: hold|recommend_prune, eta_occ_post: number}" },
			  { "name": "ttl_bounds", "type": "object", "constraints": "ASCII keys", "notes": "{TTL_floor, TTL_max_effective}" },
			  { "name": "damping_effective", "type": "number", "constraints": ">= 0", "notes": "gamma_co derived from occupancy/replay/conflict" }
			],
			"side_effects": [ "observer-only" ]
		  },
		  "state_lifecycle": {
			"states": [ "observing", "capacity_pressure", "export_ready", "error" ],
			"transitions": [
			  { "from": "observing", "to": "capacity_pressure", "on": "eta_occ >= theta_sat", "guard": "thresholds valid", "notes": "Trigger compression recommendation" },
			  { "from": "capacity_pressure", "to": "export_ready", "on": "compression_snapshot_ready", "guard": "no control writes performed", "notes": "Prepare prune recommendation if needed" },
			  { "from": "any", "to": "error", "on": "non_finite_input OR theta_prune < theta_sat OR observer_violation", "guard": "", "notes": "Halt recommendations; emit errors" }
			]
		  },
		  "requirements": [
			{ "level": "MUST", "text": "Apply capacity-first: perform equivalence compression before emitting any prune recommendation.", "anchor": "RFC-0006 ¬ß3‚Äì¬ß4; RFC-0009 ¬ß6‚Äì¬ß7" },
			{ "level": "MUST", "text": "Only allow prune recommendation if eta_occ_post >= theta_prune and theta_prune >= theta_sat.", "anchor": "RFC-0006 ¬ß4.4; RFC-0009 ¬ß7.1" },
			{ "level": "MUST", "text": "Compute effective damping gamma_co as a non-decreasing function of occupancy, replay_rate, and conflict_rate to enforce lawful saturation (dC/dt ‚Üí 0 at high pressure).", "anchor": "RFC-0005 ¬ß3.2; RFC-0009 ¬ß5‚Äì¬ß7" },
			{ "level": "MUST", "text": "Honor ethical retention: TTL_floor = max(tau_decay, 10¬∑delta_t_tick) and ensure TTL_floor <= TTL <= TTL_max_effective.", "anchor": "RFC-0005 ¬ß4; RFC-0009 ¬ß7" },
			{ "level": "MUST", "text": "Remain observer-only at Layer_1: measure, seal, route; do not perform control writes to Œû.", "anchor": "PDP-0001 ¬ß3; RFC-0008 ¬ß2" },
			{ "level": "SHOULD", "text": "Project measurements and retention trends along the coherence time vector for geometric consistency.", "anchor": "RFC-0006 ¬ß1‚Äì¬ß2" }
		  ],
		  "error_model": [
			{ "code": "E.MMM.201", "when": "Prune recommendation emitted without prior equivalence compression", "message": "prune_without_compression", "remedy": "Block recommendation; run compression; re-evaluate" },
			{ "code": "E.MMM.202", "when": "Proposed TTL below TTL_floor", "message": "ttl_floor_violation", "remedy": "Clamp to TTL_floor; emit policy_warning; continue observer mode" },
			{ "code": "E.MMM.203", "when": "Computed gamma_co decreases as pressure terms increase", "message": "non_monotonic_damping", "remedy": "Reject update; recompute with monotone transform; raise anomaly" },
			{ "code": "E.MMM.204", "when": "Any input is NaN/Inf or out of declared domain", "message": "non_finite_input", "remedy": "Discard sample; mark window degraded; request upstream normalization" },
			{ "code": "E.MMM.205", "when": "theta_prune < theta_sat", "message": "invalid_threshold_order", "remedy": "Reject configuration; require theta_prune >= theta_sat" },
			{ "code": "E.MMM.206", "when": "Attempted control write at Layer_1", "message": "observer_violation", "remedy": "Block action; emit audit; delegate to Layer_2 app-spec" }
		  ],
		  "metrics": [
			{ "name": "saturation_level", "unit": "fraction", "window": "EMA-32", "notes": "eta_occ = LTMM_usage / C_max" },
			{ "name": "lawful_compression_ratio", "unit": "fraction", "window": "EMA-32", "notes": "Pre-prune snapshot only" },
			{ "name": "equivalence_efficiency", "unit": "fraction", "window": "EMA-16", "notes": "Duplicates mapped to canonical representatives" },
			{ "name": "ethical_ttl_floor", "unit": "ticks", "window": "EMA-64", "notes": "max(tau_decay, 10¬∑delta_t_tick)" },
			{ "name": "ttl_max_effective", "unit": "ticks", "window": "EMA-32", "notes": "Monotone decreasing in storage_pressure" },
			{ "name": "damping_effective", "unit": "dimensionless", "window": "EMA-32", "notes": "gamma_co derived from occupancy/replay/conflict" }
		  ],
		  "pseudocode": [
			{
			  "title": "Capacity Evaluator (Observer)",
			  "anchors": [ "capacity_evaluator" ],
			  "rfc_anchors": [ "RFC-0006 ¬ß3‚Äì¬ß4", "RFC-0009 ¬ß6" ],
			  "code": [
				"def capacity_evaluator(LTMM_usage, C_max, theta_sat):",
				"    eta_occ = LTMM_usage / C_max",
				"    if eta_occ < theta_sat:",
				"        return { 'status': 'ok', 'action': 'none', 'eta_occ': eta_occ }",
				"    else:",
				"        return { 'status': 'pressure', 'action': 'request_compress', 'eta_occ': eta_occ }"
			  ]
			},
			{
			  "title": "TTL Bounds & Damping Update (Observer)",
			  "anchors": [ "compute_ttl_bounds", "update_gamma_co" ],
			  "rfc_anchors": [ "RFC-0005 ¬ß4", "RFC-0009 ¬ß5‚Äì¬ß7" ],
			  "code": [
				"def compute_ttl_bounds(tau_decay, delta_t_tick, storage_pressure, policy):",
				"    TTL_floor = max(tau_decay, 10 * delta_t_tick)",
				"    TTL_max_effective = policy.bound(storage_pressure)  # monotone decreasing",
				"    return { 'TTL_floor': TTL_floor, 'TTL_max_effective': TTL_max_effective }",
				"",
				"def update_gamma_co(eta_occ, replay_rate, conflict_rate, gamma_0, a1, a2, a3):",
				"    gamma_co = max(0.0, gamma_0 + a1*eta_occ + a2*replay_rate + a3*conflict_rate)",
				"    return gamma_co"
			  ]
			}
		  ],
		  "examples": [
			{
			  "title": "Compression before prune",
			  "input": { "LTMM_usage": 0.86, "C_max": 1.0, "theta_sat": 0.75, "theta_prune": 0.85 },
			  "output": { "capacity_status": { "status": "pressure", "action": "request_compress", "eta_occ": 0.86 }, "prune_recommendation": { "decision": "hold" } },
			  "notes": "Prune may only be recommended after a compression snapshot shows eta_occ_post >= theta_prune."
			},
			{
			  "title": "TTL bounds under pressure",
			  "input": { "tau_decay": 30, "delta_t_tick": 2, "storage_pressure": 0.7, "policy": "monotone" },
			  "output": { "ttl_bounds": { "TTL_floor": 30, "TTL_max_effective": 18 } },
			  "notes": "Floor respects RFC-0005; ceiling reduced by storage pressure per RFC-0009."
			}
		  ]
		},
		{
		  "id": "2.2",
		  "title": "STMM/LTMM Update Laws",
		  "description": "Defines adaptive update laws for Short-Term Motif Memory (STMM) and Long-Term Motif Memory (LTMM) under an observer-only posture at Layer_1: promotion back-pressure, equivalence-first compression before any prune, staleness-dependent damping, and glider-aware idempotence. All actions are measurements and recommendations; enforcement lives in Layer_2.",
		  "rfc_anchors": [
			"PDP-0001 ¬ß3‚Äì¬ß4",
			"RFC-0005 ¬ß3‚Äì¬ß4",
			"RFC-0006 ¬ß3‚Äì¬ß4",
			"RFC-0008 ¬ß2",
			"RFC-0009 ¬ß5‚Äì¬ß7"
		  ],
		  "interfaces": {
			"inputs": [
			  { "name": "C_ema64", "type": "number", "constraints": "0<=C_ema64<=1; finite", "notes": "Smoothed coherence for content gate" },
			  { "name": "delta_closure", "type": "number", "constraints": "delta_closure>=0; finite", "notes": "Triadic closure residual" },
			  { "name": "rho_res", "type": "number", "constraints": "0<=rho_res<=1", "notes": "Resonance band indicator" },
			  { "name": "LTMM_usage", "type": "number", "constraints": "0<=LTMM_usage<=C_max", "notes": "Occupied capacity" },
			  { "name": "C_max", "type": "number", "constraints": "C_max>0", "notes": "Capacity for occupancy normalization" },
			  { "name": "lawful_compression_ratio", "type": "number", "constraints": "0<=value<=1", "notes": "Post-equivalence/pre-prune size √∑ pre-equivalence size" },
			  { "name": "replay_rate", "type": "number", "constraints": "replay_rate>=0", "notes": "Observed replay pressure" },
			  { "name": "conflict_rate", "type": "number", "constraints": "conflict_rate>=0", "notes": "Observed conflict/contradiction rate" },
			  { "name": "last_access_intervals", "type": "array<number>", "constraints": "each > 0", "notes": "For staleness EMA" },
			  { "name": "is_glider", "type": "boolean", "constraints": "", "notes": "Glider detection flag (structure-only at L1)" },
			  { "name": "canonical_present", "type": "boolean", "constraints": "", "notes": "Whether canonical representative already exists" }
			],
			"outputs": [
			  { "name": "promotion_decision", "type": "object", "constraints": "ASCII keys", "notes": "{promote: true|false, backpressure: [0,1], reasons: []}" },
			  { "name": "capacity_action", "type": "object", "constraints": "ASCII keys", "notes": "{action: none|compress|prune, snapshot: {lawful_compression_ratio,equivalence_efficiency,eta_occ_pre,eta_occ_post}}" },
			  { "name": "staleness_update", "type": "object", "constraints": "ASCII keys", "notes": "{gamma_stale, gamma_total_hint}" }
			],
			"side_effects": [
			  "observer-only"
			]
		  },
		  "state_lifecycle": {
			"states": [
			  "observing",
			  "promotion_gated",
			  "capacity_pressure",
			  "post_compress_evaluation",
			  "error"
			],
			"transitions": [
			  { "from": "observing", "to": "promotion_gated", "on": "content_and_capacity_checks_evaluated", "guard": "inputs finite", "notes": "Decide promote bool + back-pressure" },
			  { "from": "observing", "to": "capacity_pressure", "on": "eta_occ > rho_thresh(t)", "guard": "", "notes": "Begin equivalence-first capacity actions" },
			  { "from": "capacity_pressure", "to": "post_compress_evaluation", "on": "compression_snapshot_ready", "guard": "KPIs computed", "notes": "Consider prune only after compression KPIs" },
			  { "from": "any", "to": "error", "on": "non_finite_input OR observer_violation", "guard": "", "notes": "Hold state; emit error" }
			]
		  },
		  "requirements": [
			{ "level": "MUST", "text": "Apply equivalence compression (shift/closure) before emitting any prune recommendation when eta_occ exceeds threshold.", "anchor": "RFC-0006 ¬ß4.4; RFC-0009 ¬ß6‚Äì¬ß7" },
			{ "level": "MUST", "text": "Promotion STMM‚ÜíLTMM requires both content gates (C_ema64, delta_closure, resonance band) AND capacity gates (eta_occ below cap and lawful_compression_ratio at/below threshold).", "anchor": "RFC-0006 ¬ß3‚Äì¬ß4; RFC-0009 ¬ß7.1" },
			{ "level": "MUST", "text": "Emit lawful_compression_ratio and equivalence_efficiency KPIs with every compression snapshot, prior to any prune recommendation.", "anchor": "RFC-0006 ¬ß4.4; RFC-0009 ¬ß6" },
			{ "level": "MUST", "text": "Increase effective damping monotonically with staleness (EMA of inter-access intervals) in addition to occupancy/replay/conflict pressures.", "anchor": "RFC-0005 ¬ß4.2; RFC-0009 ¬ß5‚Äì¬ß7" },
			{ "level": "MUST", "text": "Glider promotions are idempotent: at most one canonical representative per equivalence class.", "anchor": "RFC-0006 ¬ß3‚Äì¬ß4" },
			{ "level": "MUST", "text": "Maintain observer-only posture: provide measurements, KPIs, and recommendations without control writes to Œû.", "anchor": "PDP-0001 ¬ß3‚Äì¬ß4; RFC-0008 ¬ß2" },
			{ "level": "SHOULD", "text": "Project update trends along the coherence time vector to maintain geometric consistency.", "anchor": "RFC-0006 ¬ß1‚Äì¬ß2" }
		  ],
		  "error_model": [
			{ "code": "E.MMM.301", "when": "Prune recommendation emitted without prior equivalence compression snapshot", "message": "prune_without_compression", "remedy": "Block; run compression; compute KPIs; re-evaluate" },
			{ "code": "E.MMM.302", "when": "Non-finite or out-of-range inputs encountered (NaN/Inf/invalid bounds)", "message": "non_finite_input", "remedy": "Discard sample; mark window degraded; request normalization" },
			{ "code": "E.MMM.303", "when": "Glider promotion requested but canonical_present=true", "message": "glider_idempotence_violation", "remedy": "Deny promotion; reference existing canonical" },
			{ "code": "E.MMM.304", "when": "Compression KPIs missing on prune evaluation", "message": "missing_compression_kpis", "remedy": "Recompute snapshot; emit lawful_compression_ratio and equivalence_efficiency" },
			{ "code": "E.MMM.305", "when": "Attempted control write at Layer_1", "message": "observer_violation", "remedy": "Block; emit audit; delegate to Layer_2 app-spec" }
		  ],
		  "metrics": [
			{ "name": "promotion_rate", "unit": "events/tick", "window": "EMA-32", "notes": "STMM‚ÜíLTMM promotions per tick (recommended)" },
			{ "name": "promotion_backpressure", "unit": "dimensionless", "window": "EMA-32", "notes": "Rises with occupancy, eases with effective compression" },
			{ "name": "eta_occ", "unit": "fraction", "window": "EMA-32", "notes": "LTMM occupancy fraction" },
			{ "name": "lawful_compression_ratio", "unit": "dimensionless", "window": "EMA-32", "notes": "Post-equivalence/pre-prune size √∑ pre-equivalence size" },
			{ "name": "equivalence_efficiency", "unit": "fraction", "window": "EMA-32", "notes": "Capacity relief achieved by equivalence compression" },
			{ "name": "prune_events", "unit": "events/tick", "window": "EMA-16", "notes": "Count of prunes recommended after compression insufficient" },
			{ "name": "staleness_index", "unit": "fraction", "window": "EMA-32", "notes": "Normalized EMA of inter-access intervals" }
		  ],
		  "pseudocode": [
			{
			  "title": "Promotion Decision with Back-Pressure (Observer)",
			  "anchors": [ "promotion_decision_with_backpressure" ],
			  "rfc_anchors": [ "RFC-0006 ¬ß3‚Äì¬ß4", "RFC-0009 ¬ß7.1" ],
			  "code": [
				"def promotion_decision_with_backpressure(C_ema64, delta_closure, rho_res, LTMM_usage, C_max, lawful_compression_ratio,",
				"                                         lambda_thresh_seed, theta_promote_cap, theta_lcr, epsilon_triad):",
				"    eta_occ = LTMM_usage / C_max",
				"    lambda_thresh = lambda_thresh_seed * (1 + ema32(eta_occ))",
				"    cond_content = (C_ema64 >= lambda_thresh) and (delta_closure < epsilon_triad) and (0.3 <= rho_res <= 0.7)",
				"    cond_capacity = (eta_occ < theta_promote_cap) and (lawful_compression_ratio <= theta_lcr)",
				"    promote = bool(cond_content and cond_capacity)",
				"    backpressure = 1.0 - min(1.0, max(0.0, (theta_promote_cap - eta_occ) / theta_promote_cap))",
				"    return { 'promote': promote, 'backpressure': backpressure, 'reasons': explain(cond_content, cond_capacity) }"
			  ]
			},
			{
			  "title": "Equivalence-First Capacity Management (Observer)",
			  "anchors": [ "equivalence_first_capacity_management" ],
			  "rfc_anchors": [ "RFC-0006 ¬ß4.4", "RFC-0009 ¬ß6‚Äì¬ß7" ],
			  "code": [
				"def equivalence_first_capacity_management(LTMM_index, rho_thresh_seed, compression_target, prune_floor):",
				"    eta_occ = occupancy(LTMM_index)",
				"    rho_thresh = rho_thresh_seed * (1 - ema32(1 - eta_occ))",
				"    if eta_occ <= rho_thresh:",
				"        return { 'action': 'none', 'snapshot': { 'eta_occ_pre': eta_occ } }",
				"    S = find_equivalence_classes(LTMM_index, mode='closure_shift')",
				"    pre = size(LTMM_index); post = size(representatives(S))",
				"    lcr = post / max(1, pre); eff = (pre - post) / max(1, pre)",
				"    LTMM_index = store_representatives(S, target=compression_target)  # observer recommendation surface",
				"    eta_post = occupancy(LTMM_index)",
				"    if eta_post > rho_thresh:",
				"        return { 'action': 'prune', 'snapshot': { 'lawful_compression_ratio': lcr, 'equivalence_efficiency': eff, 'eta_occ_pre': eta_occ, 'eta_occ_post': eta_post } }",
				"    else:",
				"        return { 'action': 'compress', 'snapshot': { 'lawful_compression_ratio': lcr, 'equivalence_efficiency': eff, 'eta_occ_pre': eta_occ, 'eta_occ_post': eta_post } }"
			  ]
			}
		  ],
		  "examples": [
			{
			  "title": "Promotion denied due to capacity gate",
			  "input": { "C_ema64": 0.88, "delta_closure": 0.01, "rho_res": 0.55, "LTMM_usage": 0.83, "C_max": 1.0, "lawful_compression_ratio": 0.62,
						 "lambda_thresh_seed": 0.8, "theta_promote_cap": 0.8, "theta_lcr": 0.6, "epsilon_triad": 0.02 },
			  "output": { "promotion_decision": { "promote": false, "backpressure": 0.96, "reasons": ["capacity_gate_failed","lcr_above_threshold"] } },
			  "notes": "Content gates pass; capacity gate fails due to occupancy and LCR."
			},
			{
			  "title": "Compression before prune under saturation",
			  "input": { "LTMM_index_size": 1000, "rho_thresh_seed": 0.7, "compression_target": 0.75, "prune_floor": 0.2, "eta_occ_initial": 0.92 },
			  "output": { "capacity_action": { "action": "prune", "snapshot": { "lawful_compression_ratio": 0.82, "equivalence_efficiency": 0.18, "eta_occ_pre": 0.92, "eta_occ_post": 0.88 } } },
			  "notes": "Compression attempted first; still saturated ‚Üí prune recommendation allowed."
			}
		  ]
		},
		{
		  "id": "2.3",
		  "title": "Reanchor and Recovery Escalation Logic",
		  "description": "Define an observer-only, bounded recovery procedure that (a) detects violation conditions, (b) attempts reanchor within a capped budget derived from conflict-rate EMA, (c) escalates to quarantine on overlap or exhaustion, and (d) guarantees finite outcomes {reanchored, quarantined, abandoned} with full auditability.",
		  "rfc_anchors": [
			"PDP-0001 ¬ß3‚Äì¬ß4",
			"RFC-0005 ¬ß4.2",
			"RFC-0006 ¬ß3‚Äì¬ß4",
			"RFC-0007 ¬ß2",
			"RFC-0008 ¬ß2‚Äì¬ß3",
			"RFC-0009 ¬ß5‚Äì¬ß7"
		  ],
		  "interfaces": {
			"inputs": [
			  { "name": "snapshot_history", "type": "list<observer_snapshot>", "constraints": "ordered by time, includes closure/resonance measures", "notes": "read-only provenance; no Layer_2 keying" },
			  { "name": "tau_recovery", "type": "duration", "constraints": "tau_recovery > 0", "notes": "window to search for last lawful state" },
			  { "name": "conflict_rate_ema32", "type": "float", "constraints": "0 <= value", "notes": "smoothed incident rate driving attempt budget" },
			  { "name": "k", "type": "float", "constraints": "k >= 0", "notes": "scales attempt budget" },
			  { "name": "epsilon_triad", "type": "float", "constraints": "epsilon_triad > 0", "notes": "closure gap tolerance" }
			],
			"outputs": [
			  { "name": "status", "type": "enum", "constraints": "{no_action|reanchored|quarantined|abandoned|rejected|staged}", "notes": "finite terminal or staging status" },
			  { "name": "recovery_token", "type": "string", "constraints": "monotonic, unique per incident", "notes": "used for idempotence and audit trace" }
			],
			"side_effects": [
			  "observer-only: emit events/metrics",
			  "observer-only: mark quarantine set (read-only isolation)",
			  "observer-only: stage bundles after validation (no control writes to Xi)"
			]
		  },
		  "state_lifecycle": {
			"states": [
			  "idle",
			  "detecting_violation",
			  "reanchoring",
			  "quarantined",
			  "reanchored",
			  "abandoned"
			],
			"transitions": [
			  { "from": "idle", "to": "detecting_violation", "on": "violation_detected", "guard": "resonance out of band OR closure_gap > epsilon_triad", "notes": "RFC-0006 bands; RFC-0009 closure integrity" },
			  { "from": "detecting_violation", "to": "reanchoring", "on": "attempt_budget_allocated", "guard": "N_max = ceil(k * conflict_rate_ema32) >= 1", "notes": "bounded attempts (RFC-0009 ¬ß5.2)" },
			  { "from": "reanchoring", "to": "reanchored", "on": "lawful_state_found", "guard": "closure_gap == 0 AND resonance in band", "notes": "RFC-0006 lawful test" },
			  { "from": "reanchoring", "to": "quarantined", "on": "overlap_or_exhaustion", "guard": "overlapping windows OR attempts exhausted", "notes": "escalation to quarantine" },
			  { "from": "quarantined", "to": "reanchored", "on": "diagnostics_pass", "guard": "bounded Jacobian AND improving closure", "notes": "observer diagnostics only (RFC-0009 ¬ß7)" },
			  { "from": "quarantined", "to": "abandoned", "on": "ttl_or_policy_stop", "guard": "quarantine TTL elapsed without pass", "notes": "finite termination" }
			]
		  },
		  "requirements": [
			{ "level": "MUST", "text": "Operate as observer-only: no control writes to Xi during detection, reanchor, quarantine, or diagnostics.", "anchor": "PDP-0001 ¬ß3‚Äì¬ß4" },
			{ "level": "MUST", "text": "Bound reanchor attempts by N_max = ceil(k * conflict_rate_ema32) with per-attempt window tau_recovery.", "anchor": "RFC-0009 ¬ß5.2" },
			{ "level": "MUST", "text": "Escalate to quarantine if recovery windows overlap or attempts are exhausted.", "anchor": "RFC-0009 ¬ß5.2; RFC-0005 ¬ß4.2" },
			{ "level": "MUST", "text": "Ensure finite outcomes in {reanchored, quarantined, abandoned} and record an audit trace keyed by recovery_token.", "anchor": "RFC-0009 ¬ß5.2" },
			{ "level": "MUST", "text": "Test lawfulness using closure == 0 and resonance within the RFC-0006 in-band interval.", "anchor": "RFC-0006 ¬ß3‚Äì¬ß4" },
			{ "level": "SHOULD", "text": "Reject import bundles lacking valid DAG, envelope, or lineage before staging.", "anchor": "RFC-0007 ¬ß2; RFC-0008 ¬ß2‚Äì¬ß3" },
			{ "level": "MAY", "text": "Adapt k via policy tied to capacity/homeostasis KPIs.", "anchor": "RFC-0009 ¬ß5‚Äì¬ß7" }
		  ],
		  "error_model": [
			{ "code": "E.MMM.230", "when": "overlapping recovery windows detected", "message": "Recovery windows overlap; escalation required.", "remedy": "Escalate to quarantine; preserve read-only observability." },
			{ "code": "E.MMM.231", "when": "no lawful prior snapshot in tau_recovery", "message": "No lawful state found in window.", "remedy": "Emit reanchor_fail; escalate to quarantine." },
			{ "code": "E.MMM.232", "when": "idempotent re-entry with identical recovery_token", "message": "Duplicate recovery cycle suppressed.", "remedy": "Emit idempotent_drop; return abandoned." },
			{ "code": "E.MMM.233", "when": "quarantine diagnostics exceed TTL without pass", "message": "Diagnostics timed out.", "remedy": "Hold or abandon per policy; do not export/promote." },
			{ "code": "E.MMM.234", "when": "import validation fails (DAG/envelope/lineage)", "message": "Bundle rejected by guard.", "remedy": "Emit near_miss and return rejected; staging is not performed." }
		  ],
		  "metrics": [
			{ "name": "reanchor_attempt", "unit": "count/tick", "window": "EMA-32", "notes": "Increment per attempt (bounded by N_max)." },
			{ "name": "reanchor_fail", "unit": "count/tick", "window": "EMA-16", "notes": "Attempts that did not reach a lawful state." },
			{ "name": "quarantine_entry", "unit": "count/tick", "window": "EMA-32", "notes": "Escalations due to overlap or exhaustion." },
			{ "name": "overlap_detected", "unit": "flag", "window": "EMA-16", "notes": "1 if any overlap occurred in the last tick; else 0." },
			{ "name": "recovery_latency", "unit": "ticks", "window": "EMA-32", "notes": "Ticks from violation to terminal state {reanchored|quarantined}." },
			{ "name": "diagnostic_jacobian_norm", "unit": "unitless", "window": "EMA-16", "notes": "Estimated local Jacobian norm during quarantine diagnostics." },
			{ "name": "quarantine_pass_share", "unit": "fraction", "window": "EMA-32", "notes": "Share of quarantined items that passed the last diagnostic step." }
		  ],
		  "pseudocode": [
			{
			  "title": "Reanchor Protocol (Observer)",
			  "anchors": ["reanchor_protocol"],
			  "rfc_anchors": ["RFC-0006 ¬ß3‚Äì¬ß4", "RFC-0009 ¬ß5.2"],
			  "code": [
				"def reanchor_protocol(hist, tau_recovery, conflict_rate_ema32, k, epsilon_triad):",
				"    if not violation_detected(epsilon_triad):",
				"        return {'status': 'no_action', 'recovery_token': None}",
				"    token = monotonic_token()",
				"    if seen(token):",
				"        emit('idempotent_drop'); return {'status': 'abandoned', 'recovery_token': token}",
				"    N_max = max(1, ceil(k * conflict_rate_ema32))",
				"    for _ in range(N_max):",
				"        cand = last_lawful(hist, tau_recovery)",
				"        if cand is None: emit('reanchor_fail'); break",
				"        stage_observer_state(cand)  # observer-only",
				"        if is_lawful(): emit('reanchor_success'); return {'status': 'reanchored', 'recovery_token': token}",
				"        emit('reanchor_attempt')",
				"    if windows_overlap(tau_recovery): emit('overlap_detected')",
				"    return quarantine_escalation(token)"
			  ]
			},
			{
			  "title": "Quarantine Escalation (Observer)",
			  "anchors": ["quarantine_escalation"],
			  "rfc_anchors": ["RFC-0009 ¬ß7", "PDP-0001 ¬ß3‚Äì¬ß4"],
			  "code": [
				"def quarantine_escalation(token):",
				"    isolate_readonly_set(token)          # suppress export/promotion at Layer_1",
				"    emit('quarantine_entry', {'token': token})",
				"    start_quarantine_timer()",
				"    return {'status': 'quarantined', 'recovery_token': token}"
			  ]
			}
		  ],
		  "examples": [
			{
			  "title": "Reanchored after one attempt",
			  "input": {
				"snapshot_history": ["s0_lawful", "s1_violation"],
				"tau_recovery": "5s",
				"conflict_rate_ema32": 0.2,
				"k": 3.0,
				"epsilon_triad": 0.001
			  },
			  "output": { "status": "reanchored", "recovery_token": "tok_12345" },
			  "notes": "N_max = ceil(3.0 * 0.2) = 1; last lawful found within tau_recovery."
			},
			{
			  "title": "Escalation to quarantine on overlap",
			  "input": {
				"snapshot_history": ["s0_violation", "s1_violation"],
				"tau_recovery": "10s",
				"conflict_rate_ema32": 0.9,
				"k": 2.0,
				"epsilon_triad": 0.001
			  },
			  "output": { "status": "quarantined", "recovery_token": "tok_67890" },
			  "notes": "Attempts exhausted and recovery windows overlap; quarantine_entry emitted."
			}
		  ]
		}	
    },

    "3": {
      "id": "3",
	  "title": "Memory Structures and Data Formats",
		{
		  "id": "3.1",
		  "title": "Motif Ontology Bundles",
		  "description": "Define the observer-only contracts for Motif Ontology Bundles (MOBs) used in cross-agent exchange: minimal on-wire schema, provenance and lineage fields (structural only), validation gates (RFC-0007 DAG/version, trusted origin), deterministic merge/fork classification, replay/phase checks under feature flags, and quarantine routing on failure. Layer_1 remains neutral and non-cryptographic; all control writes and cryptographic semantics are deferred to Layer_2.",
		  "rfc_anchors": [
			"PDP-0001 ¬ß3‚Äì¬ß4",
			"RFC-0005 ¬ß4.2",
			"RFC-0006 ¬ß3‚Äì¬ß4",
			"RFC-0007 ¬ß2‚Äì¬ß4, ¬ß8",
			"RFC-0008 ¬ß2‚Äì¬ß3, ¬ß5",
			"RFC-0009 ¬ß6‚Äì¬ß7"
		  ],
		  "interfaces": {
			"inputs": [
			  { "name": "bundle", "type": "object<MOB>", "constraints": "contains {header, ontology, lineage, provenance}", "notes": "values may include Unicode (e.g., motif ids); keys are ASCII" },
			  { "name": "trusted_roots", "type": "set<origin>", "constraints": "non-empty for production use", "notes": "Layer_1 structural registry; no keys/PKI here" },
			  { "name": "feature_flags", "type": "object", "constraints": "booleans: {enable_exchange_envelope, enable_integrity_checks, enable_provenance_on_export}", "notes": "gates Sigma_phase/Delta_hash/provenance-on-export" }
			],
			"outputs": [
			  { "name": "status", "type": "enum", "constraints": "{valid|staged|merged|forked|unrelated|rejected|quarantined}", "notes": "finite outcome for import/reconcile/export" },
			  { "name": "result", "type": "object|null", "constraints": "merged bundle or fork pair metadata; null otherwise", "notes": "observer-constructed summary only" }
			],
			"side_effects": [
			  "observer-only: emit telemetry/events",
			  "observer-only: stage bundle for read-only use",
			  "observer-only: route failed validations to quarantine classification (no deletion/prune at L1)"
			]
		  },
		  "state_lifecycle": {
			"states": [
			  "idle",
			  "validating",
			  "staged",
			  "reconciled_merged",
			  "reconciled_forked",
			  "reconciled_unrelated",
			  "quarantined",
			  "rejected"
			],
			"transitions": [
			  { "from": "idle", "to": "validating", "on": "bundle_received", "guard": "", "notes": "begin RFC-0007/0008/0009 structural checks" },
			  { "from": "validating", "to": "rejected", "on": "ontology_or_origin_invalid", "guard": "DAG fail OR version fail OR unknown origin", "notes": "emit dag_invalid/version_invalid/unknown_origin" },
			  { "from": "validating", "to": "rejected", "on": "lineage_or_phase_invalid", "guard": "flagged checks fail", "notes": "Delta_hash or Sigma_phase gates" },
			  { "from": "validating", "to": "staged", "on": "all_checks_pass", "guard": "", "notes": "observer staging only" },
			  { "from": "staged", "to": "reconciled_merged", "on": "reconcile", "guard": "parent_hash=A=B AND integrity_hash=A=B (if enabled)", "notes": "deterministic merge" },
			  { "from": "staged", "to": "reconciled_forked", "on": "reconcile", "guard": "parent_hash=A=B AND integrity_hash differ", "notes": "deterministic fork" },
			  { "from": "staged", "to": "reconciled_unrelated", "on": "reconcile", "guard": "parent_hash differ", "notes": "no merge" },
			  { "from": "validating", "to": "quarantined", "on": "suspicious_but_structural", "guard": "passes DAG/version/origin but other structural anomaly", "notes": "hold for observer diagnostics; no exports" }
			]
		  },
		  "requirements": [
			{ "level": "MUST", "text": "Validate ontology structure before any staging: acyclic DAG, all motif references resolvable, and version formatted as /^\\d{4}-Q[1-4]$/.", "anchor": "RFC-0007 ¬ß2‚Äì¬ß4, ¬ß8" },
			{ "level": "MUST", "text": "Enforce trusted-origin check: bundle.provenance.origin ‚àà trusted_roots and provenance.origin_hash equals the structural seed function defined for Layer_1.", "anchor": "PDP-0001 ¬ß3‚Äì¬ß4" },
			{ "level": "MUST", "text": "Classify reconciliation deterministically: merged iff {parent_hash, integrity_hash} match (when integrity checks are enabled); forked iff parent_hash matches and integrity_hash differs; unrelated otherwise.", "anchor": "RFC-0009 ¬ß6‚Äì¬ß7; RFC-0007 ¬ß2" },
			{ "level": "MUST", "text": "Apply feature-flag gating: emit Sigma_phase only if enable_exchange_envelope=true; emit Delta_hash and verify integrity_hash only if enable_integrity_checks=true; attach provenance on export only if enable_provenance_on_export=true.", "anchor": "RFC-0008 ¬ß2‚Äì¬ß3, ¬ß5; RFC-0009 ¬ß6" },
			{ "level": "MUST", "text": "Operate as observer-only at Layer_1: importing, staging, reconciling, and exporting MUST NOT mutate motif content nor perform control writes to Xi.", "anchor": "PDP-0001 ¬ß3‚Äì¬ß4" },
			{ "level": "SHOULD", "text": "On validation failure after DAG/version/origin pass but with other anomalies, route the bundle to quarantine with full observability and suppressed export.", "anchor": "RFC-0009 ¬ß7; RFC-0005 ¬ß4.2" },
			{ "level": "MAY", "text": "Record read-only provenance events for merge/fork outcomes to support later audit without altering bundle contents.", "anchor": "PDP-0001 ¬ß4" }
		  ],
		  "error_model": [
			{ "code": "E.MMM.310", "when": "ontology DAG invalid or references unresolved", "message": "Ontology validation failed (DAG/references).", "remedy": "Reject bundle; emit dag_invalid_count and near_miss event." },
			{ "code": "E.MMM.311", "when": "version field missing or not /^\\d{4}-Q[1-4]$/", "message": "Invalid ontology version.", "remedy": "Reject bundle; request version normalization." },
			{ "code": "E.MMM.312", "when": "provenance.origin not in trusted_roots or origin_hash mismatch", "message": "Unknown or untrusted origin.", "remedy": "Reject bundle; emit unknown_origin_rate increment." },
			{ "code": "E.MMM.313", "when": "integrity checks enabled and integrity_hash mismatch with payload", "message": "Integrity lineage mismatch.", "remedy": "Reject bundle; emit lineage_rejects and quarantine if policy requires." },
			{ "code": "E.MMM.314", "when": "exchange envelope enabled and Sigma_phase outside accept window", "message": "Phase/replay window violation.", "remedy": "Reject bundle; emit replay_suspect and advise resend within window." }
		  ],
		  "metrics": [
			{ "name": "merge_rate", "unit": "events/tick", "window": "EMA-32", "notes": "Share of reconciliations that produced merged outcome." },
			{ "name": "fork_rate", "unit": "events/tick", "window": "EMA-32", "notes": "Share of reconciliations that produced forked outcome." },
			{ "name": "dag_invalid_count", "unit": "events/tick", "window": "EMA-16", "notes": "Count of ontology DAG validation failures." },
			{ "name": "lineage_rejects", "unit": "events/tick", "window": "EMA-16", "notes": "Rejects due to integrity_hash mismatch when enabled." },
			{ "name": "unknown_origin_rate", "unit": "fraction", "window": "EMA-32", "notes": "Fraction of bundles failing trusted origin checks." },
			{ "name": "bundle_staged_count", "unit": "events/tick", "window": "EMA-32", "notes": "Bundles that passed validation and were staged (observer-only)." },
			{ "name": "envelope_replay_flags", "unit": "events/tick", "window": "EMA-16", "notes": "Sigma_phase window violations when envelope flag is enabled." }
		  ],
		  "pseudocode": [
			{
			  "title": "validate_bundle (Observer)",
			  "anchors": ["validate_bundle"],
			  "rfc_anchors": ["RFC-0007 ¬ß2‚Äì¬ß4, ¬ß8", "PDP-0001 ¬ß3‚Äì¬ß4", "RFC-0008 ¬ß2‚Äì¬ß3", "RFC-0009 ¬ß6"],
			  "code": [
				"def validate_bundle(bundle, trusted_roots, flags):",
				"    if not dag_valid(bundle.ontology): emit('dag_invalid_count'); return {'status': 'rejected'}",
				"    if not regex('^\\\\d{4}-Q[1-4]$', bundle.header.version): emit('version_invalid'); return {'status': 'rejected'}",
				"    if bundle.provenance.origin not in trusted_roots: emit('unknown_origin_rate'); return {'status': 'rejected'}",
				"    if flags.enable_integrity_checks and not delta_hash_consistent(bundle.lineage, bundle):",
				"        emit('lineage_rejects'); return {'status': 'rejected'}",
				"    if flags.enable_exchange_envelope and not phase_window_accept(bundle.header.Sigma_phase):",
				"        emit('envelope_replay_flags'); return {'status': 'rejected'}",
				"    emit('bundle_staged_count'); return {'status': 'staged'}"
			  ]
			},
			{
			  "title": "merge_or_fork (Observer)",
			  "anchors": ["merge_or_fork"],
			  "rfc_anchors": ["RFC-0009 ¬ß6‚Äì¬ß7", "RFC-0007 ¬ß2"],
			  "code": [
				"def merge_or_fork(A, B, flags):",
				"    if A.lineage.parent_hash != B.lineage.parent_hash:",
				"        return {'status': 'unrelated', 'result': None}",
				"    if flags.enable_integrity_checks and A.lineage.integrity_hash == B.lineage.integrity_hash:",
				"        merged = unify_fields(A, B, strategy='latest_timestamp')  # observer summary",
				"        emit('merge_rate'); return {'status': 'merged', 'result': merged}",
				"    else:",
				"        forks = {'A': A.header.id, 'B': B.header.id}",
				"        emit('fork_rate'); return {'status': 'forked', 'result': forks}"
			  ]
			},
			{
			  "title": "export_bundle (Observer, Flag-Gated)",
			  "anchors": ["export_bundle"],
			  "rfc_anchors": ["RFC-0008 ¬ß2‚Äì¬ß3", "RFC-0009 ¬ß6", "PDP-0001 ¬ß3‚Äì¬ß4"],
			  "code": [
				"def export_bundle(bundle, flags):",
				"    pkt = {'payload': bundle}",
				"    if flags.enable_provenance_on_export:",
				"        pkt['provenance'] = { 'origin': bundle.provenance.origin, 'origin_hash': bundle.provenance.origin_hash, 'created_at': bundle.provenance.created_at }",
				"    if flags.enable_exchange_envelope:",
				"        pkt['Sigma_phase'] = compute_phase(bundle)        # structural",
				"    if flags.enable_integrity_checks:",
				"        pkt['Delta_hash'] = compute_delta_hash(bundle)    # structural",
				"    return {'status': 'valid', 'result': pkt}"
			  ]
			}
		  ],
		  "examples": [
			{
			  "title": "Valid bundle staged (observer-only)",
			  "input": {
				"bundle": {
				  "header": { "id": "mob_001", "version": "2025-Q4" },
				  "ontology": { "motifs": ["œà-core@Œû"], "edges": [] },
				  "lineage": { "parent_hash": "h0", "integrity_hash": "h1" },
				  "provenance": { "origin": "agent.alpha", "origin_hash": "s123", "created_at": "2025-10-13T00:00:00Z" }
				},
				"trusted_roots": ["agent.alpha", "agent.beta"],
				"feature_flags": { "enable_exchange_envelope": true, "enable_integrity_checks": true, "enable_provenance_on_export": true }
			  },
			  "output": { "status": "staged", "result": null },
			  "notes": "DAG valid, version matches ^\\d{4}-Q[1-4]$, origin trusted; staged for read-only reconciliation."
			},
			{
			  "title": "Rejected due to DAG cycle",
			  "input": {
				"bundle": {
				  "header": { "id": "mob_bad", "version": "2025-Q4" },
				  "ontology": { "motifs": ["œà-a@Œû","œà-b@Œû"], "edges": [["œà-a@Œû","œà-b@Œû"], ["œà-b@Œû","œà-a@Œû"]] },
				  "lineage": { "parent_hash": "h9", "integrity_hash": "hA" },
				  "provenance": { "origin": "agent.unknown", "origin_hash": "x999", "created_at": "2025-09-01T00:00:00Z" }
				},
				"trusted_roots": ["agent.alpha"],
				"feature_flags": { "enable_exchange_envelope": false, "enable_integrity_checks": false, "enable_provenance_on_export": false }
			  },
			  "output": { "status": "rejected", "result": null },
			  "notes": "Cycle detected and unknown origin; fails RFC-0007 DAG and trusted-origin checks."
			}
		  ]
		},
		{
		  "id": "3.2",
		  "title": "Memory Trace and Logging",
		  "description": "Define Layer_1, observer-only trace-buffer semantics for motif access/recall, promotion/demotion, recovery, capacity, and exchange events. Tracing measures, seals, and routes summaries; it does not perform control writes to Xi. Export of phase/lineage/provenance headers is strictly feature-flag‚Äìgated.",
		  "rfc_anchors": [
			"PDP-0001 ¬ß3‚Äì¬ß4",
			"RFC-0005 ¬ß4.2",
			"RFC-0006 ¬ß1‚Äì¬ß3",
			"RFC-0008 ¬ß5",
			"RFC-0009 ¬ß7, ¬ß9"
		  ],
		  "interfaces": {
			"inputs": [
			  { "name": "entry", "type": "object", "constraints": "ASCII keys; required fields per trace_entry_schema", "notes": "values may include Unicode (e.g., motif_id)" },
			  { "name": "now_tick", "type": "integer", "constraints": "now_tick >= 0", "notes": "monotonic tick index" },
			  { "name": "tau_decay", "type": "integer", "constraints": "tau_decay > 0", "notes": "lawful purge horizon (RFC-0005 ¬ß4.2)" },
			  { "name": "window_size_ticks", "type": "integer", "constraints": "window_size_ticks > 0", "notes": "summary roll-up window" },
			  { "name": "feature_flags", "type": "object<bool>", "constraints": "{enable_exchange_envelope, enable_integrity_checks, enable_provenance_on_export}", "notes": "gates exported headers" }
			],
			"outputs": [
			  { "name": "status", "type": "enum", "constraints": "{ok|staged|exported|purged|rate_limited|rejected}", "notes": "operation result" },
			  { "name": "packet", "type": "object|null", "constraints": "present only for export", "notes": "observer-class summary packet" },
			  { "name": "purged_count", "type": "integer", "constraints": ">= 0", "notes": "number of entries removed by purge_old" },
			  { "name": "summary", "type": "object|null", "constraints": "ASCII keys; KPI fields only", "notes": "roll-up result; no raw payloads" }
			],
			"side_effects": [
			  "observer-only: append to ring buffer",
			  "observer-only: emit telemetry counters and EMAs",
			  "observer-only: rate-limit export attempts"
			]
		  },
		  "state_lifecycle": {
			"states": [
			  "idle",
			  "recording",
			  "rolling_up",
			  "exporting",
			  "purging",
			  "rate_limited"
			],
			"transitions": [
			  { "from": "idle", "to": "recording", "on": "append_trace_entry", "guard": "schema valid", "notes": "validate and record" },
			  { "from": "recording", "to": "purging", "on": "purge_old", "guard": "now_tick - t > tau_decay for some entries", "notes": "lawful forgetting" },
			  { "from": "recording", "to": "rolling_up", "on": "rollup_trace_summary", "guard": "window_size_ticks > 0", "notes": "compute KPIs" },
			  { "from": "rolling_up", "to": "exporting", "on": "export_trace", "guard": "feature flags respected", "notes": "seal summary for SRX" },
			  { "from": "exporting", "to": "rate_limited", "on": "export_qps_exceeded", "guard": "", "notes": "throttle without dropping summary" },
			  { "from": "rate_limited", "to": "idle", "on": "qps_window_reset", "guard": "", "notes": "resume" },
			  { "from": "purging", "to": "idle", "on": "purge_complete", "guard": "", "notes": "return to idle" }
			]
		  },
		  "requirements": [
			{ "level": "MUST", "text": "Operate as observer-only: trace routines SHALL NOT perform control writes to Xi.", "anchor": "PDP-0001 ¬ß3‚Äì¬ß4" },
			{ "level": "MUST", "text": "Maintain a bounded ring buffer; on overflow, drop the oldest entries first.", "anchor": "RFC-0009 ¬ß7" },
			{ "level": "MUST", "text": "Purge entries strictly older than tau_decay ticks.", "anchor": "RFC-0005 ¬ß4.2" },
			{ "level": "MUST", "text": "Export headers obey flag gating: Sigma_phase present iff enable_exchange_envelope=true; Delta_hash present iff enable_integrity_checks=true; provenance attached on export iff enable_provenance_on_export=true.", "anchor": "RFC-0008 ¬ß5; RFC-0009 ¬ß7" },
			{ "level": "MUST", "text": "Trace entry schema includes at least: t, motif_id, C, lambda, gamma_co, rho_res, delta_closure, event, notes?. Event enumerates {access, retrieve, promote, demote, near_miss, reanchor_attempt, reanchor_fail, quarantine_entry, saturation_prune}.", "anchor": "RFC-0006 ¬ß1‚Äì¬ß3; RFC-0009 ¬ß9" },
			{ "level": "SHOULD", "text": "Roll-up summaries compute EMAs for dC and per-event rates and expose band shares for resonance.", "anchor": "RFC-0006 ¬ß3; RFC-0009 ¬ß7" },
			{ "level": "MAY", "text": "Rate-limit export attempts to a configured QPS without dropping already-computed summaries.", "anchor": "RFC-0009 ¬ß7" }
		  ],
		  "error_model": [
			{ "code": "E.MMM.320", "when": "trace entry fails schema validation", "message": "Invalid trace entry schema.", "remedy": "Reject entry; emit schema_error counter; do not mutate buffer." },
			{ "code": "E.MMM.321", "when": "export attempted while over QPS limit", "message": "Export rate limited.", "remedy": "Return status=rate_limited; retry after window reset." },
			{ "code": "E.MMM.322", "when": "packet includes Sigma_phase or Delta_hash while corresponding flags are false", "message": "Flag-gating violation on exported headers.", "remedy": "Strip gated fields; emit gating_violation; return status=rejected if policy strict." },
			{ "code": "E.MMM.323", "when": "purge invoked with non-positive tau_decay", "message": "Invalid purge horizon.", "remedy": "Refuse purge; require tau_decay > 0." }
		  ],
		  "metrics": [
			{ "name": "memory_trace_dC", "unit": "delta_per_tick", "window": "EMA-32", "notes": "Smoothed ŒîC between adjacent ticks in window." },
			{ "name": "reanchor_rate", "unit": "events/tick", "window": "EMA-32", "notes": "EMA of indicator(event=reanchor_attempt)." },
			{ "name": "reanchor_fail_rate", "unit": "events/tick", "window": "EMA-32", "notes": "EMA of indicator(event=reanchor_fail)." },
			{ "name": "quarantine_entry_rate", "unit": "events/tick", "window": "EMA-32", "notes": "EMA of indicator(event=quarantine_entry)." },
			{ "name": "saturation_prune_rate", "unit": "events/tick", "window": "EMA-32", "notes": "EMA of indicator(event=saturation_prune)." },
			{ "name": "rho_res_band_share", "unit": "fraction", "window": "EMA-32", "notes": "Share of entries with 0.3 ‚â§ rho_res ‚â§ 0.7." },
			{ "name": "avg_replay_window_ticks", "unit": "ticks", "window": "EMA-32", "notes": "Average accepted Sigma_phase replay window, when envelope enabled (ref. ¬ß4.1 gating)." }
		  ],
		  "pseudocode": [
			{
			  "title": "append_trace_entry (Observer)",
			  "anchors": ["append_trace_entry"],
			  "rfc_anchors": ["RFC-0006 ¬ß1‚Äì¬ß3", "RFC-0009 ¬ß7"],
			  "code": [
				"def append_trace_entry(entry):",
				"    # Validate ASCII keys and required fields",
				"    if not schema_valid(entry):",
				"        emit('schema_error'); return {'status': 'rejected'}",
				"    with lock():",
				"        ring.push(entry)",
				"        if ring.len() > TRACE_BUFFER_LEN: ring.drop_oldest()",
				"    return {'status': 'ok'}"
			  ]
			},
			{
			  "title": "export_trace (Flag-Gated)",
			  "anchors": ["export_trace"],
			  "rfc_anchors": ["RFC-0008 ¬ß5", "RFC-0009 ¬ß7", "PDP-0001 ¬ß3‚Äì¬ß4"],
			  "code": [
				"def export_trace(summary, flags):",
				"    pkt = {'kind': 'trace_summary', 'body': summary}",
				"    if flags.enable_provenance_on_export:",
				"        pkt['provenance'] = minimal_provenance(summary)",
				"    if flags.enable_exchange_envelope:",
				"        pkt['Sigma_phase'] = compute_phase_checksum(pkt)",
				"    if flags.enable_integrity_checks:",
				"        pkt['Delta_hash'] = compute_lineage_hash(pkt)",
				"    if qps_exceeded(): return {'status': 'rate_limited', 'packet': None}",
				"    return {'status': 'exported', 'packet': pkt}"
			  ]
			}
		  ],
		  "examples": [
			{
			  "title": "Record recovery attempt and roll up",
			  "input": {
				"entry": { "t": 1201, "motif_id": "œà-core@Œû", "C": 0.62, "lambda": 0.08, "gamma_co": 0.03, "rho_res": 0.55, "delta_closure": 0.0, "event": "reanchor_attempt", "notes": "" },
				"window_size_ticks": 128,
				"feature_flags": { "enable_exchange_envelope": true, "enable_integrity_checks": true, "enable_provenance_on_export": false }
			  },
			  "output": { "status": "exported", "packet": { "kind": "trace_summary" } },
			  "notes": "Entry accepted; roll-up computes memory_trace_dC and event EMAs; export attaches Sigma_phase and Delta_hash (provenance omitted by flag)."
			},
			{
			  "title": "Gating violation on export",
			  "input": {
				"summary": { "memory_trace_dC": 0.0, "reanchor_rate": 0.05 },
				"feature_flags": { "enable_exchange_envelope": false, "enable_integrity_checks": false, "enable_provenance_on_export": true }
			  },
			  "output": { "status": "exported", "packet": { "kind": "trace_summary", "provenance": { } } },
			  "notes": "No Sigma_phase or Delta_hash present because flags are false; provenance attached only."
			}
		  ]
		},
		{
		  "id": "3.3",
		  "title": "Glider Handling and Shift-Equivalence Compression",
		  "description": "Define observer-only contracts to (a) detect shift-equivalence classes over validated motifs, (b) choose exactly one canonical representative per class, (c) prevent re-promotion of class members (idempotence), and (d) remap recall to the canonical via inverse shifts. Point-space glider attributes {class,v,phi,tau} are emitted only when enable_point_space_gliders=true.",
		  "rfc_anchors": [
			"PDP-0001 ¬ß3‚Äì¬ß4",
			"RFC-0005 ¬ß3‚Äì¬ß4",
			"RFC-0006 ¬ß3‚Äì¬ß4",
			"RFC-0007 ¬ß2‚Äì¬ß4",
			"RFC-0009 ¬ß5‚Äì¬ß7"
		  ],
		  "interfaces": {
			"inputs": [
			  { "name": "validated_items", "type": "list<motif>", "constraints": "Must pass RFC-0007 DAG/version/provenance checks", "notes": "Observer-only inputs; no control writes" },
			  { "name": "feature_flags", "type": "object<bool>", "constraints": "{enable_point_space_gliders}", "notes": "Gates point-space tags on export" },
			  { "name": "query_item", "type": "motif", "constraints": "Must be encodable under shift operator S", "notes": "For recall mapping" }
			],
			"outputs": [
			  { "name": "status", "type": "enum", "constraints": "{classified|canonicalized|mapped|rejected}", "notes": "Finite outcomes for each routine" },
			  { "name": "class_index", "type": "map<class_key, list<motif_id>>", "constraints": "ASCII keys; values may include Unicode", "notes": "Observer index of equivalence classes" },
			  { "name": "canonical_map", "type": "map<class_key, motif_id>", "constraints": "One representative per class", "notes": "Idempotent selection" },
			  { "name": "recall_mapping", "type": "object", "constraints": "{rep_id, inverse_shift}", "notes": "For recall_via_inverse_shift" }
			],
			"side_effects": [
			  "observer-only: update read-only class_index/canonical_map",
			  "observer-only: emit telemetry and counters"
			]
		  },
		  "state_lifecycle": {
			"states": [
			  "idle",
			  "classifying",
			  "canonicalizing",
			  "indexed",
			  "mapped",
			  "rejected"
			],
			"transitions": [
			  { "from": "idle", "to": "classifying", "on": "detect_shift_equivalence", "guard": "validated_items non-empty", "notes": "Operate on RFC-0007-passed items only" },
			  { "from": "classifying", "to": "canonicalizing", "on": "classes_built", "guard": ">= 1 class", "notes": "Derive class_key via shift-normal forms" },
			  { "from": "canonicalizing", "to": "indexed", "on": "canon_selected", "guard": "exactly one representative per class", "notes": "Idempotent; no re-promotion" },
			  { "from": "indexed", "to": "mapped", "on": "recall_via_inverse_shift", "guard": "query_item encodable", "notes": "Return {rep_id, inverse_shift}" },
			  { "from": "classifying", "to": "rejected", "on": "empty_or_invalid_input", "guard": "", "notes": "Fail fast if no valid items" }
			]
		  },
		  "requirements": [
			{ "level": "MUST", "text": "Operate as observer-only: classification, canonical selection, and recall mapping SHALL NOT perform control writes to Xi.", "anchor": "PDP-0001 ¬ß3‚Äì¬ß4" },
			{ "level": "MUST", "text": "Run ontology validation first; only RFC-0007-valid items participate in equivalence detection and canonicalization.", "anchor": "RFC-0007 ¬ß2‚Äì¬ß4" },
			{ "level": "MUST", "text": "Select exactly one canonical representative per shift-equivalence class using a deterministic order (e.g., lexicographic hash over validated members).", "anchor": "RFC-0006 ¬ß3‚Äì¬ß4" },
			{ "level": "MUST", "text": "Deny re-promotion of any class member once a canonical representative exists.", "anchor": "RFC-0006 ¬ß4; RFC-0005 ¬ß3‚Äì¬ß4" },
			{ "level": "MUST", "text": "Apply compression-by-equivalence before emitting any prune recommendation.", "anchor": "RFC-0006 ¬ß4; RFC-0009 ¬ß5‚Äì¬ß7" },
			{ "level": "SHOULD", "text": "Provide recall via inverse shift from a query item to its class canonical.", "anchor": "RFC-0006 ¬ß3" },
			{ "level": "MUST", "text": "Emit point-space glider tags {class,v,phi,tau} only when enable_point_space_gliders=true.", "anchor": "PDP-0001 ¬ß3" }
		  ],
		  "error_model": [
			{ "code": "E.MMM.330", "when": "validated_items empty or missing", "message": "No items available for classification.", "remedy": "Abort classification; require RFC-0007 validation first." },
			{ "code": "E.MMM.331", "when": "multiple canon candidates tie without deterministic breaker", "message": "Canonicalization tie without rule.", "remedy": "Apply lexicographic hash or configured deterministic tiebreaker; retry." },
			{ "code": "E.MMM.332", "when": "attempt to promote a non-canonical member of an existing class", "message": "Re-promotion denied by idempotence rule.", "remedy": "Return reference to existing canonical; update occurrence refs only." },
			{ "code": "E.MMM.333", "when": "point-space tags present while flag disabled", "message": "Glider tag leakage under disabled flag.", "remedy": "Strip tags; emit gating_violation; proceed without point-space attributes." }
		  ],
		  "metrics": [
			{ "name": "lawful_compression_ratio", "unit": "ratio", "window": "EMA-32", "notes": "Pre-prune: collapsed preimages / total validated intake." },
			{ "name": "equivalence_efficiency", "unit": "ratio", "window": "EMA-16", "notes": "Canonicals / (canonicals + occurrences)." },
			{ "name": "canonical_count", "unit": "count", "window": "EMA-32", "notes": "Number of active class representatives." },
			{ "name": "re_promotion_denied", "unit": "events/tick", "window": "EMA-16", "notes": "Idempotence enforcement incidents (E.MMM.332)." },
			{ "name": "glider_velocity_mean", "unit": "unitless", "window": "EMA-32", "notes": "Only when enable_point_space_gliders=true; omitted otherwise." }
		  ],
		  "pseudocode": [
			{
			  "title": "detect_shift_equivalence (Observer)",
			  "anchors": ["detect_shift_equivalence"],
			  "rfc_anchors": ["RFC-0007 ¬ß2‚Äì¬ß4", "RFC-0006 ¬ß3"],
			  "code": [
				"def detect_shift_equivalence(validated_items):",
				"    if not validated_items: return {'status': 'rejected'}",
				"    class_index = {}  # map<class_key, list<motif_id>>",
				"    for item in validated_items:",
				"        shifts = all_cyclic_shifts(item.encode())",
				"        class_key = min(lex_hash(s) for s in shifts)",
				"        class_index.setdefault(class_key, []).append(item.id)",
				"    return {'status': 'classified', 'class_index': class_index}"
			  ]
			},
			{
			  "title": "select_canonical_and_map (Observer)",
			  "anchors": ["select_and_register_canonical", "recall_via_inverse_shift"],
			  "rfc_anchors": ["RFC-0006 ¬ß3‚Äì¬ß4", "RFC-0005 ¬ß3‚Äì¬ß4"],
			  "code": [
				"def select_canonical_and_map(class_index, query_item=None):",
				"    canonical_map = {}",
				"    for k, members in class_index.items():",
				"        canon = min(members, key=lambda m: lex_hash(encode(m)))  # deterministic",
				"        canonical_map[k] = canon",
				"    result = {'status': 'canonicalized', 'canonical_map': canonical_map}",
				"    if query_item is not None:",
				"        kq = min(lex_hash(s) for s in all_cyclic_shifts(query_item.encode()))",
				"        rep = canonical_map.get(kq)",
				"        inv = compute_inverse_shift(query_item, rep) if rep else None",
				"        result.update({'status': 'mapped' if rep else 'rejected', 'recall_mapping': {'rep_id': rep, 'inverse_shift': inv}})",
				"    return result"
			  ]
			}
		  ],
		  "examples": [
			{
			  "title": "Sequence-only compression (flags OFF)",
			  "input": {
				"validated_items": [
				  { "id": "m1", "seq": "ababa" },
				  { "id": "m2", "seq": "babaa" },
				  { "id": "m3", "seq": "abaab" },
				  { "id": "m4", "seq": "abba" }
				],
				"feature_flags": { "enable_point_space_gliders": false }
			  },
			  "output": {
				"status": "canonicalized",
				"canonical_map": { "class_a": "m1", "class_b": "m4" }
			  },
			  "notes": "m1,m2,m3 collapse to one class; m4 is singleton. No point-space tags emitted."
			},
			{
			  "title": "Glider tags gated (flags ON)",
			  "input": {
				"validated_items": [
				  { "id": "g1", "seq": "0101..." },
				  { "id": "g2", "seq": "1010..." }
				],
				"feature_flags": { "enable_point_space_gliders": true }
			  },
			  "output": {
				"status": "canonicalized",
				"canonical_map": { "class_g": "g1" }
			  },
			  "notes": "Point-space attributes {class,v,phi,tau} MAY be attached on export only when flag is true; core canonicalization remains observer-only."
			}
		  ]
		}
    },

    "4": {
      "id": "4",
	  "title": "Integration, Security, and Recovery Protocols",
		{
		  "id": "4.1",
		  "title": "Exchange and Integrity Integration",
		  "description": "Observer-only contracts for exporting and importing Layer_1 artifacts with routing envelopes (RFC-0008) and structural integrity lineage (RFC-0009). Defines an adaptive acceptance horizon (Delta_tau_phase), a hybrid seen_set replay defense, and structural origin validation via a local trusted root. Checksums (Sigma_phase, Delta_hash) are strictly feature-flag gated. No control writes to Xi.",
		  "rfc_anchors": [
			"PDP-0001 ¬ß3‚Äì¬ß4",
			"RFC-0005 ¬ß3‚Äì¬ß4",
			"RFC-0006 ¬ß3",
			"RFC-0008 ¬ß2‚Äì¬ß3",
			"RFC-0009 ¬ß5‚Äì¬ß7, Appx D"
		  ],
		  "interfaces": {
			"inputs": [
			  { "name": "payload", "type": "object", "constraints": "Serializable, RFC-0007-conformant if ontology bundle", "notes": "Export/import body" },
			  { "name": "provenance", "type": "object", "constraints": "Must include origin, origin_fields, origin_hash (when enabled)", "notes": "Structural provenance only at L1" },
			  { "name": "feature_flags", "type": "object", "constraints": "Boolean keys: enable_exchange_envelope, enable_integrity_checks, enable_provenance_on_export", "notes": "Drives presence/validation of checksums" },
			  { "name": "coherence_C", "type": "number", "constraints": "0 <= C <= 1", "notes": "Recent coherence metric for EMA32" },
			  { "name": "last_Delta_hash", "type": "string|null", "constraints": "Required if enable_integrity_checks=true", "notes": "Lineage chain parent for export" },
			  { "name": "parent_Delta_hash", "type": "string|null", "constraints": "Required if enable_integrity_checks=true", "notes": "Expected parent for import verification" },
			  { "name": "trusted_root_registry", "type": "set<object>", "constraints": "Local structural registry (PDP-0001); non-cryptographic at L1", "notes": "Origins allowed for import/export" },
			  { "name": "now_tick", "type": "integer", "constraints": "Monotonic tick", "notes": "Used for window and replay checks" }
			],
			"outputs": [
			  { "name": "packet", "type": "object", "constraints": "Envelope: {body, provenance, timestamp, valid_until, Sigma_phase?, Delta_hash?}", "notes": "On export only" },
			  { "name": "status", "type": "string", "constraints": "one of {accepted, rejected, skipped, updated}", "notes": "Import/export/registry update result" }
			],
			"side_effects": [
			  "observer-only"
			]
		  },
		  "state_lifecycle": {
			"states": [
			  "Idle",
			  "PreparedEnvelope",
			  "Exported",
			  "ImportedStaged",
			  "Rejected"
			],
			"transitions": [
			  { "from": "Idle", "to": "PreparedEnvelope", "on": "export_request", "guard": "origin in trusted_root_registry", "notes": "Structural provenance pre-check" },
			  { "from": "PreparedEnvelope", "to": "Exported", "on": "flags_ok_and_checksums_applied", "guard": "flag-gated checksum rules satisfied", "notes": "Sigma_phase/Delta_hash added when enabled" },
			  { "from": "Idle", "to": "ImportedStaged", "on": "import_packet", "guard": "within Delta_tau_phase AND origin valid AND checksum/verifications pass", "notes": "Observer staging only" },
			  { "from": "Idle", "to": "Rejected", "on": "import_packet", "guard": "any guard fails OR seen_set replay", "notes": "Deterministic rejection reasons" }
			]
		  },
		  "requirements": [
			{ "level": "MUST", "text": "Honor observer-only posture: no control writes to Xi during export/import/registry update.", "anchor": "PDP-0001 ¬ß4.5" },
			{ "level": "MUST", "text": "Compute Delta_tau_phase = alpha * EMA32(C) and reject imports arriving after valid_until (+ optional skew).", "anchor": "RFC-0008 ¬ß2.2" },
			{ "level": "MUST", "text": "Maintain a hybrid seen_set with a time_window = 2 * Delta_tau_phase and LRU eviction within this window.", "anchor": "RFC-0005 ¬ß3‚Äì¬ß4" },
			{ "level": "MUST", "text": "Validate structural origin: origin in trusted_root_registry AND H(origin_fields) == origin_hash (when provided) BEFORE lineage acceptance.", "anchor": "PDP-0001 ¬ß3‚Äì¬ß4" },
			{ "level": "MUST", "text": "Emit Sigma_phase only when enable_exchange_envelope=true; otherwise Sigma_phase key MUST be absent.", "anchor": "RFC-0008 ¬ß2‚Äì¬ß3" },
			{ "level": "MUST", "text": "Emit Delta_hash only when enable_integrity_checks=true; otherwise Delta_hash key MUST be absent.", "anchor": "RFC-0009 ¬ß5‚Äì¬ß7" },
			{ "level": "MUST", "text": "On import, verify Sigma_phase and Delta_hash exactly when their respective flags are enabled; mismatch causes rejection.", "anchor": "RFC-0008 ¬ß3; RFC-0009 ¬ß6" },
			{ "level": "SHOULD", "text": "If enable_provenance_on_export=true, include origin_hash = H(origin_fields) in the envelope.", "anchor": "PDP-0001 ¬ß3" },
			{ "level": "SHOULD", "text": "Choose alpha in [0.5, 2.0] to keep Delta_tau_phase stable under weak-field coherence.", "anchor": "RFC-0006 ¬ß3; RFC-0009 ¬ß7" },
			{ "level": "MAY", "text": "Apply a small accept_skew_ticks for cross-node clock drift, bounded by the safety case.", "anchor": "RFC-0008 ¬ß2.2" }
		  ],
		  "error_model": [
			{ "code": "E.MMM.flag.checksum_unexpected", "when": "Checksum present while corresponding feature flag is false", "message": "Checksum present but feature flag disabled", "remedy": "Drop field and reject packet" },
			{ "code": "E.MMM.flag.checksum_missing", "when": "Feature flag true but checksum absent", "message": "Required checksum missing", "remedy": "Reject and emit telemetry" },
			{ "code": "E.MMM.integrity.delta_mismatch", "when": "Delta_hash does not match expected parent chain", "message": "Lineage hash mismatch", "remedy": "Reject; request resend from last accepted parent" },
			{ "code": "E.MMM.integrity.sigma_mismatch", "when": "Sigma_phase recomputation fails", "message": "Phase checksum mismatch", "remedy": "Reject as tampered or corrupted" },
			{ "code": "E.MMM.window.expired", "when": "now_tick exceeds packet.valid_until + accept_skew_ticks", "message": "Packet outside acceptance horizon", "remedy": "Reject; advise producer to refresh" },
			{ "code": "E.MMM.origin.unrecognized", "when": "provenance.origin not found in trusted_root_registry", "message": "Unrecognized origin", "remedy": "Reject; update registry if legitimate via governed path" },
			{ "code": "E.MMM.origin.hash_mismatch", "when": "H(origin_fields) != provenance.origin_hash (when provided)", "message": "Origin hash mismatch", "remedy": "Reject; investigate provenance construction" },
			{ "code": "E.MMM.registry.schema_invalid", "when": "Registry update bundle fails structural schema validation", "message": "Registry update invalid at Layer_1", "remedy": "Reject; correct to PDP-0001 schema" },
			{ "code": "E.MMM.replay.duplicate", "when": "seen_set indicates prior arrival within window", "message": "Replay suspect", "remedy": "Drop silently or reject with telemetry" }
		  ],
		  "metrics": [
			{ "name": "export_success_rate", "unit": "events_per_tick", "window": "EMA-32", "notes": "Accepted exports / attempted exports" },
			{ "name": "import_reject_rate", "unit": "events_per_tick", "window": "EMA-32", "notes": "Rejected imports / total imports" },
			{ "name": "unrecognized_seed_count", "unit": "events", "window": "EMA-32", "notes": "Provenance origins not in trusted_root_registry" },
			{ "name": "avg_replay_window_ticks", "unit": "ticks", "window": "EMA-32", "notes": "Average Delta_tau_phase" },
			{ "name": "replay_drop_rate", "unit": "events_per_tick", "window": "EMA-32", "notes": "Drops due to seen_set" },
			{ "name": "seen_set_size", "unit": "count", "window": "EMA-16", "notes": "Current entries in replay window" }
			],
		  "pseudocode": [
			{
			  "title": "export_payload (observer)",
			  "anchors": ["export_payload", "phase_checksum", "hash_lineage"],
			  "rfc_anchors": ["RFC-0008 ¬ß2‚Äì¬ß3", "RFC-0009 ¬ß5‚Äì¬ß7", "PDP-0001 ¬ß4.5"],
			  "code": [
				"def export_payload(payload, provenance, feature_flags, last_Delta_hash, coherence_C, trusted_root):",
				"    if provenance.origin not in trusted_root: return {'status':'rejected','error':'E.MMM.origin.unrecognized'}",
				"    packet = {'body': payload, 'provenance': provenance, 'timestamp': tick_now()}",
				"    if feature_flags.enable_exchange_envelope:",
				"        packet['Sigma_phase'] = phase_checksum(payload, coherence_time_vector())",
				"    if feature_flags.enable_integrity_checks:",
				"        if last_Delta_hash is None: return {'status':'rejected','error':'E.MMM.flag.checksum_missing'}",
				"        packet['Delta_hash'] = hash_lineage(payload, last_Delta_hash)",
				"    if feature_flags.enable_provenance_on_export:",
				"        packet['provenance']['origin_hash'] = H(provenance.origin_fields)",
				"    Delta_tau_phase = alpha() * EMA32(coherence_C)",
				"    packet['valid_until'] = packet['timestamp'] + Delta_tau_phase",
				"    return {'status':'accepted','packet':packet}"
			  ]
			},
			{
			  "title": "import_payload (observer) with hybrid replay defense",
			  "anchors": ["import_payload", "seen_set_replay_defense"],
			  "rfc_anchors": ["RFC-0005 ¬ß3‚Äì¬ß4", "RFC-0008 ¬ß2.2", "RFC-0009 ¬ß6"],
			  "code": [
				"def import_payload(packet, feature_flags, parent_Delta_hash, trusted_root, accept_skew_ticks=0):",
				"    if tick_now() > packet.valid_until + accept_skew_ticks:",
				"        return {'status':'rejected','error':'E.MMM.window.expired'}",
				"    key = compose_key(packet, feature_flags)",
				"    if seen_set.contains(key) and seen_set.within_window(key):",
				"        telemetry('replay_suspect'); return {'status':'rejected','error':'E.MMM.replay.duplicate'}",
				"    if feature_flags.enable_exchange_envelope and not verify_sigma(packet):",
				"        return {'status':'rejected','error':'E.MMM.integrity.sigma_mismatch'}",
				"    if feature_flags.enable_integrity_checks and not verify_delta(packet, parent_Delta_hash):",
				"        return {'status':'rejected','error':'E.MMM.integrity.delta_mismatch'}",
				"    if packet.provenance.origin not in trusted_root: return {'status':'rejected','error':'E.MMM.origin.unrecognized'}",
				"    if 'origin_hash' in packet.provenance and H(packet.provenance.origin_fields) != packet.provenance.origin_hash:",
				"        return {'status':'rejected','error':'E.MMM.origin.hash_mismatch'}",
				"    seen_set.insert(key)",
				"    stage_observer_only(packet.body)",
				"    telemetry('import_accept')",
				"    return {'status':'accepted'}"
			  ]
			}
		  ],
		  "examples": [
			{
			  "title": "flag_gated_checksums",
			  "input": {
				"feature_flags": { "enable_exchange_envelope": true, "enable_integrity_checks": true, "enable_provenance_on_export": true },
				"payload": { "kind": "density_report", "v": 1 },
				"provenance": { "origin": "node:A", "origin_fields": {"id":"A","region":"us-west"} },
				"last_Delta_hash": "abc123",
				"coherence_C": 0.92
			  },
			  "output": {
				"status": "accepted",
				"packet_keys_present": ["Sigma_phase", "Delta_hash", "valid_until", "provenance.origin_hash"]
			  },
			  "notes": "If either checksum flag is false, the corresponding key MUST be absent."
			},
			{
			  "title": "replay_drop_by_seen_set",
			  "input": {
				"feature_flags": { "enable_exchange_envelope": true, "enable_integrity_checks": false },
				"packet_key_fields": { "origin": "node:A", "Sigma_phase": "s1", "bundle_id": "B" }
			  },
			  "output": {
				"status": "rejected",
				"error": "E.MMM.replay.duplicate"
			  },
			  "notes": "Second arrival within 2 * Delta_tau_phase is rejected via seen_set."
			}
		  ]
		},
		{
		  "id": "4.2",
		  "title": "Decay and Recovery Protocols",
		  "description": "Observer-only contracts for lawful decay, bounded recovery, and diagnostic quarantine that restore motif states without control writes. Every recovery episode terminates in exactly one of {reanchored, quarantined, abandoned}. Reanchor attempts are idempotent and overlap-aware via a recovery_token.",
		  "rfc_anchors": [
			"PDP-0001 ¬ß4.5",
			"RFC-0005 ¬ß3‚Äì¬ß4",
			"RFC-0006 ¬ß3‚Äì¬ß4",
			"RFC-0008 ¬ß2.2",
			"RFC-0009 ¬ß5‚Äì¬ß7, ¬ß9‚Äì¬ß10"
		  ],
		  "interfaces": {
			"inputs": [
			  { "name": "snapshot_history", "type": "list<object>", "constraints": "Time-ordered, observer-captured snapshots", "notes": "Used to locate last lawful state" },
			  { "name": "stability", "type": "number", "constraints": "0<=stability<=1", "notes": "Smoothed coherence stability signal for EMA32" },
			  { "name": "violation_rate", "type": "number", "constraints": "0<=violation_rate<=1", "notes": "Recent rate of integrity/coherence violations (EMA16)" },
			  { "name": "rho_res", "type": "number", "constraints": "Band-limited per RFC-0009", "notes": "Resonance indicator for violation checks" },
			  { "name": "RIR", "type": "number", "constraints": "Non-negative", "notes": "Repair/immune response factor" },
			  { "name": "SII", "type": "number", "constraints": "Non-negative", "notes": "Structural integrity index" },
			  { "name": "epsilon", "type": "number", "constraints": "Small bounded noise", "notes": "Perturbation bound for decay and diagnostics" },
			  { "name": "lambda", "type": "number", "constraints": "Reinforcement term", "notes": "Observer-estimated input" },
			  { "name": "gamma_co", "type": "number", "constraints": "Damping term", "notes": "Observer-estimated input" },
			  { "name": "dt", "type": "number", "constraints": "tick units", "notes": "Integration step for decay projection" },
			  { "name": "recovery_token", "type": "string", "constraints": "Opaque, unique per episode", "notes": "Idempotency key; denies reentry with same token" },
			  { "name": "now_tick", "type": "integer", "constraints": "Monotonic tick", "notes": "Used for budgets and TTLs" },
			  { "name": "quarantine_ttl", "type": "integer", "constraints": "ticks>0", "notes": "Max diagnostic duration in quarantine window" }
			],
			"outputs": [
			  { "name": "termination_state", "type": "string", "constraints": "one of {reanchored, quarantined, abandoned}", "notes": "Required terminal label per episode" },
			  { "name": "attempts_used", "type": "integer", "constraints": ">=0", "notes": "Number of reanchor attempts consumed" },
			  { "name": "audit_trail", "type": "list<object>", "constraints": "Append-only events", "notes": "Episode evidence for post-mortem" }
			],
			"side_effects": [
			  "observer-only"
			]
		  },
		  "state_lifecycle": {
			"states": [
			  "Normal",
			  "ViolationDetected",
			  "RecoveryWindow",
			  "ReanchorAttempting",
			  "Quarantined",
			  "Reanchored",
			  "Abandoned"
			],
			"transitions": [
			  { "from": "Normal", "to": "ViolationDetected", "on": "violation_condition", "guard": "|RIR*SII - k_homeostasis|>epsilon OR rho_res out_of_band", "notes": "Open recovery window marker" },
			  { "from": "ViolationDetected", "to": "RecoveryWindow", "on": "window_open", "guard": "episode not active with same recovery_token", "notes": "Idempotent open" },
			  { "from": "RecoveryWindow", "to": "ReanchorAttempting", "on": "budget_available", "guard": "N_max(now_tick)>0", "notes": "Begin bounded attempts" },
			  { "from": "ReanchorAttempting", "to": "Reanchored", "on": "lawful_candidate", "guard": "closure satisfied and resonance in band", "notes": "Terminate success" },
			  { "from": "ReanchorAttempting", "to": "Quarantined", "on": "overlap_or_budget_exhausted", "guard": "window overlap OR attempts==N_max", "notes": "Escalate to diagnostics" },
			  { "from": "Quarantined", "to": "Reanchored", "on": "diagnostic_converges", "guard": "jacobian_norm<=J_max AND closure_improving", "notes": "Mark for reanchor" },
			  { "from": "Quarantined", "to": "Abandoned", "on": "ttl_expired_or_no_progress", "guard": "quarantine_ttl exceeded OR progress fails", "notes": "Terminate safely" }
			]
		  },
		  "requirements": [
			{ "level": "MUST", "text": "Maintain observer-only posture; decay, recovery, and quarantine perform measurement, staging, and routing only; no control writes to Xi.", "anchor": "PDP-0001 ¬ß4.5" },
			{ "level": "MUST", "text": "Each recovery episode terminates in exactly one of {reanchored, quarantined, abandoned} and emits an immutable audit trail.", "anchor": "RFC-0009 ¬ß5.2" },
			{ "level": "MUST", "text": "Reanchor attempts are bounded by N_max = N0 + alpha*EMA32(stability) - beta*EMA16(violation_rate).", "anchor": "RFC-0009 ¬ß5‚Äì¬ß7" },
			{ "level": "MUST", "text": "Reanchor is idempotent and overlap-aware: reuse of the same recovery_token for an active episode is rejected with no side effects.", "anchor": "RFC-0009 ¬ß5.1" },
			{ "level": "MUST", "text": "Escalate to quarantine upon window overlap or budget exhaustion; diagnostics operate under bounded Jacobian norms and track closure improvement before exit.", "anchor": "RFC-0009 ¬ß9‚Äì¬ß10" },
			{ "level": "MUST", "text": "Decay projection clamps C to [0,1] and follows dC/dt = lambda - gamma_co + epsilon.", "anchor": "RFC-0005 ¬ß3‚Äì¬ß4" },
			{ "level": "SHOULD", "text": "Choose alpha in [0.5,2.0] and beta in [0.5,2.0] to prevent oscillatory attempt budgets under weak-field conditions.", "anchor": "RFC-0006 ¬ß3; RFC-0009 ¬ß7" },
			{ "level": "MAY", "text": "Perform micro-perturbation diagnostics in quarantine with perturbation caps that preserve observer safety (no writes).", "anchor": "RFC-0009 ¬ß9.3" }
		  ],
		  "error_model": [
			{ "code": "E.MMM.recovery.token_duplicate", "when": "Recovery invoked with an already-active recovery_token", "message": "Duplicate recovery token denied", "remedy": "Reject reentry; return existing episode handle" },
			{ "code": "E.MMM.recovery.budget_exhausted", "when": "Reanchor attempts reached N_max", "message": "Attempt budget exhausted", "remedy": "Escalate to quarantine" },
			{ "code": "E.MMM.recovery.window_overlap", "when": "Overlapping recovery windows detected", "message": "Overlap detected", "remedy": "Close newest window or escalate to quarantine" },
			{ "code": "E.MMM.decay.inputs_invalid", "when": "Decay inputs out of range or NaN", "message": "Invalid decay parameters", "remedy": "Clamp or drop tick; emit telemetry" },
			{ "code": "E.MMM.quarantine.ttl_expired", "when": "Quarantine exceeded ttl without convergence", "message": "Quarantine TTL expired", "remedy": "Terminate as abandoned with audit event" }
		  ],
		  "metrics": [
			{ "name": "integrity_violation_rate", "unit": "events_per_tick", "window": "EMA-32", "notes": "Rate of violation_condition triggers" },
			{ "name": "reanchor_attempt_rate", "unit": "events_per_tick", "window": "EMA-32", "notes": "Attempts per tick while in ReanchorAttempting" },
			{ "name": "reanchor_success_rate", "unit": "events_per_tick", "window": "EMA-32", "notes": "Successful reanchors per tick" },
			{ "name": "quarantine_count", "unit": "count", "window": "EMA-32", "notes": "Active items under quarantine" },
			{ "name": "recovery_outcome_distribution", "unit": "ratio", "window": "EMA-64", "notes": "Share of {reanchored, quarantined, abandoned}" },
			{ "name": "diagnostic_jacobian_norm", "unit": "unitless", "window": "EMA-16", "notes": "Estimated local Jacobian bound during diagnostics" },
			{ "name": "attempt_budget_N_max", "unit": "count", "window": "EMA-32", "notes": "Observed N_max for active episodes" }
		  ],
		  "pseudocode": [
			{
			  "title": "lawful_decay_step (observer)",
			  "anchors": ["lawful_decay_step"],
			  "rfc_anchors": ["RFC-0005 ¬ß3‚Äì¬ß4"],
			  "code": [
				"def lawful_decay_step(C, lambda_, gamma_co, epsilon, dt):",
				"    dC = lambda_ - gamma_co + epsilon",
				"    C_next = min(1.0, max(0.0, C + dC * dt))",
				"    telemetry('decay_tick', {'C_next': C_next, 'dC': dC})",
				"    return C_next"
			  ]
			},
			{
			  "title": "reanchor_protocol (idempotent, overlap-aware)",
			  "anchors": ["reanchor_protocol"],
			  "rfc_anchors": ["RFC-0009 ¬ß5‚Äì¬ß7"],
			  "code": [
				"def reanchor_protocol(recovery_token, snapshot_history, stability, violation_rate, params):",
				"    if episode_store.active(recovery_token):",
				"        return {'status':'rejected','error':'E.MMM.recovery.token_duplicate','attempts_used':0}",
				"    episode_store.open(recovery_token)",
				"    N_max = params.N0 + params.alpha * EMA32(stability) - params.beta * EMA16(violation_rate)",
				"    N_max = max(1, int(round(N_max)))",
				"    for i in range(1, N_max+1):",
				"        if episode_store.overlap(recovery_token):",
				"            episode_store.mark(recovery_token,'overlap')",
				"            return {'status':'escalate_quarantine','attempts_used':i}",
				"        candidate = last_lawful(snapshot_history, window=params.tau_recovery)",
				"        stage_observer_only(candidate)",
				"        if is_lawful(candidate):",
				"            audit('reanchor_success', {'token': recovery_token, 'i': i})",
				"            episode_store.close(recovery_token)",
				"            return {'status':'reanchored','attempts_used':i}",
				"        audit('reanchor_attempt', {'token': recovery_token, 'i': i})",
				"    episode_store.mark(recovery_token,'budget_exhausted')",
				"    return {'status':'escalate_quarantine','attempts_used':N_max}"
			  ]
			},
			{
			  "title": "quarantine_loop (bounded diagnostics)",
			  "anchors": ["quarantine_loop"],
			  "rfc_anchors": ["RFC-0009 ¬ß9‚Äì¬ß10"],
			  "code": [
				"def quarantine_loop(quarantine_set, ttl, J_max, perturbation_cap):",
				"    t0 = tick_now()",
				"    while tick_now() - t0 < ttl:",
				"        progress = False",
				"        for motif in quarantine_set:",
				"            micro = bounded_perturbation(perturbation_cap)  # measurement-class simulation",
				"            J = jacobian_estimate(motif, window='EMA-16')",
				"            if closure_improving(motif, micro) and J <= J_max:",
				"                telemetry('diagnostic_pass', {'motif': id(motif)})",
				"                mark_for_reanchor(motif)",
				"                progress = True",
				"            else:",
				"                telemetry('diagnostic_retry', {'motif': id(motif)})",
				"        if progress:",
				"            return {'status':'recovery_ready'}",
				"    return {'status':'hold_quarantine'}"
			  ]
			}
		  ],
		  "examples": [
			{
			  "title": "deterministic_termination_states",
			  "input": {
				"stability": 0.9,
				"violation_rate": 0.1,
				"snapshot_history": ["..."],
				"recovery_token": "tok-123",
				"params": { "N0": 1, "alpha": 1.0, "beta": 1.0, "tau_recovery": 100 }
			  },
			  "output": {
				"possible": [
				  { "condition": "lawful candidate within N_max", "termination_state": "reanchored" },
				  { "condition": "budget exhausted or overlap; diagnostics not converged yet", "termination_state": "quarantined" },
				  { "condition": "ttl expired without progress", "termination_state": "abandoned" }
				]
			  },
			  "notes": "All outcomes emit an append-only audit trail."
			},
			{
			  "title": "idempotent_reentry_denied",
			  "input": {
				"recovery_token": "tok-123",
				"episode_already_active": true
			  },
			  "output": {
				"status": "rejected",
				"error": "E.MMM.recovery.token_duplicate"
			  },
			  "notes": "Prevents duplicate work and crash loops."
			}
		  ]
		},
		{
		  "id": "4.3",
		  "title": "Security and Data Handling (L1 posture)",
		  "description": "Layer_1 states structural security guarantees for exchange, staging, and at-rest handling. Validation is structural only: origin membership in the local trusted root, envelope policy compliance, and declared signature-type profile checks. Cryptography, keystores, RBAC/consent, remote trust, and persistence bindings are deferred to Layer_2.",
		  "rfc_anchors": [
			"PDP-0001 ¬ß3.1, ¬ß4.4‚Äì¬ß4.5",
			"RFC-0005 ¬ß4.2",
			"RFC-0007 ¬ß5‚Äì¬ß6, ¬ß8",
			"RFC-0008 ¬ß2.1, ¬ß5‚Äì¬ß6",
			"RFC-0009 ¬ß5.1, ¬ß7.2, ¬ß9.3; Appx D.4"
		  ],
		  "interfaces": {
			"inputs": [
			  { "name": "packet", "type": "object", "constraints": "SRX-like envelope shape per ¬ß4.1; may include Sigma_phase?, Delta_hash?", "notes": "Inbound artifact for structural checks" },
			  { "name": "feature_flags", "type": "object", "constraints": "enable_exchange_envelope, enable_integrity_checks (booleans)", "notes": "Gates checksum presence/verification" },
			  { "name": "agent_registry", "type": "map<string,object>", "constraints": "agent_id ‚Üí {allowed_sig_types:[string]}", "notes": "Local structural profile registry" },
			  { "name": "trusted_root_registry", "type": "set<object>", "constraints": "Origins authorized at Layer_1 (structural, non-cryptographic)", "notes": "See PDP-0001" },
			  { "name": "bundle", "type": "object", "constraints": "If at-rest handling; must include storage_profile{profile,retention_ticks}", "notes": "Ontology or report bundle" },
			  { "name": "tau_decay", "type": "integer", "constraints": "ticks>0", "notes": "Retention floor derived from lawful decay (RFC-0005 ¬ß4.2)" }
			],
			"outputs": [
			  { "name": "status", "type": "string", "constraints": "one of {accepted, rejected, quarantined, noop, expire, retain}", "notes": "Decision/result per operation" },
			  { "name": "reason", "type": "string", "constraints": "machine-readable reason key", "notes": "Returned on rejection/branching" }
			],
			"side_effects": [
			  "observer-only"
			]
		  },
		  "state_lifecycle": {
			"states": [
			  "Idle",
			  "EnvelopeChecked",
			  "OriginChecked",
			  "PolicyChecked",
			  "AcceptedStaged",
			  "Rejected",
			  "Quarantined"
			],
			"transitions": [
			  { "from": "Idle", "to": "EnvelopeChecked", "on": "packet_received", "guard": "packet shape present", "notes": "Begin structural checks" },
			  { "from": "EnvelopeChecked", "to": "Rejected", "on": "checksum_required_missing", "guard": "flag requires checksum but absent", "notes": "See ¬ß4.1 gating" },
			  { "from": "EnvelopeChecked", "to": "OriginChecked", "on": "checksums_ok_or_not_required", "guard": "gating satisfied", "notes": "" },
			  { "from": "OriginChecked", "to": "Rejected", "on": "unrecognized_seed_or_origin_hash_mismatch", "guard": "origin ‚àâ trusted_root OR H(origin_fields)‚â†origin_hash", "notes": "" },
			  { "from": "OriginChecked", "to": "PolicyChecked", "on": "seed_ok", "guard": "origin recognized", "notes": "" },
			  { "from": "PolicyChecked", "to": "Rejected", "on": "illegal_sig_type_or_wrapped_unsigned", "guard": "sig_type not allowed OR envelope claims signed without signature_block", "notes": "Confused-deputy defense" },
			  { "from": "PolicyChecked", "to": "AcceptedStaged", "on": "structurally_valid", "guard": "all checks passed", "notes": "Observer staging only" },
			  { "from": "Rejected", "to": "Quarantined", "on": "staging_policy_route", "guard": "deployment chooses quarantine for analysis", "notes": "No control writes" }
			]
		  },
		  "requirements": [
			{ "level": "MUST", "text": "Maintain observer-only posture: validation, staging, routing only; no control writes to Xi.", "anchor": "PDP-0001 ¬ß4.5" },
			{ "level": "MUST", "text": "Enforce checksum gating: Sigma_phase present iff enable_exchange_envelope=true; Delta_hash present iff enable_integrity_checks=true; otherwise keys MUST be absent.", "anchor": "RFC-0008 ¬ß5‚Äì¬ß6; RFC-0009 Appx D.4" },
			{ "level": "MUST", "text": "Validate structural origin: provenance.origin ‚àà trusted_root_registry AND H(origin_fields) == origin_hash (when provided) before any acceptance.", "anchor": "PDP-0001 ¬ß3.1, ¬ß4.4" },
			{ "level": "MUST", "text": "Validate envelope.sig_type by structural profile only: sig_type ‚àà agent_registry[provenance.origin.agent_id].allowed_sig_types.", "anchor": "RFC-0008 ¬ß5‚Äì¬ß6" },
			{ "level": "MUST", "text": "Reject wrapped-unsigned: if envelope claims a signed origin but signature_block is null/empty/stub, the packet is rejected.", "anchor": "RFC-0008 ¬ß5‚Äì¬ß6" },
			{ "level": "MUST", "text": "At-rest handling requires declared storage_profile.profile ‚àà {volatile, durable} and retention_ticks ‚â• tau_decay.", "anchor": "RFC-0005 ¬ß4.2" },
			{ "level": "SHOULD", "text": "Persist provenance {origin, origin_hash, created_at} and lineage {parent_hash, integrity_hash} blocks only after passing structural checks.", "anchor": "RFC-0007 ¬ß5‚Äì¬ß6; RFC-0009 Appx D.4" },
			{ "level": "MAY", "text": "Route structurally suspicious packets to quarantine staging with diagnostic telemetry rather than drop-only handling.", "anchor": "RFC-0009 ¬ß9.3" }
		  ],
		  "error_model": [
			{ "code": "E.MMM.flag.missing_sigma", "when": "enable_exchange_envelope=true but Sigma_phase absent", "message": "Required Sigma_phase missing", "remedy": "Reject; increment import_reject_missing_checksum" },
			{ "code": "E.MMM.flag.missing_delta", "when": "enable_integrity_checks=true but Delta_hash absent", "message": "Required Delta_hash missing", "remedy": "Reject; increment import_reject_missing_checksum" },
			{ "code": "E.MMM.origin.unrecognized", "when": "provenance.origin not in trusted_root_registry", "message": "Unrecognized origin seed", "remedy": "Reject; consider quarantine staging" },
			{ "code": "E.MMM.origin.hash_mismatch", "when": "H(origin_fields) != origin_hash", "message": "Origin hash mismatch", "remedy": "Reject; investigate provenance construction" },
			{ "code": "E.MMM.policy.illegal_sig_type", "when": "envelope.sig_type not allowed for origin agent_id", "message": "Illegal signature-type declaration", "remedy": "Reject; increment illegal_sig_type_rate" },
			{ "code": "E.MMM.policy.wrapped_unsigned", "when": "Envelope claims signed but signature_block missing/empty/stub", "message": "Wrapped unsigned payload", "remedy": "Reject; increment wrapped_unsigned_rejects" }
		  ],
		  "metrics": [
			{ "name": "illegal_sig_type_rate", "unit": "events_per_tick", "window": "EMA-32", "notes": "Rejections due to disallowed envelope.sig_type" },
			{ "name": "wrapped_unsigned_rejects", "unit": "events", "window": "EMA-32", "notes": "Count of rejected wrapped-unsigned attempts (confused-deputy defense)" },
			{ "name": "import_reject_missing_checksum", "unit": "events_per_tick", "window": "EMA-32", "notes": "Rejections for missing Sigma_phase/Delta_hash when required" },
			{ "name": "staging_quarantine_count", "unit": "events", "window": "EMA-32", "notes": "Packets routed to quarantine after structural policy failures" },
			{ "name": "at_rest_expirations", "unit": "events", "window": "EMA-32", "notes": "Bundles expired by retention policy (tau_decay floor)" }
		  ],
		  "pseudocode": [
			{
			  "title": "validate_envelope_and_origin (structural only)",
			  "anchors": ["validate_envelope_and_origin"],
			  "rfc_anchors": ["RFC-0008 ¬ß5‚Äì¬ß6", "PDP-0001 ¬ß3.1, ¬ß4.4"],
			  "code": [
				"def validate_envelope_and_origin(packet, feature_flags, agent_registry, trusted_root):",
				"    if feature_flags.enable_exchange_envelope and 'Sigma_phase' not in packet: return {'status':'rejected','reason':'E.MMM.flag.missing_sigma'}",
				"    if feature_flags.enable_integrity_checks and 'Delta_hash' not in packet: return {'status':'rejected','reason':'E.MMM.flag.missing_delta'}",
				"    prov = packet.get('provenance', {})",
				"    if prov.get('origin') not in trusted_root: return {'status':'rejected','reason':'E.MMM.origin.unrecognized'}",
				"    if 'origin_hash' in prov and H(prov.get('origin_fields')) != prov['origin_hash']:",
				"        return {'status':'rejected','reason':'E.MMM.origin.hash_mismatch'}",
				"    agent_id = prov.get('agent_id')",
				"    allowed = set(agent_registry.get(agent_id, {}).get('allowed_sig_types', []))",
				"    sig_type = packet.get('envelope', {}).get('sig_type')",
				"    if sig_type not in allowed: return {'status':'rejected','reason':'E.MMM.policy.illegal_sig_type'}",
				"    return {'status':'accepted','reason':'structurally_valid'}"
			  ]
			},
			{
			  "title": "reject_wrapped_unsigned (confused-deputy defense)",
			  "anchors": ["reject_wrapped_unsigned"],
			  "rfc_anchors": ["RFC-0008 ¬ß5‚Äì¬ß6"],
			  "code": [
				"def reject_wrapped_unsigned(packet):",
				"    env = packet.get('envelope', {})",
				"    claims_signed = bool(env.get('claims_signed'))",
				"    sig_block = packet.get('signature_block')",
				"    if claims_signed and (sig_block is None or sig_block == '' or sig_block == 'stub'):",
				"        return {'status':'rejected','reason':'E.MMM.policy.wrapped_unsigned'}",
				"    return {'status':'noop'}"
			  ]
			},
			{
			  "title": "enforce_retention_policy (at-rest)",
			  "anchors": ["enforce_retention_policy"],
			  "rfc_anchors": ["RFC-0005 ¬ß4.2", "RFC-0009 Appx D.4"],
			  "code": [
				"def enforce_retention_policy(bundle, tau_decay, now_tick):",
				"    prof = bundle.setdefault('storage_profile', {})",
				"    if prof.get('profile') not in {'volatile','durable'}: return {'status':'rejected','reason':'E.MMM.policy.invalid_storage_profile'}",
				"    prof['retention_ticks'] = max(int(prof.get('retention_ticks', 0)), int(tau_decay))",
				"    expiry = bundle.get('timestamp', 0) + prof['retention_ticks']",
				"    return {'status':'expire' if now_tick > expiry else 'retain'}"
			  ]
			}
		  ],
		  "examples": [
			{
			  "title": "wrapped_unsigned_rejection",
			  "input": {
				"packet": {
				  "envelope": { "claims_signed": true, "sig_type": "rsa_pss" },
				  "signature_block": null,
				  "provenance": { "origin": "node:A", "agent_id": "agent:A", "origin_fields": {"id":"A"}, "origin_hash": "H({id:A})" }
				},
				"feature_flags": { "enable_exchange_envelope": true, "enable_integrity_checks": true },
				"agent_registry": { "agent:A": { "allowed_sig_types": ["rsa_pss","eddsa"] } },
				"trusted_root_registry": ["node:A"]
			  },
			  "output": { "status": "rejected", "reason": "E.MMM.policy.wrapped_unsigned" },
			  "notes": "Confused-deputy defense: structural claim of signing without a signature block is rejected at Layer_1."
			},
			{
			  "title": "illegal_signature_type",
			  "input": {
				"packet": {
				  "envelope": { "claims_signed": true, "sig_type": "es256k" },
				  "signature_block": "stub", 
				  "provenance": { "origin": "node:B", "agent_id": "agent:B", "origin_fields": {"id":"B"}, "origin_hash": "H({id:B})" }
				},
				"feature_flags": { "enable_exchange_envelope": true, "enable_integrity_checks": false },
				"agent_registry": { "agent:B": { "allowed_sig_types": ["rsa_pss"] } },
				"trusted_root_registry": ["node:B"]
			  },
			  "output": { "status": "rejected", "reason": "E.MMM.policy.illegal_sig_type" },
			  "notes": "Layer_1 checks only the declared sig_type membership in the local profile; cryptographic proof is deferred to Layer_2."
			},
			{
			  "title": "retention_floor_enforced",
			  "input": {
				"bundle": { "timestamp": 1000, "storage_profile": { "profile": "durable", "retention_ticks": 50 } },
				"tau_decay": 120,
				"now_tick": 1105
			  },
			  "output": { "status": "retain" },
			  "notes": "Retention floor set to tau_decay; bundle will expire at t=1120."
			}
		  ]
		}
	},

    "5": {
      "id": "5",
	  "title": "Observability, Ethics, and Policy",
		{
		  "id": "5.1",
		  "title": "Observability and Metrics",
		  "description": "Defines the WHAT for MMM observability: inputs, outputs, lifecycle, testable requirements, error model, and KPI catalog for measuring coherence, resonance, capacity, decay ethics, recovery activity, exchange timing, and (flag-gated) glider flow. Layer_1 remains observer-only; sealing fields are emitted strictly under feature flags.",
		  "rfc_anchors": [
			"PDP-0001 ¬ß4.4‚Äì¬ß4.5",
			"RFC-0005 ¬ß3‚Äì¬ß4",
			"RFC-0006 ¬ß3‚Äì¬ß4",
			"RFC-0008 ¬ß2‚Äì¬ß3; ¬ß5.3",
			"RFC-0009 ¬ß7.1‚Äì¬ß9.3; Appx D.4"
		  ],
		  "interfaces": {
			"inputs": [
			  {
				"name": "trace_entries_window",
				"type": "list<TraceEntry>",
				"constraints": "Bounded by chosen EMA window; entries expose {C, rho_res, event, idle_time, timestamp}.",
				"notes": "Source of coherence/resonance/health signals; observer-only."
			  },
			  {
				"name": "stmm_ltmm_events",
				"type": "list<Event>",
				"constraints": "Events in {'promote','reanchor_attempt','reanchor_fail','quarantine_entry'}.",
				"notes": "Used to compute rates and recovery gauges."
			  },
			  {
				"name": "capacity",
				"type": "object",
				"constraints": "Contains {C_max: >0, LTMM_usage: >=0}.",
				"notes": "Feeds saturation_level = LTMM_usage / C_max."
			  },
			  {
				"name": "replay_params",
				"type": "object",
				"constraints": "Contains {Delta_tau_phase: >=0} or enough to derive it.",
				"notes": "Defines adaptive acceptance window for exchange timing KPIs."
			  },
			  {
				"name": "feature_flags",
				"type": "object",
				"constraints": "Booleans {enable_exchange_envelope, enable_integrity_checks, enable_provenance_on_export, enable_point_space_gliders}.",
				"notes": "Strict gating for checksum and glider gauges."
			  },
			  {
				"name": "provenance",
				"type": "object",
				"constraints": "ASCII keys; structure per PDP-0001.",
				"notes": "Included only when exporting metrics with provenance enabled."
			  }
			],
			"outputs": [
			  {
				"name": "metrics_snapshot",
				"type": "object",
				"constraints": "ASCII keys; values within declared ranges; windows limited to {EMA-16, EMA-32, EMA-64}.",
				"notes": "Point-in-time rollup suitable for dashboards."
			  },
			  {
				"name": "metrics_packet",
				"type": "object",
				"constraints": "Present only when export is requested; includes optional Sigma_phase and Delta_hash per flags.",
				"notes": "Observer envelope for SRX routing; no control writes."
			  }
			],
			"side_effects": [
			  "observer-only"
			]
		  },
		  "state_lifecycle": {
			"states": [
			  "observing",
			  "rolling_up",
			  "sealed_ready",
			  "exported"
			],
			"transitions": [
			  {
				"from": "observing",
				"to": "rolling_up",
				"on": "tick",
				"guard": "trace_entries_window not empty",
				"notes": "Roll up means/rates within EMA windows."
			  },
			  {
				"from": "rolling_up",
				"to": "sealed_ready",
				"on": "snapshot_computed",
				"guard": "ASCII key validation passes AND feature gating checks pass",
				"notes": "No Sigma_phase/Delta_hash unless enabled."
			  },
			  {
				"from": "sealed_ready",
				"to": "exported",
				"on": "export_requested",
				"guard": "If enable_exchange_envelope=true then include Sigma_phase; if enable_integrity_checks=true then include Delta_hash; otherwise omit.",
				"notes": "Any rate limiting/backoff is enforced in Layer_2."
			  },
			  {
				"from": "sealed_ready",
				"to": "observing",
				"on": "no_export",
				"guard": "n/a",
				"notes": "Keep local snapshot and continue."
			  }
			]
		  },
		  "requirements": [
			{
			  "level": "MUST",
			  "text": "Operate in observer-only posture: measurement, sealing, and routing only; no control writes.",
			  "anchor": "PDP-0001 ¬ß4.5"
			},
			{
			  "level": "MUST",
			  "text": "Emit metrics using EMA windows limited to {EMA-16, EMA-32, EMA-64}. Means default to EMA-64; rates default to EMA-32 unless stated.",
			  "anchor": "RFC-0009 ¬ß7.1‚Äì¬ß7.3"
			},
			{
			  "level": "MUST",
			  "text": "Compute lawful_compression_ratio and equivalence_efficiency strictly before any prune recommendation.",
			  "anchor": "RFC-0006 ¬ß4; RFC-0009 ¬ß7"
			},
			{
			  "level": "MUST",
			  "text": "Honor ethical TTL floor in all retention KPIs: TTL_floor = max(tau_decay, 10 * delta_t_tick).",
			  "anchor": "RFC-0005 ¬ß4; RFC-0009 ¬ß7"
			},
			{
			  "level": "MUST",
			  "text": "Gate Sigma_phase on enable_exchange_envelope and Delta_hash on enable_integrity_checks. Do not emit stub fields when disabled.",
			  "anchor": "RFC-0008 ¬ß5.3; RFC-0009 Appx D.4"
			},
			{
			  "level": "MUST",
			  "text": "Emit glider-related gauges only when enable_point_space_gliders=true.",
			  "anchor": "RFC-0006 ¬ß3‚Äì¬ß4"
			},
			{
			  "level": "MUST",
			  "text": "Use ASCII keys for all exported objects; Unicode is allowed only inside free-text values.",
			  "anchor": "PDP-0001 ¬ß4.4"
			},
			{
			  "level": "SHOULD",
			  "text": "Derive avg_replay_window_ticks from Delta_tau_phase and report it for exchange timing diagnostics.",
			  "anchor": "RFC-0008 ¬ß2‚Äì¬ß3"
			},
			{
			  "level": "SHOULD",
			  "text": "Annotate each metric with unit and EMA window and keep ranges within declared bounds.",
			  "anchor": "RFC-0009 ¬ß7.2"
			},
			{
			  "level": "MAY",
			  "text": "Include provenance.origin_hash in metrics_packet when enable_provenance_on_export=true.",
			  "anchor": "PDP-0001 ¬ß4.4"
			}
		  ],
		  "error_model": [
			{
			  "code": "E.MMM.ASCII.001",
			  "when": "Non-ASCII key detected in metrics_snapshot or metrics_packet.",
			  "message": "ASCII-only keys required at Layer_1.",
			  "remedy": "Normalize keys to ASCII or drop offending fields."
			},
			{
			  "code": "E.MMM.WINDOW.002",
			  "when": "Metric computed with a window not in {EMA-16, EMA-32, EMA-64}.",
			  "message": "Invalid EMA window.",
			  "remedy": "Recompute using an allowed window."
			},
			{
			  "code": "E.MMM.GATE.003",
			  "when": "Checksum fields emitted while corresponding flags are disabled.",
			  "message": "Checksum gating violation.",
			  "remedy": "Remove Sigma_phase/Delta_hash or enable flags explicitly."
			},
			{
			  "code": "E.MMM.GLIDER.004",
			  "when": "Glider gauges emitted but glider feature flag is disabled.",
			  "message": "Glider gauge gating violation.",
			  "remedy": "Disable glider gauges or enable feature flag."
			},
			{
			  "code": "E.MMM.REQ.005",
			  "when": "Required KPI (compression or TTL floor) omitted from snapshot.",
			  "message": "Missing required KPI.",
			  "remedy": "Compute lawful_compression_ratio, equivalence_efficiency, and TTL floor metrics before export."
			},
			{
			  "code": "E.MMM.EXPORT.006",
			  "when": "Export attempted without a sealed_ready snapshot.",
			  "message": "Export precondition not met.",
			  "remedy": "Produce a valid snapshot and reattempt export."
			}
		  ],
		  "metrics": [
			{ "name": "rfc0009_Q_coh", "unit": "dimensionless", "window": "EMA-64", "notes": "Mean coherence level C; range [0,1]." },
			{ "name": "rfc0009_Q_res", "unit": "dimensionless", "window": "EMA-64", "notes": "Mean resonance coefficient rho_res; range [0,1]." },
			{ "name": "rho_res_band_share", "unit": "fraction", "window": "EMA-32", "notes": "Share of entries with rho_res in [0.3,0.7]; range [0,1]." },
			{ "name": "lawful_compression_ratio", "unit": "dimensionless", "window": "EMA-32", "notes": "post_equiv_count / pre_equiv_count; pre-prune only; range [0,1]." },
			{ "name": "equivalence_efficiency", "unit": "fraction", "window": "EMA-32", "notes": "(pre - post) / pre; pre-prune only; range [0,1]." },
			{ "name": "ethical_ttl_floor", "unit": "ticks", "window": "EMA-16", "notes": "TTL_floor = max(tau_decay, 10*delta_t_tick); range [0,+inf)." },
			{ "name": "ttl_max_effective", "unit": "ticks", "window": "EMA-16", "notes": "Configured maximum retention horizon; range [0,+inf)." },
			{ "name": "staleness_index", "unit": "fraction", "window": "EMA-32", "notes": "Share nearing decay by idle_time; range [0,1]." },
			{ "name": "saturation_level", "unit": "fraction", "window": "EMA-32", "notes": "LTMM_usage / C_max; range [0,1]." },
			{ "name": "memory_promotion_rate", "unit": "events/tick", "window": "EMA-32", "notes": "STMM‚ÜíLTMM promotions per tick; range [0,1]." },
			{ "name": "reanchor_rate", "unit": "events/tick", "window": "EMA-32", "notes": "Rate of reanchor_attempt events; range [0,1]." },
			{ "name": "reanchor_fail_rate", "unit": "events/tick", "window": "EMA-32", "notes": "Rate of reanchor_fail events; range [0,1]." },
			{ "name": "quarantine_entry_rate", "unit": "events/tick", "window": "EMA-32", "notes": "Rate of quarantine_entry events; range [0,1]." },
			{ "name": "quarantine_count", "unit": "sets", "window": "EMA-32", "notes": "Number of motif sets currently quarantined; range [0,+inf)." },
			{ "name": "avg_replay_window_ticks", "unit": "ticks", "window": "EMA-32", "notes": "Observed average Delta_tau_phase; range [0,+inf)." },
			{ "name": "gamma_co", "unit": "1/tick", "window": "EMA-64", "notes": "Adaptive damping estimate from coherence law; range [0,+inf)." },
			{ "name": "glider_detected", "unit": "count", "window": "EMA-16", "notes": "Flag-gated; count of glider detection events." },
			{ "name": "glider_canonical_count", "unit": "count", "window": "EMA-16", "notes": "Flag-gated; number of canonical glider representatives." }
		  ],
		  "pseudocode": [
			{
			  "title": "Compute Compression KPIs (pre-prune snapshot)",
			  "anchors": ["compute_compression_kpis"],
			  "rfc_anchors": ["RFC-0006 ¬ß4", "RFC-0009 ¬ß7"],
			  "code": [
				"def compute_compression_kpis(pre_equiv_count, post_equiv_count):",
				"    if pre_equiv_count <= 0:",
				"        return {'lawful_compression_ratio': 1.0, 'equivalence_efficiency': 0.0}",
				"    lcr = post_equiv_count / pre_equiv_count",
				"    ee  = (pre_equiv_count - post_equiv_count) / pre_equiv_count",
				"    return {'lawful_compression_ratio': lcr, 'equivalence_efficiency': ee}"
			  ]
			},
			{
			  "title": "Roll Up Observability Window",
			  "anchors": ["rollup_observability_window"],
			  "rfc_anchors": ["RFC-0008 ¬ß2‚Äì¬ß3", "RFC-0009 ¬ß7.1‚Äì¬ß7.3"],
			  "code": [
				"def rollup_observability_window(entries, events, capacity, flags, Delta_tau_phase):",
				"    Q_coh = EMA64(mean(e.C for e in entries))",
				"    Q_res = EMA64(mean(e.rho_res for e in entries))",
				"    band  = EMA32(frac(e for e in entries if 0.3 <= e.rho_res <= 0.7))",
				"    eta   = EMA32(capacity.LTMM_usage / capacity.C_max)",
				"    pr    = EMA32(rate(events, kind='promote'))",
				"    rr    = EMA32(rate(events, kind='reanchor_attempt'))",
				"    rrf   = EMA32(rate(events, kind='reanchor_fail'))",
				"    qer   = EMA32(rate(events, kind='quarantine_entry'))",
				"    qc    = EMA32(current_quarantine_sets())",
				"    avg_rw= EMA32(Delta_tau_phase)",
				"    gauges = {'rfc0009_Q_coh':Q_coh,'rfc0009_Q_res':Q_res,'rho_res_band_share':band,'saturation_level':eta,",
				"              'memory_promotion_rate':pr,'reanchor_rate':rr,'reanchor_fail_rate':rrf,",
				"              'quarantine_entry_rate':qer,'quarantine_count':qc,'avg_replay_window_ticks':avg_rw}",
				"    if flags.enable_point_space_gliders:",
				"        gauges.update({'glider_detected': EMA16(rate(events,'glider_detected')),",
				"                       'glider_canonical_count': EMA16(size(glider_index()))})",
				"    return gauges"
			  ]
			}
		  ],
		  "examples": [
			{
			  "title": "Snapshot and Export (flags ON)",
			  "input": {
				"trace_entries_window": "[...]",
				"stmm_ltmm_events": "[promote, reanchor_attempt, reanchor_fail, quarantine_entry]",
				"capacity": {"C_max": 1000, "LTMM_usage": 700},
				"replay_params": {"Delta_tau_phase": 16},
				"feature_flags": {
				  "enable_exchange_envelope": true,
				  "enable_integrity_checks": true,
				  "enable_provenance_on_export": true,
				  "enable_point_space_gliders": true
				},
				"provenance": {"origin": "observer.MMM", "session": "abc123"}
			  },
			  "output": {
				"metrics_snapshot": {
				  "rfc0009_Q_coh": 0.62,
				  "rfc0009_Q_res": 0.55,
				  "rho_res_band_share": 0.60,
				  "lawful_compression_ratio": 0.80,
				  "equivalence_efficiency": 0.20,
				  "ethical_ttl_floor": 100,
				  "ttl_max_effective": 1000,
				  "staleness_index": 0.12,
				  "saturation_level": 0.70,
				  "memory_promotion_rate": 0.03,
				  "reanchor_rate": 0.01,
				  "reanchor_fail_rate": 0.002,
				  "quarantine_entry_rate": 0.001,
				  "quarantine_count": 2,
				  "avg_replay_window_ticks": 16,
				  "gamma_co": 0.05,
				  "glider_detected": 3,
				  "glider_canonical_count": 1
				},
				"metrics_packet": {
				  "kind": "metrics",
				  "version": "2025-Q4",
				  "body": "{metrics_snapshot}",
				  "provenance": {"origin": "observer.MMM", "origin_hash": "H(...)"},
				  "Sigma_phase": "phase_checksum(...)",
				  "Delta_hash": "hash_lineage(...)"
				}
			  },
			  "notes": "Checksum and glider gauges present because all flags are enabled."
			},
			{
			  "title": "Snapshot Only (flags OFF)",
			  "input": {
				"trace_entries_window": "[...]",
				"stmm_ltmm_events": "[promote]",
				"capacity": {"C_max": 1000, "LTMM_usage": 300},
				"replay_params": {"Delta_tau_phase": 8},
				"feature_flags": {
				  "enable_exchange_envelope": false,
				  "enable_integrity_checks": false,
				  "enable_provenance_on_export": false,
				  "enable_point_space_gliders": false
				}
			  },
			  "output": {
				"metrics_snapshot": {
				  "rfc0009_Q_coh": 0.71,
				  "rfc0009_Q_res": 0.66,
				  "rho_res_band_share": 0.64,
				  "lawful_compression_ratio": 0.90,
				  "equivalence_efficiency": 0.10,
				  "ethical_ttl_floor": 100,
				  "ttl_max_effective": 1000,
				  "staleness_index": 0.05,
				  "saturation_level": 0.30,
				  "memory_promotion_rate": 0.02,
				  "reanchor_rate": 0.00,
				  "reanchor_fail_rate": 0.00,
				  "quarantine_entry_rate": 0.00,
				  "quarantine_count": 0,
				  "avg_replay_window_ticks": 8,
				  "gamma_co": 0.04
				}
			  },
			  "notes": "No Sigma_phase, no Delta_hash, and no glider gauges because flags are disabled."
			}
		  ]
		},
		{
		  "id": "5.2",
		  "title": "Ethics and Data Retention Policy",
		  "description": "Defines the WHAT for ethical retention in MMM: observer-only posture, decay-as-forgetting (not deletion), TTL floor contracts, provenance-and-lineage validation for resurrection, and sealed export fields gated strictly by feature flags.",
		  "rfc_anchors": [
			"PDP-0001 ¬ß4.4‚Äì¬ß4.5",
			"RFC-0005 ¬ß3‚Äì¬ß4.2",
			"RFC-0007 ¬ß5‚Äì¬ß6; ¬ß8",
			"RFC-0008 ¬ß5.3",
			"RFC-0009 ¬ß7; Appx D.4"
		  ],
		  "interfaces": {
			"inputs": [
			  {
				"name": "bundle",
				"type": "object",
				"constraints": "Contains {storage_profile:{retention_ticks>=0}, timestamp}. ASCII keys.",
				"notes": "Observed metadata only; no writes by this section."
			  },
			  {
				"name": "now_tick",
				"type": "integer",
				"constraints": "now_tick>=0",
				"notes": "Current scheduler tick for retention evaluation."
			  },
			  {
				"name": "tau_decay",
				"type": "integer",
				"constraints": "tau_decay>=0",
				"notes": "Decay horizon derived upstream from signals; used as ethical baseline."
			  },
			  {
				"name": "delta_t_tick",
				"type": "integer",
				"constraints": "delta_t_tick>0",
				"notes": "System tick interval used in TTL floor bound."
			  },
			  {
				"name": "feature_flags",
				"type": "object",
				"constraints": "Booleans {enable_exchange_envelope, enable_integrity_checks, enable_provenance_on_export}.",
				"notes": "Strict gating for sealed export fields."
			  },
			  {
				"name": "resurrection_request",
				"type": "object",
				"constraints": "If present, includes {provenance:{origin,origin_hash?,created_at}, lineage:{parent_hash?,integrity_hash?,schema}}.",
				"notes": "Validated prior to any acceptance."
			  },
			  {
				"name": "parent_Delta_hash",
				"type": "string",
				"constraints": "ASCII; optional unless integrity checks enabled.",
				"notes": "Expected chain head when validating resurrection lineage."
			  },
			  {
				"name": "payload_for_export",
				"type": "object",
				"constraints": "ASCII keys; metrics or bundles to seal structurally.",
				"notes": "Used only when an export is requested."
			  },
			  {
				"name": "provenance",
				"type": "object",
				"constraints": "ASCII keys; structure per PDP-0001.",
				"notes": "Included on export when provenance feature is enabled."
			  },
			  {
				"name": "T_mu",
				"type": "integer",
				"constraints": "T_mu>=0",
				"notes": "Phase epoch for checksum when exchange envelope is enabled."
			  },
			  {
				"name": "last_Delta_hash",
				"type": "string",
				"constraints": "ASCII; optional unless integrity checks enabled.",
				"notes": "Lineage tail for chained integrity hashing."
			  }
			],
			"outputs": [
			  {
				"name": "policy_decision",
				"type": "object",
				"constraints": "ASCII keys; action‚àà{'retain','expire'}; includes {retention_ticks_effective, reasons[]}.",
				"notes": "Observer-only result for downstream enforcement in Layer_2."
			  },
			  {
				"name": "resurrection_status",
				"type": "object",
				"constraints": "status‚àà{'accepted','rejected'}; reasons[] if rejected.",
				"notes": "Outcome of provenance/lineage validation."
			  },
			  {
				"name": "export_packet",
				"type": "object",
				"constraints": "Present only when export requested; includes {body, provenance?} and flag-gated {Sigma_phase?, Delta_hash?}.",
				"notes": "Sealed structurally; no cryptographic claims at Layer_1."
			  }
			],
			"side_effects": [
			  "observer-only"
			]
		  },
		  "state_lifecycle": {
			"states": [
			  "idle",
			  "evaluating_retention",
			  "validating_resurrection",
			  "sealing_export"
			],
			"transitions": [
			  {
				"from": "idle",
				"to": "evaluating_retention",
				"on": "tick",
				"guard": "bundle present",
				"notes": "Compute effective TTL floor and decision."
			  },
			  {
				"from": "evaluating_retention",
				"to": "validating_resurrection",
				"on": "resurrection_request_present",
				"guard": "n/a",
				"notes": "Validate provenance and lineage consecutively."
			  },
			  {
				"from": "validating_resurrection",
				"to": "sealing_export",
				"on": "export_requested",
				"guard": "If flags enabled, attach gated fields; otherwise omit.",
				"notes": "Sealing is structural; routing is handled later."
			  },
			  {
				"from": "sealing_export",
				"to": "idle",
				"on": "done",
				"guard": "n/a",
				"notes": "Observer loop continues."
			  }
			]
		  },
		  "requirements": [
			{
			  "level": "MUST",
			  "text": "Maintain observer-only posture: measurement, staging, sealing, and routing only; no control writes.",
			  "anchor": "PDP-0001 ¬ß4.5"
			},
			{
			  "level": "MUST",
			  "text": "Apply ethical TTL floor: retention_ticks_effective = max(tau_decay, 10 * delta_t_tick) when evaluating expiry.",
			  "anchor": "RFC-0005 ¬ß4.2; RFC-0009 ¬ß7"
			},
			{
			  "level": "MUST",
			  "text": "Prefer decay-as-forgetting over deletion: expiry decisions are time-based and reversible only via lawful resurrection.",
			  "anchor": "RFC-0005 ¬ß3‚Äì¬ß4"
			},
			{
			  "level": "MUST",
			  "text": "Accept resurrection only with validated provenance and continuous lineage; when enable_integrity_checks=true, require Delta_hash chain continuity and parent match.",
			  "anchor": "RFC-0007 ¬ß5‚Äì¬ß6; RFC-0009 Appx D.4"
			},
			{
			  "level": "MUST",
			  "text": "Emit Sigma_phase only when enable_exchange_envelope=true and Delta_hash only when enable_integrity_checks=true; never emit stub fields when disabled.",
			  "anchor": "RFC-0008 ¬ß5.3; RFC-0009 Appx D.4"
			},
			{
			  "level": "MUST",
			  "text": "Use ASCII keys in all outputs and sealed packets; Unicode allowed only within free-text values.",
			  "anchor": "PDP-0001 ¬ß4.4"
			},
			{
			  "level": "SHOULD",
			  "text": "Include provenance.origin_hash in export_packet when enable_provenance_on_export=true.",
			  "anchor": "PDP-0001 ¬ß4.4"
			},
			{
			  "level": "SHOULD",
			  "text": "Reject resurrection if ontology DAG constraints or references are invalid or cyclic.",
			  "anchor": "RFC-0007 ¬ß8"
			}
		  ],
		  "error_model": [
			{
			  "code": "E.MMM.ASCII.001",
			  "when": "Non-ASCII key detected in outputs or export_packet.",
			  "message": "ASCII-only keys required at Layer_1.",
			  "remedy": "Normalize keys to ASCII or drop offending fields."
			},
			{
			  "code": "E.MMM.TTL.101",
			  "when": "Retention evaluated below ethical floor.",
			  "message": "TTL floor violation.",
			  "remedy": "Recompute retention_ticks_effective = max(tau_decay, 10 * delta_t_tick)."
			},
			{
			  "code": "E.MMM.LINEAGE.201",
			  "when": "Resurrection request missing provenance or lineage fields.",
			  "message": "Incomplete resurrection metadata.",
			  "remedy": "Provide required provenance and lineage per RFC-0007 and retry."
			},
			{
			  "code": "E.MMM.LINEAGE.202",
			  "when": "Computed integrity_hash does not match submitted lineage.integrity_hash.",
			  "message": "Integrity mismatch.",
			  "remedy": "Correct the payload or lineage record; revalidate."
			},
			{
			  "code": "E.MMM.LINEAGE.203",
			  "when": "parent_hash does not match parent_Delta_hash when integrity checks enabled.",
			  "message": "Lineage parent mismatch.",
			  "remedy": "Repair chain or disable integrity checks (not recommended)."
			},
			{
			  "code": "E.MMM.LINEAGE.204",
			  "when": "Ontology references are cyclic or point to unknown motifs.",
			  "message": "Ontology DAG invalid.",
			  "remedy": "Fix references to satisfy RFC-0007 DAG constraints."
			},
			{
			  "code": "E.MMM.GATE.003",
			  "when": "Checksum fields emitted while the corresponding flags are disabled.",
			  "message": "Checksum gating violation.",
			  "remedy": "Remove gated fields or enable features explicitly."
			},
			{
			  "code": "E.MMM.OBSV.401",
			  "when": "A control write is attempted by this section.",
			  "message": "Observer-only violation.",
			  "remedy": "Route any writes to Layer_2 components; keep Layer_1 read/validate/seal only."
			},
			{
			  "code": "E.MMM.PROV.402",
			  "when": "Export attempted with enable_provenance_on_export=true but provenance missing required fields.",
			  "message": "Export provenance insufficient.",
			  "remedy": "Attach provenance per PDP-0001 or disable feature flag."
			}
		  ],
		  "metrics": [
			{ "name": "retention_expirations", "unit": "events/tick", "window": "EMA-32", "notes": "Rate of bundles expired by ethical policy." },
			{ "name": "resurrection_rejects_lineage", "unit": "events/tick", "window": "EMA-32", "notes": "Rejections due to missing/invalid provenance or lineage." },
			{ "name": "ttl_policy_violations", "unit": "events/tick", "window": "EMA-16", "notes": "Attempts to set retention below ethical TTL floor." },
			{ "name": "observer_write_attempts", "unit": "events/tick", "window": "EMA-16", "notes": "Incidents where a control write was attempted by observer components (should be zero)." }
		  ],
		  "pseudocode": [
			{
			  "title": "Evaluate Ethical Retention (observer-only)",
			  "anchors": ["evaluate_retention_policy"],
			  "rfc_anchors": ["RFC-0005 ¬ß4.2", "RFC-0009 ¬ß7"],
			  "code": [
				"def evaluate_retention_policy(bundle, now_tick, tau_decay, delta_t_tick):",
				"    ttl_floor = max(tau_decay, 10 * delta_t_tick)",
				"    r_eff = max(bundle.storage_profile.retention_ticks, ttl_floor)",
				"    will_expire = (bundle.timestamp + r_eff) < now_tick",
				"    action = 'expire' if will_expire else 'retain'",
				"    reasons = []",
				"    if r_eff > bundle.storage_profile.retention_ticks:",
				"        reasons.append('ttl_floor_applied')",
				"    return {'action': action, 'retention_ticks_effective': r_eff, 'reasons': reasons}"
			  ]
			},
			{
			  "title": "Validate Resurrection Lineage",
			  "anchors": ["validate_resurrection_lineage"],
			  "rfc_anchors": ["RFC-0007 ¬ß5‚Äì¬ß6; ¬ß8", "RFC-0009 Appx D.4"],
			  "code": [
				"def validate_resurrection_lineage(req, flags, parent_Delta_hash):",
				"    need = ('provenance' in req and 'lineage' in req)",
				"    if not need: return {'status':'rejected','reasons':['missing_fields']}",
				"    ok_hash = (H(req['meta_and_data']) == req['lineage'].get('integrity_hash'))",
				"    if not ok_hash: return {'status':'rejected','reasons':['integrity_mismatch']}",
				"    if flags.enable_integrity_checks:",
				"        if req['lineage'].get('parent_hash') != parent_Delta_hash:",
				"            return {'status':'rejected','reasons':['parent_mismatch']}",
				"    if not ontology_dag_valid(req):",
				"        return {'status':'rejected','reasons':['ontology_dag_invalid']}",
				"    return {'status':'accepted'}"
			  ]
			},
			{
			  "title": "Seal Export Ethically (flag-gated)",
			  "anchors": ["seal_export_ethically"],
			  "rfc_anchors": ["RFC-0008 ¬ß5.3", "PDP-0001 ¬ß4.4"],
			  "code": [
				"def seal_export_ethically(payload, provenance, last_Delta_hash, T_mu, flags):",
				"    packet = {'body': payload}",
				"    if flags.enable_provenance_on_export:",
				"        packet['provenance'] = dict(provenance)",
				"        packet['provenance']['origin_hash'] = H(provenance)",
				"    if flags.enable_exchange_envelope:",
				"        packet['Sigma_phase'] = phase_checksum(packet['body'], T_mu)",
				"    if flags.enable_integrity_checks:",
				"        packet['Delta_hash'] = hash_lineage(packet['body'], last_Delta_hash)",
				"    return packet"
			  ]
			}
		  ],
		  "examples": [
			{
			  "title": "Retention decision with TTL floor applied",
			  "input": {
				"bundle": { "storage_profile": { "retention_ticks": 8 }, "timestamp": 1000 },
				"now_tick": 1115,
				"tau_decay": 12,
				"delta_t_tick": 1
			  },
			  "output": {
				"policy_decision": { "action": "expire", "retention_ticks_effective": 12, "reasons": ["ttl_floor_applied"] }
			  },
			  "notes": "TTL floor max(12,10) = 12; timestamp+12=1012 < now_tick ‚Üí expire."
			},
			{
			  "title": "Resurrection rejected due to lineage mismatch",
			  "input": {
				"resurrection_request": {
				  "provenance": { "origin": "observer.MMM", "created_at": "2025-10-13T00:00:00Z" },
				  "lineage": { "parent_hash": "abc", "integrity_hash": "bad" },
				  "meta_and_data": "{...}"
				},
				"feature_flags": { "enable_integrity_checks": true },
				"parent_Delta_hash": "xyz"
			  },
			  "output": {
				"resurrection_status": { "status": "rejected", "reasons": ["integrity_mismatch", "parent_mismatch"] }
			  },
			  "notes": "Hash mismatch and parent mismatch both detected when integrity checks are enabled."
			},
			{
			  "title": "Export sealed with gated fields",
			  "input": {
				"payload_for_export": { "kind": "metrics", "version": "2025-Q4", "body": "{...}" },
				"provenance": { "origin": "observer.MMM", "session": "s1" },
				"last_Delta_hash": "p123",
				"T_mu": 4096,
				"feature_flags": {
				  "enable_exchange_envelope": true,
				  "enable_integrity_checks": true,
				  "enable_provenance_on_export": true
				}
			  },
			  "output": {
				"export_packet": {
				  "body": { "kind": "metrics", "version": "2025-Q4", "body": "{...}" },
				  "provenance": { "origin": "observer.MMM", "session": "s1", "origin_hash": "H(...)" },
				  "Sigma_phase": "phase_checksum(...)",
				  "Delta_hash": "hash_lineage(...)"
				}
			  },
			  "notes": "All gated fields emitted because corresponding flags are true."
			}
		  ]
		}
    },

    "appendix": {
	 {
	  "appendix": "A",
	  "title": "Worked Examples & Mathematical Supplement",
	  "objective": "Provide lintable, Layer_1‚Äìconformant worked examples that instantiate MMM contracts (capacity-first ordering, equivalence compression, replay defense, lineage validation, bounded recovery) with ASCII-only keys on-wire. Math identities are referenced, not proved.",
	  "schema": {
		"appendix_types": ["diagrammatic", "worked_example", "reference_table", "pseudocode_index"],
		"common_keys": ["id", "title", "type", "objective", "rfc_anchors", "feature_flags?", "notes?"],
		"worked_example_keys": ["algorithms", "invariants", "example_json", "telemetry", "bindings?"],
		"diagrammatic_keys": ["diagram_format", "diagram"],
		"reference_table_keys": ["schema_version", "data", "validation_rules"],
		"pseudocode_index_keys": ["blocks"]
	  },
	  "sections": [
		{
		  "id": "A.0",
		  "title": "Conventions, Lint, and Feature Flags",
		  "type": "reference_table",
		  "objective": "Establish appendix-wide rules (ASCII keys, EMA windows, flag gating) and the JSON lint checks used by fixtures.",
		  "data": {
			"ascii_keys_only": true,
			"allowed_windows": ["EMA-16", "EMA-32", "EMA-64"],
			"flag_rules": {
			  "enable_exchange_envelope": "controls presence of Sigma_phase",
			  "enable_integrity_checks": "controls presence of Delta_hash",
			  "enable_point_space_gliders": "controls presence of {class,v,phi,tau} glider fields"
			}
		  },
		  "validation_rules": [
			"no unicode outside 'latex' strings",
			"metrics.window ‚àà {EMA-16,EMA-32,EMA-64}",
			"flag-gated fields appear iff enabled"
		  ],
		  "lint": {
			"checks": [
			  {
				"id": "LINT.ASCII_KEYS",
				"description": "All JSON object keys must be ASCII.",
				"selector": "$..*",
				"test": "for each object: all(keys.match(/^[\\x00-\\x7F]+$/))",
				"on_fail": "reject fixture; emit ascii_key_normalization_events metric once per response"
			  },
			  {
				"id": "LINT.LATEX_ONLY_UNICODE",
				"description": "Unicode characters allowed only inside values of fields named 'latex'.",
				"selector": "$..*",
				"test": "for each string value v: if field_name!='latex' then v.match(/^[\\x00-\\x7F]*$/)",
				"on_fail": "reject fixture; annotate path"
			  },
			  {
				"id": "LINT.METRIC_WINDOW_SET",
				"description": "Metric windows must be in the allowed set.",
				"selector": "$..metrics[*].window,$..telemetry[*].window,$..bindings[*].window",
				"test": "value ‚àà {'EMA-16','EMA-32','EMA-64'}",
				"on_fail": "reject metric; suggest nearest allowed window"
			  },
			  {
				"id": "LINT.FLAG_GATING_EXCHANGE",
				"description": "Sigma_phase must exist only when enable_exchange_envelope=true.",
				"selector": "$..*",
				"test": "if payload has Sigma_phase then feature_flags.enable_exchange_envelope===true",
				"on_fail": "reject payload; remove Sigma_phase or enable flag"
			  },
			  {
				"id": "LINT.FLAG_GATING_INTEGRITY",
				"description": "Delta_hash must exist only when enable_integrity_checks=true.",
				"selector": "$..*",
				"test": "if payload has Delta_hash then feature_flags.enable_integrity_checks===true",
				"on_fail": "reject payload; remove Delta_hash or enable flag"
			  },
			  {
				"id": "LINT.FLAG_GATING_GLIDERS",
				"description": "Glider fields {class,v,phi,tau} must exist only when enable_point_space_gliders=true.",
				"selector": "$..*",
				"test": "if any of {class,v,phi,tau} present then feature_flags.enable_point_space_gliders===true",
				"on_fail": "reject payload; strip glider fields or enable flag"
			  }
			],
			"suggested_metrics": [
			  { "name": "ascii_key_normalization_events", "unit": "count", "window": "EMA-32", "notes": "Emit once per response when any key required normalization." },
			  { "name": "appendix_fixture_lint_failures", "unit": "count", "window": "EMA-32", "notes": "Total failed lint checks per validation run." },
			  { "name": "appendix_fixture_lint_pass_rate", "unit": "fraction", "window": "EMA-32", "notes": "Passes / (passes + failures)." }
			],
			"examples": {
			  "pass": {
				"feature_flags": {
				  "enable_exchange_envelope": true,
				  "enable_integrity_checks": false,
				  "enable_point_space_gliders": false
				},
				"metrics": [
				  { "metric": "lawful_compression_ratio", "window": "EMA-32" }
				],
				"envelope": { "Sigma_phase": "phase:2025-10-10T00:00:00Z" },
				"notes": "Delta_hash absent because integrity flag is false; all keys ASCII."
			  },
			  "fail": [
				{
				  "reason": "non-ASCII key",
				  "bad_fixture": { "m√©tric": "equivalence_efficiency", "window": "EMA-16" },
				  "violations": ["LINT.ASCII_KEYS"]
				},
				{
				  "reason": "unicode outside latex",
				  "bad_fixture": { "title": "coherence ‚Üí ok", "latex": "C = 1" },
				  "violations": ["LINT.LATEX_ONLY_UNICODE"]
				},
				{
				  "reason": "flag-gated field present while flag=false",
				  "bad_fixture": {
					"feature_flags": { "enable_integrity_checks": false },
					"envelope": { "Delta_hash": "sha256:abcd" }
				  },
				  "violations": ["LINT.FLAG_GATING_INTEGRITY"]
				}
			  ]
			}
		  },
		  "notes": [
			"Appendix fixtures are observer-only: they measure, seal, route, validate, and emit telemetry; they do not perform control writes.",
			"When a flag is disabled, its gated fields MUST be entirely absent from fixtures, telemetry, and schemas (not null, not empty strings).",
			"All examples must be ready for automated linting and dashboard binding without manual edits."
		  ],
		  "rfc_anchors": ["PDP-0001 ¬ß3‚Äì¬ß4.5", "RFC-0008 ¬ß2", "RFC-0009 Appx D.4"]
		},

		{
		  "id": "A.1",
		  "title": "Mathematical Identities (Reference Index)",
		  "type": "reference_table",
		  "objective": "Index the equations used by all worked examples in Appendix A. Each identity is normative for variable naming and KPI computation but omits derivation details (Layer_0 governs proofs).",
		  "data": [
			{
			  "eq_id": "A.0",
			  "role": "governing_law",
			  "latex": "\\frac{d\\mathcal{C}}{dt} = \\lambda - (\\gamma_{co}+\\gamma_{stale}) + \\varepsilon",
			  "gloss": "Core coherence evolution: reinforcement minus adaptive and staleness damping plus small perturbation."
			},
			{
			  "eq_id": "A.1",
			  "role": "decay_horizon",
			  "latex": "\\tau_{decay} = \\zeta^{-1}",
			  "gloss": "Retention horizon derived from damping slope Œ∂."
			},
			{
			  "eq_id": "A.2a",
			  "role": "ethical_floor_def",
			  "latex": "TTL_{floor} = \\max(\\tau_{decay},\\;10\\,\\Delta t_{tick})",
			  "gloss": "Ethical minimum retention floor combining decay and tick-based duration."
			},
			{
			  "eq_id": "A.2b",
			  "role": "retention_bound",
			  "latex": "TTL_{floor} \\leq TTL \\leq TTL_{max}(t)",
			  "gloss": "Lawful retention must lie between the ethical floor and policy-dependent maximum."
			},
			{
			  "eq_id": "A.3",
			  "role": "phase_window",
			  "latex": "\\Delta\\tau_{phase} = \\alpha\\,EMA_{32}(\\mathcal{C})\\,,\\; \\alpha\\in[0.5,2.0]",
			  "gloss": "Adaptive replay or acceptance window scaled by coherence EMA."
			},
			{
			  "eq_id": "A.3b",
			  "role": "replay_seen_set_window",
			  "latex": "Window_{seen\\_set} = 2\\,\\Delta\\tau_{phase}",
			  "gloss": "Hybrid replay window: seen_set time horizon equals twice the phase window."
			},
			{
			  "eq_id": "A.4",
			  "role": "compression_ratio",
			  "latex": "LCR = \\frac{\\text{post\\_equiv\\_count}}{\\text{pre\\_equiv\\_count}}",
			  "gloss": "Lawful compression ratio ‚Äî post-equivalence divided by pre-equivalence entry count."
			},
			{
			  "eq_id": "A.5",
			  "role": "equivalence_efficiency",
			  "latex": "1 - LCR",
			  "gloss": "Capacity relief fraction gained from equivalence compression (inverse of LCR)."
			}
		  ],
		  "invariants": [
			{
			  "name": "Layer_0_Governs_Proofs",
			  "condition": "No derivation steps appear here; all equations trace to RFC-0005‚Äì0009.",
			  "source": "PDP-0001 ¬ß3.2 (Layer abstraction contract)"
			},
			{
			  "name": "ASCII_On_Wire",
			  "condition": "All keys ASCII; unicode limited to latex strings.",
			  "source": "Appendix A.0 rule set"
			},
			{
			  "name": "EMA_Window_Restriction",
			  "condition": "EMA operators limited to {EMA-16, EMA-32, EMA-64}. Default for ŒîœÑ_phase is EMA-32.",
			  "source": "Appendix A.0 validation rules"
			}
		  ],
		  "examples": {
			"lawful_compression_example": {
			  "pre_equiv_count": 200,
			  "post_equiv_count": 140,
			  "LCR": 0.7,
			  "eff_eq": 0.3,
			  "notes": "Matches A.4 and A.5 definitions; pre-prune snapshot only."
			},
			"ttl_floor_example": {
			  "tau_decay": 240,
			  "Delta_t_tick": 12,
			  "TTL_floor": 240,
			  "TTL_max": 360,
			  "lawful_range": "[240, 360]"
			}
		  },
		  "rfc_anchors": ["RFC-0005 ¬ß4", "RFC-0006 ¬ß3‚Äì¬ß4", "RFC-0009 ¬ß7"],
		  "handoff": "Mathematical primitives indexed; next sections instantiate them through observer-class algorithms and telemetry."
		},

		{
		  "id": "A.2",
		  "title": "Capacity-First Saturation Handling",
		  "type": "worked_example",
		  "objective": "Show promotion gating ‚Üí equivalence compression snapshot (pre-prune KPIs) ‚Üí conditional prune.",
		  "rfc_anchors": ["RFC-0006 ¬ß4.4", "RFC-0009 ¬ß7.1", "RFC-0005 ¬ß4.2"],
		  "algorithms": [
			{
			  "name": "promotion_gating",
			  "role": "observer",
			  "inputs": ["C", "occupancy", "theta_promote_cap", "lambda_thresh", "delta_closure_max", "rho_res"],
			  "outputs": ["promotion_allowed"],
			  "params": ["window='EMA-32'", "rho_band=[0.3,0.7]"],
			  "steps": [
				"1. c_bar <- EMA(window, C).",
				"2. cap_gate <- (occupancy < theta_promote_cap).",
				"3. band_gate <- (rho_res >= rho_band[0] AND rho_res <= rho_band[1]).",
				"4. closure_gate <- (delta_closure_max is not exceeded).",
				"5. rate_gate <- (c_bar >= lambda_thresh).",
				"6. promotion_allowed <- cap_gate AND band_gate AND closure_gate AND rate_gate.",
				"7. return promotion_allowed."
			  ]
			},
			{
			  "name": "equivalence_compression_snapshot",
			  "role": "observer",
			  "inputs": ["pre_equiv_count"],
			  "outputs": ["post_equiv_count", "lawful_compression_ratio", "equivalence_efficiency"],
			  "params": [],
			  "steps": [
				"1. Map entries to shift-equivalence classes (no prune).",
				"2. post_equiv_count <- count(unique canonical representatives).",
				"3. if pre_equiv_count == 0: lawful_compression_ratio <- 1.0; equivalence_efficiency <- 0.0; return.",
				"4. lawful_compression_ratio <- post_equiv_count / pre_equiv_count.",
				"5. equivalence_efficiency <- 1 - lawful_compression_ratio.",
				"6. Emit snapshot to telemetry; proceed to saturation check."
			  ]
			},
			{
			  "name": "conditional_prune_if_still_saturated",
			  "role": "observer",
			  "inputs": ["occupancy_post_equiv", "theta_sat", "theta_prune"],
			  "outputs": ["prune_decision"],
			  "params": [],
			  "steps": [
				"1. if occupancy_post_equiv < theta_sat: prune_decision <- false; return.",
				"2. if occupancy_post_equiv >= theta_prune: prune_decision <- true; else prune_decision <- false.",
				"3. Record prune_decision and, if true, emit prune_events++."
			  ]
			}
		  ],
		  "invariants": [
			{
			  "name": "Compress_Before_Prune",
			  "condition": "Shift-equivalence compression MUST be performed and snapshotted prior to any pruning.",
			  "source": "RFC-0006 ¬ß4.4; RFC-0009 ¬ß7.1"
			},
			{
			  "name": "Observer_Only",
			  "condition": "All steps are measurement/validation/telemetry; no control writes to Xi.",
			  "source": "PDP-0001 ¬ß4.5"
			},
			{
			  "name": "ASCII_On_Wire",
			  "condition": "All JSON keys are ASCII; math symbols appear only within latex strings in A.1.",
			  "source": "Appendix A.0"
			},
			{
			  "name": "EMA_Window_Restriction",
			  "condition": "EMA windows limited to {EMA-16, EMA-32, EMA-64}.",
			  "source": "Appendix A.0"
			}
		  ],
		  "example_json": {
			"window": "EMA-32",
			"theta_promote_cap": 0.75,
			"theta_sat": 0.80,
			"theta_prune": 0.90,
			"inputs": {
			  "occupancy_before": 0.91,
			  "pre_equiv_count": 200,
			  "C": 0.72,
			  "lambda_thresh": 0.18,
			  "delta_closure_max": 0.02,
			  "rho_res": 0.55
			},
			"snapshot": {
			  "post_equiv_count": 140,
			  "lawful_compression_ratio": 0.70,
			  "equivalence_efficiency": 0.30
			},
			"post_equiv": {
			  "occupancy_post_equiv": 0.78,
			  "promotion_allowed": true,
			  "prune_decision": false
			},
			"notes": "Occupancy dropped below Œ∏_sat after equivalence compression; no prune executed. KPIs recorded strictly pre-prune."
		  },
		  "telemetry": [
			{ "metric": "saturation_level", "unit": "fraction", "window": "EMA-32", "notes": "Proportion of LTMM capacity currently occupied." },
			{ "metric": "lawful_compression_ratio", "unit": "dimensionless", "window": "EMA-32", "notes": "post_equiv_count / pre_equiv_count measured pre-prune." },
			{ "metric": "equivalence_efficiency", "unit": "fraction", "window": "EMA-32", "notes": "1 - lawful_compression_ratio." },
			{ "metric": "prune_events", "unit": "count", "window": "EMA-32", "notes": "Incremented only when prune_decision=true." }
		  ],
		  "bindings": [
			{ "dashboard": "memory/homeostasis", "series": ["saturation_level", "lawful_compression_ratio", "equivalence_efficiency"], "window": "EMA-32" }
		  ],
		  "notes": [
			"Promotion gating prevents capacity-negative promotions during pressure.",
			"Equivalence compression uses canonical representatives; counts are captured before any destructive step.",
			"Pruning is conditional and only follows a failed post-equivalence saturation check."
		  ],
		  "handoff": "Capacity contract demonstrated; next example isolates KPI computation paths for pre-prune snapshots."
		},

		{
		  "id": "A.3",
		  "title": "Compression KPI Snapshot (Pre-Prune)",
		  "type": "worked_example",
		  "objective": "Compute lawful_compression_ratio and equivalence_efficiency strictly pre-prune; export EMA-bound KPIs.",
		  "rfc_anchors": ["RFC-0006 ¬ß4.4", "RFC-0009 ¬ß7.2"],
		  "math_refs": ["A.4", "A.5"],

		  "algorithms": [
			{
			  "name": "compute_compression_kpis",
			  "role": "observer",
			  "inputs": ["pre_equiv_count", "post_equiv_count"],
			  "outputs": ["snapshot.lawful_compression_ratio", "snapshot.equivalence_efficiency"],
			  "params": ["window='EMA-32'"],
			  "steps": [
				"1. Guard: if pre_equiv_count == 0 ‚Üí set lcr=1.0 and eff=0.0; goto step 4.",
				"2. Compute lcr = post_equiv_count / pre_equiv_count.",
				"3. Compute eff = 1 - lcr.",
				"4. snapshot := {pre_equiv_count, post_equiv_count, lawful_compression_ratio:lcr, equivalence_efficiency:eff}.",
				"5. Return snapshot."
			  ]
			},
			{
			  "name": "export_kpis_to_telemetry",
			  "role": "observer",
			  "inputs": ["snapshot.lawful_compression_ratio", "snapshot.equivalence_efficiency", "window"],
			  "outputs": ["telemetry.lawful_compression_ratio", "telemetry.equivalence_efficiency"],
			  "params": ["window ‚àà {EMA-16, EMA-32, EMA-64} (default 'EMA-32')"],
			  "steps": [
				"1. Feed snapshot.lawful_compression_ratio into EMA(window) ‚Üí telemetry.lawful_compression_ratio.",
				"2. Feed snapshot.equivalence_efficiency into EMA(window) ‚Üí telemetry.equivalence_efficiency.",
				"3. Emit both metrics to the memory/homeostasis dashboard series.",
				"4. Return export handles."
			  ]
			},
			{
			  "name": "pre_prune_guard",
			  "role": "observer",
			  "inputs": ["stage"],
			  "outputs": ["ok"],
			  "params": [],
			  "steps": [
				"1. Require stage == 'pre-prune'.",
				"2. If stage != 'pre-prune' ‚Üí raise E.MMM.stage.violation.",
				"3. ok <- true; return."
			  ]
			}
		  ],

		  "invariants": [
			{
			  "name": "PrePruneOnly",
			  "condition": "KPI snapshot MUST be taken before any pruning or eviction occurs.",
			  "source": "RFC-0006 ¬ß4.4; RFC-0009 ¬ß7.2"
			},
			{
			  "name": "EMAWindows",
			  "condition": "Telemetry smoothing windows MUST be one of {EMA-16, EMA-32, EMA-64}.",
			  "source": "RFC-0009 ¬ß7.2"
			},
			{
			  "name": "ZeroDivisionGuard",
			  "condition": "If pre_equiv_count == 0, set lawful_compression_ratio=1.0 and equivalence_efficiency=0.0.",
			  "source": "RFC-0009 ¬ß7.2"
			},
			{
			  "name": "ASCII_On_Wire",
			  "condition": "All JSON keys are ASCII; any math glyphs appear only in the A.M index.",
			  "source": "PDP-0001 ¬ß4.5 (authoring/validation discipline)"
			},
			{
			  "name": "ObserverOnly",
			  "condition": "This routine measures and emits telemetry only; no control writes to Œû.",
			  "source": "PDP-0001 ¬ß4.5"
			}
		  ],

		  "example_json": {
			"fixture_nominal": {
			  "stage": "pre-prune",
			  "window": "EMA-32",
			  "pre_equiv_count": 1200,
			  "post_equiv_count": 780,
			  "snapshot": {
				"lawful_compression_ratio": 0.65,
				"equivalence_efficiency": 0.35
			  },
			  "telemetry_rollup": {
				"lawful_compression_ratio": 0.648,
				"equivalence_efficiency": 0.352
			  },
			  "notes": "Counts taken immediately after equivalence mapping; before any destructive action."
			},
			"fixture_edge_zero_pre": {
			  "stage": "pre-prune",
			  "window": "EMA-16",
			  "pre_equiv_count": 0,
			  "post_equiv_count": 0,
			  "snapshot": {
				"lawful_compression_ratio": 1.0,
				"equivalence_efficiency": 0.0
			  },
			  "telemetry_rollup": {
				"lawful_compression_ratio": 1.0,
				"equivalence_efficiency": 0.0
			  },
			  "notes": "Zero-division guard path; telemetry remains well-defined."
			},
			"fixture_out_of_order_violation": {
			  "stage": "post-prune",
			  "expect_error": "E.MMM.stage.violation",
			  "notes": "Spec-violating call for negative test coverage."
			}
		  },

		  "telemetry": [
			{ "metric": "lawful_compression_ratio", "range": "[0,1]", "units": "dimensionless", "window": "EMA-32", "description": "post_equiv_count / pre_equiv_count measured strictly pre-prune." },
			{ "metric": "equivalence_efficiency", "range": "[0,1]", "units": "fraction", "window": "EMA-32", "description": "1 - lawful_compression_ratio." }
		  ],

		  "bindings": [
			{ "dashboard": "memory/homeostasis", "series": ["lawful_compression_ratio", "equivalence_efficiency"], "window": "EMA-32" }
		  ],

		  "error_model": [
			{ "code": "E.MMM.stage.violation", "when": "stage != 'pre-prune'", "message": "Compression KPI snapshot must be taken pre-prune.", "remedy": "Reorder: run equivalence snapshot before prune pipeline." }
		  ],

		  "notes": [
			"Inputs are integers ‚â• 0; snapshot values are computed in floating point.",
			"This example intentionally omits any storage or adapter detail (Layer_2)."
		  ]
		},

		{
		  "id": "A.4",
		  "title": "Ethical TTL Floor Verification",
		  "type": "worked_example",
		  "objective": "Verify TTL_floor ‚â§ TTL ‚â§ TTL_max(t) with observer-only checks and telemetry.",
		  "rfc_anchors": ["RFC-0005 ¬ß4.2", "RFC-0009 ¬ß7.1"],
		  "math_refs": ["A.2a", "A.2b"],

		  "algorithms": [
			{
			  "name": "compute_ttl_floor",
			  "role": "observer",
			  "inputs": ["tau_decay", "delta_t_tick"],
			  "outputs": ["TTL_floor"],
			  "params": [],
			  "steps": [
				"1. x <- tau_decay.",
				"2. y <- 10 * delta_t_tick.",
				"3. TTL_floor <- max(x, y).",
				"4. return TTL_floor."
			  ]
			},
			{
			  "name": "compute_ttl_max_effective",
			  "role": "observer",
			  "inputs": ["policy", "storage_pressure"],
			  "outputs": ["TTL_max"],
			  "params": ["g(policy, storage_pressure) is monotone non-increasing in storage_pressure"],
			  "steps": [
				"1. TTL_max <- g(policy, storage_pressure).",
				"2. return TTL_max."
			  ]
			},
			{
			  "name": "evaluate_retention",
			  "role": "observer",
			  "inputs": ["TTL_observed", "tau_decay", "delta_t_tick", "policy", "storage_pressure"],
			  "outputs": ["is_compliant", "violation_reason?", "TTL_floor", "TTL_max"],
			  "params": [],
			  "steps": [
				"1. TTL_floor <- compute_ttl_floor(tau_decay, delta_t_tick).",
				"2. TTL_max <- compute_ttl_max_effective(policy, storage_pressure).",
				"3. if TTL_observed < TTL_floor: is_compliant <- false; violation_reason <- 'below_floor'; return with TTL_floor, TTL_max.",
				"4. if TTL_observed > TTL_max: is_compliant <- false; violation_reason <- 'above_max'; return with TTL_floor, TTL_max.",
				"5. is_compliant <- true; violation_reason <- null; return with TTL_floor, TTL_max."
			  ]
			},
			{
			  "name": "export_retention_telemetry",
			  "role": "observer",
			  "inputs": ["TTL_floor", "TTL_observed", "TTL_max", "is_compliant", "window"],
			  "outputs": ["telemetry.ethical_ttl_floor", "telemetry.ttl_max_effective", "telemetry.ttl_compliance_rate"],
			  "params": ["window ‚àà {EMA-16, EMA-32, EMA-64} (default 'EMA-16')"],
			  "steps": [
				"1. telemetry.ethical_ttl_floor <- EMA(window, TTL_floor).",
				"2. telemetry.ttl_max_effective <- EMA(window, TTL_max).",
				"3. telemetry.ttl_compliance_rate <- EMA(window, 1 if is_compliant else 0).",
				"4. return export handles."
			  ]
			}
		  ],

		  "invariants": [
			{
			  "name": "EthicalFloorBound",
			  "condition": "Retention MUST satisfy TTL_floor ‚â§ TTL ‚â§ TTL_max(t).",
			  "source": "RFC-0005 ¬ß4.2; RFC-0009 ¬ß7.1"
			},
			{
			  "name": "TTLFloorDefinition",
			  "condition": "TTL_floor = max(tau_decay, 10¬∑delta_t_tick).",
			  "source": "RFC-0005 ¬ß4.2"
			},
			{
			  "name": "TTLMaxMonotonicity",
			  "condition": "TTL_max(t) MUST be monotone non-increasing in storage_pressure.",
			  "source": "RFC-0009 ¬ß7.1"
			},
			{
			  "name": "ObserverOnly",
			  "condition": "Evaluation and telemetry are observer-class only; no control writes to Œû.",
			  "source": "PDP-0001 ¬ß4.5"
			},
			{
			  "name": "EMAWindows",
			  "condition": "All telemetry smoothing windows MUST be one of {EMA-16, EMA-32, EMA-64}.",
			  "source": "RFC-0009 ¬ß7.1"
			},
			{
			  "name": "ASCII_On_Wire",
			  "condition": "All JSON keys are ASCII; math glyphs live only in the A.M index.",
			  "source": "Authoring discipline"
			}
		  ],

		  "example_json": {
			"fixture_nominal": {
			  "window": "EMA-16",
			  "inputs": {
				"tau_decay": 240,
				"delta_t_tick": 12,
				"TTL_observed": 300,
				"policy": "retention:balanced",
				"storage_pressure": 0.7
			  },
			  "computed": {
				"TTL_floor": 240,
				"TTL_max": 360,
				"is_compliant": true,
				"violation_reason": null
			  },
			  "telemetry_rollup": {
				"ethical_ttl_floor": 241.2,
				"ttl_max_effective": 358.7,
				"ttl_compliance_rate": 1.0
			  },
			  "notes": "Within bounds: 240 ‚â§ 300 ‚â§ 360."
			},
			"fixture_below_floor": {
			  "window": "EMA-32",
			  "inputs": {
				"tau_decay": 240,
				"delta_t_tick": 8,
				"TTL_observed": 180,
				"policy": "retention:conservative",
				"storage_pressure": 0.3
			  },
			  "computed": {
				"TTL_floor": 240,
				"TTL_max": 420,
				"is_compliant": false,
				"violation_reason": "below_floor"
			  },
			  "expect_error": null,
			  "notes": "Violation: observed TTL below ethical floor."
			},
			"fixture_above_max": {
			  "window": "EMA-64",
			  "inputs": {
				"tau_decay": 120,
				"delta_t_tick": 10,
				"TTL_observed": 900,
				"policy": "retention:pressure-aware",
				"storage_pressure": 0.9
			  },
			  "computed": {
				"TTL_floor": 120,
				"TTL_max": 300,
				"is_compliant": false,
				"violation_reason": "above_max"
			  },
			  "notes": "Violation: observed TTL exceeds pressure-constrained maximum."
			}
		  },

		  "telemetry": [
			{ "metric": "ethical_ttl_floor", "range": "[0,+inf)", "units": "ticks", "window": "EMA-16", "description": "Smoothed floor bound used for audits." },
			{ "metric": "ttl_max_effective", "range": "[0,+inf)", "units": "ticks", "window": "EMA-16", "description": "Smoothed maximum bound under current policy/pressure." },
			{ "metric": "ttl_compliance_rate", "range": "[0,1]", "units": "fraction", "window": "EMA-16", "description": "Rate of samples in compliance with the ethical bound." }
		  ],

		  "bindings": [
			{ "dashboard": "memory/policy", "series": ["ethical_ttl_floor", "ttl_max_effective", "ttl_compliance_rate"], "window": "EMA-16" }
		  ],

		  "error_model": [
			{ "code": "E.MMM.ttl.floor.undefined", "when": "tau_decay or delta_t_tick missing/invalid", "message": "Cannot compute TTL_floor without tau_decay and delta_t_tick.", "remedy": "Provide both inputs as non-negative numbers." },
			{ "code": "E.MMM.ttl.max.nonmonotone", "when": "g(policy, storage_pressure) increases with storage_pressure", "message": "TTL_max must be non-increasing in storage_pressure.", "remedy": "Select a policy function g that respects monotonicity." }
		  ],

		  "notes": [
			"Inputs are non-negative numbers; units (ticks/seconds) must be consistent across tau_decay, delta_t_tick, TTL_observed.",
			"This worked example avoids any storage, role, or crypto detail (Layer_2)."
		  ]
		},

		{
		  "id": "A.5",
		  "title": "Replay Window & seen_set Defense",
		  "type": "worked_example",
		  "objective": "Apply ŒîœÑ_phase and hybrid (time window + LRU) seen_set for replay protection; bind dashboard series.",
		  "rfc_anchors": ["RFC-0008 ¬ß2.2", "RFC-0009 ¬ß7.2"],
		  "math_refs": ["A.3", "A.3b"],

		  "feature_flags": {
			"enable_exchange_envelope": "gates Sigma_phase key component",
			"enable_integrity_checks": "gates Delta_hash key component"
		  },

		  "algorithms": [
			{
			  "name": "compute_phase_window",
			  "role": "observer",
			  "inputs": ["C_trace", "alpha"],
			  "outputs": ["Delta_tau_phase"],
			  "params": ["alpha ‚àà [0.5, 2.0]", "EMA window='EMA-32'"],
			  "steps": [
				"1. C_bar <- EMA-32(C_trace).",
				"2. Delta_tau_phase <- alpha * C_bar.",
				"3. return Delta_tau_phase."
			  ]
			},
			{
			  "name": "compose_seen_key",
			  "role": "observer",
			  "inputs": ["origin", "bundle_id", "Sigma_phase?", "Delta_hash?", "flags"],
			  "outputs": ["seen_key"],
			  "params": [],
			  "steps": [
				"1. parts <- [origin].",
				"2. if flags.enable_exchange_envelope and Sigma_phase present: parts.append(Sigma_phase).",
				"3. if flags.enable_integrity_checks and Delta_hash present: parts.append(Delta_hash).",
				"4. parts.append(bundle_id).",
				"5. seen_key <- join(parts, '|').",
				"6. return seen_key."
			  ]
			},
			{
			  "name": "seen_set_hybrid_policy",
			  "role": "observer",
			  "inputs": ["seen_key", "now", "Delta_tau_phase"],
			  "outputs": ["accepted", "replay_drop_event?"],
			  "params": ["window = 2 * Delta_tau_phase", "eviction = LRU"],
			  "steps": [
				"1. if seen_set.contains(seen_key) and (now - seen_set[seen_key].ts) <= window:",
				"2.    emit replay_drop_event; accepted <- false; return.",
				"3. seen_set[seen_key] <- {ts: now, ttl: window}.",
				"4. apply LRU eviction on capacity pressure.",
				"5. accepted <- true; return."
			  ]
			},
			{
			  "name": "export_replay_telemetry",
			  "role": "observer",
			  "inputs": ["Delta_tau_phase", "replay_drop_event?", "accepted"],
			  "outputs": ["telemetry.avg_replay_window_ticks", "telemetry.replay_drop_rate", "telemetry.accepted_within_window"],
			  "params": ["window='EMA-32'"],
			  "steps": [
				"1. avg_replay_window_ticks <- EMA-32(2*Delta_tau_phase).",
				"2. replay_drop_rate <- EMA-32(1 if replay_drop_event else 0).",
				"3. accepted_within_window <- EMA-32(1 if accepted else 0).",
				"4. emit metrics."
			  ]
			}
		  ],

		  "invariants": [
			{
			  "name": "WindowDefinition",
			  "condition": "Replay defense MUST use window = 2¬∑ŒîœÑ_phase.",
			  "source": "RFC-0008 ¬ß2.2"
			},
			{
			  "name": "LRUEviction",
			  "condition": "Eviction policy within the seen_set MUST be LRU.",
			  "source": "RFC-0008 ¬ß2.2; RFC-0009 ¬ß7.2"
			},
			{
			  "name": "FlagRespectingKey",
			  "condition": "seen_key composition MUST include Sigma_phase/Delta_hash only when respective flags are enabled.",
			  "source": "RFC-0008 ¬ß2; RFC-0009 ¬ß7.2"
			},
			{
			  "name": "ObserverOnly",
			  "condition": "Defense is observer-class: insert/lookup/emit only; no control writes to Œû.",
			  "source": "PDP-0001 ¬ß4.5"
			},
			{
			  "name": "EMAWindows",
			  "condition": "Telemetry windows MUST be one of {EMA-16, EMA-32, EMA-64}; default EMA-32.",
			  "source": "RFC-0009 ¬ß7.2"
			},
			{
			  "name": "ASCII_On_Wire",
			  "condition": "All JSON keys are ASCII; math glyphs live only in the A.M index.",
			  "source": "Authoring discipline"
			}
		  ],

		  "example_json": {
			"fixture_flags_ON": {
			  "flags": { "enable_exchange_envelope": true, "enable_integrity_checks": true },
			  "alpha": 1.0,
			  "C_trace": [0.62, 0.64, 0.63, 0.65],
			  "computed": { "Delta_tau_phase": 0.64, "window_ticks": 1.28 },
			  "events": [
				{ "t": 100.00, "action": "import", "seen_key": "agent.A|phase:t100|sha256:aa...11|G@2025-Q4", "result": "accepted" },
				{ "t": 100.80, "action": "import", "seen_key": "agent.A|phase:t100|sha256:aa...11|G@2025-Q4", "result": "replay_drop" },
				{ "t": 101.50, "action": "import", "seen_key": "agent.A|phase:t101.5|sha256:aa...11|G@2025-Q4", "result": "accepted" }
			  ],
			  "telemetry_rollup": {
				"avg_replay_window_ticks": 1.28,
				"replay_drop_rate": 0.333,
				"accepted_within_window": 0.667
			  },
			  "notes": "Checksums present in key; second event dropped within 2¬∑ŒîœÑ_phase."
			},
			"fixture_flags_OFF": {
			  "flags": { "enable_exchange_envelope": false, "enable_integrity_checks": false },
			  "alpha": 0.8,
			  "C_trace": [0.40, 0.45, 0.44, 0.46],
			  "computed": { "Delta_tau_phase": 0.36, "window_ticks": 0.72 },
			  "events": [
				{ "t": 200.00, "action": "import", "seen_key": "agent.X|G@2025-Q4", "result": "accepted" },
				{ "t": 200.50, "action": "import", "seen_key": "agent.X|G@2025-Q4", "result": "replay_drop" },
				{ "t": 201.00, "action": "import", "seen_key": "agent.X|G@2025-Q4", "result": "accepted" }
			  ],
			  "telemetry_rollup": {
				"avg_replay_window_ticks": 0.72,
				"replay_drop_rate": 0.333,
				"accepted_within_window": 0.667
			  },
			  "notes": "Key excludes Sigma_phase/Delta_hash; behavior still bounded by 2¬∑ŒîœÑ_phase."
			},
			"negative_fixture_non_lru": {
			  "flags": { "enable_exchange_envelope": true, "enable_integrity_checks": true },
			  "policy_attempt": "FIFO",
			  "expect_error": "E.MMM.seen.eviction_policy"
			}
		  },

		  "telemetry": [
			{ "metric": "avg_replay_window_ticks", "range": "[0,+inf)", "units": "ticks", "window": "EMA-32", "description": "Smoothed value of 2¬∑ŒîœÑ_phase." },
			{ "metric": "replay_drop_rate", "range": "[0,1]", "units": "fraction", "window": "EMA-32", "description": "Fraction of imports dropped as replays inside window." },
			{ "metric": "accepted_within_window", "range": "[0,1]", "units": "fraction", "window": "EMA-32", "description": "Fraction of imports accepted (not dropped) in the same horizon." },
			{ "metric": "import_reject_missing_checksum", "range": "[0,+inf)", "units": "count", "window": "EMA-32", "description": "Rejected imports due to missing required checksum fields when flags demand them." }
		  ],

		  "bindings": [
			{ "dashboard": "exchange/timing", "series": ["avg_replay_window_ticks", "accepted_within_window"], "window": "EMA-32" },
			{ "dashboard": "security/exchange", "series": ["import_reject_missing_checksum", "replay_drop_rate"], "window": "EMA-32" }
		  ],

		  "error_model": [
			{ "code": "E.MMM.seen.eviction_policy", "when": "eviction policy != LRU", "message": "seen_set eviction policy must be LRU.", "remedy": "Configure LRU eviction within the replay window." },
			{ "code": "E.MMM.seen.flag_key_violation", "when": "seen_key contains gated fields while flags disabled (or vice versa)", "message": "Key composition must respect feature flags.", "remedy": "Recompose key according to current flags." },
			{ "code": "E.MMM.phase.alpha.invalid", "when": "alpha ‚àâ [0.5, 2.0]", "message": "alpha outside allowed range for ŒîœÑ_phase computation.", "remedy": "Choose alpha in [0.5, 2.0]." }
		  ],

		  "notes": [
			"Time units are abstract 'ticks'; consistency across inputs and telemetry is required.",
			"This example is observer-only; it performs lookup/insert/emit without mutating control state."
		  ]
		},

		{
		  "id": "A.6",
		  "title": "Provenance & Lineage: Merge vs Fork",
		  "type": "worked_example",
		  "objective": "Validate RFC-0007 bundles; decide merge/fork via parent_hash and integrity_hash; emit provenance events (observer-only).",
		  "rfc_anchors": ["RFC-0007 ¬ß2", "RFC-0009 ¬ß5.1", "PDP-0001 ¬ß3"],

		  "algorithms": [
			{
			  "name": "validate_provenance_and_lineage",
			  "role": "observer",
			  "inputs": ["bundle_header"],
			  "outputs": ["provenance_ok", "lineage_ok", "reasons"],
			  "params": [
				"version_format = 'YYYY-QX'",
				"psi_regex = '^œà-[a-z0-9_]+@Œû$'",
				"hash_regex = '^[a-f0-9]{6,}$'"
			  ],
			  "steps": [
				"1. Check header.version matches version_format.",
				"2. Verify provenance fields {origin, origin_hash, created_at} exist and origin_hash matches hash_regex (structural only).",
				"3. Validate ontology index œà-field names against psi_regex (values may be unicode; keys remain ASCII).",
				"4. lineage_ok <- header.lineage.schema in {'RFC-0007','RFC-0009-lineage'} AND parent_hash/integrity_hash match hash_regex.",
				"5. provenance_ok <- (origin is present) AND (origin_hash structural check passed) AND (created_at ISO-8601).",
				"6. reasons <- array of any failing checks (empty if all pass).",
				"7. return provenance_ok, lineage_ok, reasons."
			  ]
			},
			{
			  "name": "merge_or_fork_decision",
			  "role": "observer",
			  "inputs": ["bundle_A.lineage", "bundle_B.lineage"],
			  "outputs": ["decision"],
			  "params": [],
			  "steps": [
				"1. if A.parent_hash == B.parent_hash AND A.integrity_hash == B.integrity_hash: decision <- 'merge'.",
				"2. else if A.parent_hash == B.parent_hash AND A.integrity_hash != B.integrity_hash: decision <- 'fork'.",
				"3. else: decision <- 'unrelated'.",
				"4. return decision."
			  ]
			},
			{
			  "name": "emit_provenance_event",
			  "role": "observer",
			  "inputs": ["decision", "bundle_meta"],
			  "outputs": ["event_recorded"],
			  "params": ["window = 'EMA-32'"],
			  "steps": [
				"1. if decision == 'fork': record {type:'fork_event', origin, parent_hash, integrity_hash_A, integrity_hash_B, timestamp}.",
				"2. else if decision == 'merge': record {type:'merge_event', origin, parent_hash, integrity_hash, timestamp}.",
				"3. else: record {type:'no_merge', reason:'unrelated', timestamp}.",
				"4. event_recorded <- true; return."
			  ]
			}
		  ],

		  "invariants": [
			{
			  "name": "RFC0007_First",
			  "condition": "Bundle schema (version, œà-field, lineage) is validated before any merge/fork decision.",
			  "source": "RFC-0007 ¬ß2"
			},
			{
			  "name": "MergeFork_Rules",
			  "condition": "merge iff parent_hash and integrity_hash both match; fork iff parent_hash matches and integrity_hash differs; else unrelated.",
			  "source": "RFC-0007 ¬ß2; RFC-0009 ¬ß5.1"
			},
			{
			  "name": "Observer_Only",
			  "condition": "Process performs measurement/validation/record-only; no control writes to Xi.",
			  "source": "PDP-0001 ¬ß3"
			},
			{
			  "name": "ASCII_On_Wire",
			  "condition": "All JSON keys are ASCII; unicode may appear in values (e.g., œà-field).",
			  "source": "Appendix A conventions"
			}
		  ],

		  "example_json": {
			"version": "2025-Q4",
			"bundle_A": {
			  "header": {
				"provenance": { "origin": "agent.A", "origin_hash": "a1b2c3d4", "created_at": "2025-09-30T12:00:00Z" },
				"lineage": { "parent_hash": "p_hash_77aa", "integrity_hash": "ihash_aa11", "schema": "RFC-0007" },
				"motif_count": 128
			  },
			  "index": [
				{ "motif_id": "m-001", "psi_field": "œà-null@Œû", "usage_frequency": 12, "version": "2025-Q4" }
			  ]
			},
			"bundle_B": {
			  "header": {
				"provenance": { "origin": "agent.B", "origin_hash": "d4e5f6a7", "created_at": "2025-10-02T08:45:10Z" },
				"lineage": { "parent_hash": "p_hash_77aa", "integrity_hash": "ihash_bb22", "schema": "RFC-0007" },
				"motif_count": 129
			  },
			  "index": [
				{ "motif_id": "m-001", "psi_field": "œà-null@Œû", "usage_frequency": 13, "version": "2025-Q4" }
			  ]
			},
			"validation": {
			  "provenance_ok": true,
			  "lineage_ok": true,
			  "reasons": []
			},
			"decision": "fork",
			"provenance_event": {
			  "type": "fork_event",
			  "origin": "agent.B",
			  "parent_hash": "p_hash_77aa",
			  "integrity_hash_A": "ihash_aa11",
			  "integrity_hash_B": "ihash_bb22",
			  "timestamp": "2025-10-11T00:00:00Z"
			},
			"notes": "Parent hashes equal; integrity hashes differ ‚áí fork per RFC-0007."
		  },

		  "telemetry": [
			{ "metric": "fork_events", "range": "[0,+inf)", "units": "count", "window": "EMA-32", "description": "Count of fork decisions recorded." },
			{ "metric": "merge_events", "range": "[0,+inf)", "units": "count", "window": "EMA-32", "description": "Count of merge decisions recorded." },
			{ "metric": "provenance_validation_failures", "range": "[0,+inf)", "units": "count", "window": "EMA-32", "description": "Number of structural provenance/lineage validation failures." }
		  ],

		  "bindings": [
			{ "dashboard": "security/provenance", "series": ["fork_events", "merge_events", "provenance_validation_failures"], "window": "EMA-32" }
		  ],

		  "notes": [
			"This appendix illustrates behavior; it does not introduce new MUSTs beyond those anchored to RFC-0007/RFC-0009.",
			"If feature flags for checksums are present elsewhere, they do not affect merge/fork rules in this example."
		  ]
		},

		{
		  "id": "A.7",
		  "title": "Adversarial Import ‚Üí Bounded Recovery & Quarantine",
		  "type": "worked_example",
		  "objective": "Reanchor attempts with overlap detection, seen_set replay defense, and bounded quarantine outcomes.",
		  "feature_flags": {
			"enable_exchange_envelope": "gates Sigma_phase",
			"enable_integrity_checks": "gates Delta_hash"
		  },
		  "rfc_anchors": ["RFC-0007 ¬ß2.1", "RFC-0008 ¬ß2", "RFC-0009 ¬ß5.2", "PDP-0001 ¬ß3‚Äì¬ß4.5"],

		  "algorithms": [
			{
			  "name": "seen_set_replay_defense",
			  "role": "observer",
			  "inputs": ["origin", "bundle_id", "envelope.Sigma_phase?", "now", "Delta_tau_phase"],
			  "outputs": ["replay_drop_event?"],
			  "params": ["window_ticks = 2 * Delta_tau_phase", "eviction_policy = LRU"],
			  "steps": [
				"1. Compose replay_key := (origin, bundle_id[, Sigma_phase]) ‚Äî include Sigma_phase only if enable_exchange_envelope=true.",
				"2. If replay_key present and age <= window_ticks ‚Üí emit replay_drop_event and STOP.",
				"3. Insert replay_key with TTL=window_ticks; apply LRU eviction on capacity.",
				"4. Continue to lineage/provenance validation."
			  ]
			},
			{
			  "name": "validate_lineage_and_provenance",
			  "role": "observer",
			  "inputs": ["bundle.header.provenance", "bundle.header.lineage", "envelope?"],
			  "outputs": ["valid", "reason?"],
			  "params": ["hash_regex='^[a-f0-9]{6,}$'", "iso8601='^\\d{4}-\\d{2}-\\d{2}T'"],
			  "steps": [
				"1. Structural checks: provenance {origin, origin_hash, created_at} present; created_at matches iso8601; origin_hash matches hash_regex.",
				"2. Lineage checks: {parent_hash, integrity_hash, schema} present; both hashes match hash_regex; schema in {'RFC-0007','RFC-0009-lineage'}.",
				"3. If enable_integrity_checks=true and envelope.Delta_hash present ‚Üí recompute integrity and compare.",
				"4. If all checks pass ‚Üí valid=true else valid=false with reason.",
				"5. Return valid, reason."
			  ]
			},
			{
			  "name": "reanchor_attempts_with_overlap_detection",
			  "role": "observer",
			  "inputs": ["origin", "lineage.parent_hash", "valid", "reason?", "now"],
			  "outputs": ["reanchor_attempt_event", "overlap_detected?"],
			  "params": ["recovery_token := monotonic()", "overlap_key := (origin, parent_hash)"],
			  "steps": [
				"1. Emit reanchor_attempt_event {recovery_token, origin, parent_hash, timestamp:now}.",
				"2. If an active recovery exists for overlap_key with different token ‚Üí set overlap_detected=true and apply short jitter backoff (observer note only).",
				"3. If valid=false and reason indicates lineage mismatch ‚Üí continue to quarantine flow; else proceed to lawful acceptance outside this example."
			  ]
			},
			{
			  "name": "quarantine_on_lineage_failure",
			  "role": "observer",
			  "inputs": ["origin", "reason", "bundle_meta"],
			  "outputs": ["quarantine_entry_event", "staging_record_handle"],
			  "params": ["termination_outcomes = {reanchored, quarantined, abandoned}"],
			  "steps": [
				"1. Create immutable staging record with {origin, reason, minimal bundle_meta}.",
				"2. Emit quarantine_entry_event with handle to staging record.",
				"3. Mark outcome='quarantined' for this packet and stop further recovery attempts for this recovery_token."
			  ]
			},
			{
			  "name": "bounded_termination_guard",
			  "role": "observer",
			  "inputs": ["recovery_token", "attempt_counter", "policy.max_attempts"],
			  "outputs": ["terminate?"],
			  "params": ["policy.max_attempts default = 3"],
			  "steps": [
				"1. If attempt_counter >= policy.max_attempts ‚Üí terminate=true and mark outcome='abandoned'.",
				"2. Else terminate=false.",
				"3. Return terminate."
			  ]
			}
		  ],

		  "invariants": [
			{ "name": "RFC0007_before_recovery", "condition": "Bundle provenance and lineage MUST be validated prior to any reanchor or merge action." },
			{ "name": "Replay_Window", "condition": "Replay defense uses window_ticks = 2 * Delta_tau_phase with LRU eviction within the window." },
			{ "name": "Flag_Gated_Checksums", "condition": "Sigma_phase appears only when enable_exchange_envelope=true; Delta_hash appears only when enable_integrity_checks=true." },
			{ "name": "Bounded_Outcomes", "condition": "Recovery outcomes are restricted to {reanchored, quarantined, abandoned}; no unbounded loops." },
			{ "name": "Observer_Only", "condition": "All steps are measurement/validation/sealing/routing only; no control writes to Xi." },
			{ "name": "ASCII_On_Wire", "condition": "All JSON keys are ASCII; any greek/math appears only inside latex strings elsewhere in Appendix A." }
		  ],

		  "example_json": {
			"variant_ON": {
			  "feature_flags": { "enable_exchange_envelope": true, "enable_integrity_checks": true },
			  "inputs": {
				"origin": "agent.A",
				"bundle_id": "mirror@2025-Q4",
				"Delta_tau_phase": 1,
				"envelope": { "version": "2025-Q4", "Sigma_phase": "phase:2025-10-10T17:07:00Z+0000", "Delta_hash": "sha256:7f2e...c1" },
				"bundle": {
				  "header": {
					"provenance": { "origin": "agent.A", "origin_hash": "sha256:aa11bb...", "created_at": "2025-10-10T17:07:00Z" },
					"lineage": { "parent_hash": "sha256:deadbeef", "integrity_hash": "sha256:badc0de", "schema": "RFC-0007" }
				  },
				  "payload_meta": { "C": 0.65, "rho_res": 0.33, "delta_closure": 0.045 }
				}
			  },
			  "timeline": [
				"t0: seen_set key=(agent.A, mirror@2025-Q4, phase:2025-10-10T17:07:00Z+0000) not present ‚Üí accept for validation.",
				"t1: lineage recompute mismatch vs integrity_hash ‚Üí reanchor_attempt emitted.",
				"t2: overlap check: none active ‚Üí proceed.",
				"t3: reanchor fail (no lawful prior) ‚Üí quarantine_entry_event; outcome=quarantined.",
				"t4: seen_set insert with TTL=2 ticks (2 * Delta_tau_phase)."
			  ],
			  "telemetry_sample": { "reanchor_attempt": 1, "reanchor_fail": 1, "quarantine_entry": 1, "avg_replay_window_ticks": 2 }
			},
			"variant_OFF": {
			  "feature_flags": { "enable_exchange_envelope": false, "enable_integrity_checks": false },
			  "inputs": {
				"origin": "agent.X",
				"bundle_id": "mirror@2025-Q4",
				"Delta_tau_phase": 2,
				"envelope": { "version": "2025-Q4" },
				"bundle": {
				  "header": {
					"provenance": { "origin": "agent.X", "origin_hash": "sha256:ff00ee...", "created_at": "2025-10-10T17:09:00Z" },
					"lineage": { "parent_hash": "sha256:feedface", "integrity_hash": "sha256:cafebabe", "schema": "RFC-0007" }
				  },
				  "payload_meta": { "C": 0.66, "rho_res": 0.31, "delta_closure": 0.047 }
				}
			  },
			  "timeline": [
				"t0: seen_set key=(agent.X, mirror@2025-Q4) (no Sigma_phase due to flags) not present ‚Üí accept for validation.",
				"t1: integrity mismatch via local recompute; no Delta_hash expected (flag off).",
				"t2: reanchor_attempt emitted; overlap detected with another token ‚Üí jittered backoff (observer note only).",
				"t3: reanchor fail ‚Üí quarantine_entry_event; outcome=quarantined.",
				"t4: seen_set insert with TTL=4 ticks (2 * Delta_tau_phase)."
			  ],
			  "telemetry_sample": { "reanchor_attempt": 1, "reanchor_fail": 1, "quarantine_entry": 1, "overlap_recovery_drops": 1, "avg_replay_window_ticks": 4 }
			}
		  },

		  "telemetry": [
			{ "metric": "reanchor_attempt", "range": "[0,+inf)", "units": "count", "window": "EMA-32", "description": "Number of recovery attempts initiated." },
			{ "metric": "reanchor_fail", "range": "[0,+inf)", "units": "count", "window": "EMA-32", "description": "Failed reanchor attempts (structural/lineage mismatch)." },
			{ "metric": "quarantine_entry", "range": "[0,+inf)", "units": "count", "window": "EMA-32", "description": "Packets staged to quarantine." },
			{ "metric": "overlap_recovery_drops", "range": "[0,+inf)", "units": "count", "window": "EMA-32", "description": "Attempts dropped due to concurrent recovery overlap on (origin,parent_hash)." },
			{ "metric": "replay_drop_event_count", "range": "[0,+inf)", "units": "count", "window": "EMA-32", "description": "Imports rejected by seen_set replay defense." },
			{ "metric": "avg_replay_window_ticks", "range": "[0,+inf)", "units": "ticks", "window": "EMA-32", "description": "Rolling average of 2 * Delta_tau_phase." }
		  ],

		  "bindings": [
			{ "dashboard": "security/exchange", "series": ["replay_drop_event_count", "avg_replay_window_ticks"], "window": "EMA-32" },
			{ "dashboard": "memory/recovery", "series": ["reanchor_attempt", "reanchor_fail", "quarantine_entry", "overlap_recovery_drops"], "window": "EMA-32" }
		  ],

		  "notes": [
			"This example is observer-only and does not prescribe Layer_2 enforcement details.",
			"Checksum fields are entirely absent when their feature flags are disabled."
		  ]
		},

		{
		  "id": "A.8",
		  "title": "Glider Canonicalization & Recall (Flag-Gated)",
		  "type": "worked_example",
		  "objective": "Detect shift-equivalence gliders; store a single canonical representative; deny repeat promotions; recall via S_k.",
		  "feature_flags": { "enable_point_space_gliders": true },
		  "rfc_anchors": ["RFC-0006 ¬ß3‚Äì¬ß4", "RFC-0005 ¬ß3.3", "RFC-0009 ¬ß7.1"],

		  "algorithms": [
			{
			  "name": "detect_glider",
			  "role": "observer",
			  "inputs": ["trace_window", "tau_band_min", "rho_res_band=[0.3,0.7]", "delta_closure_max"],
			  "outputs": ["is_glider", "class_id"],
			  "params": ["window='EMA-32'"],
			  "steps": [
				"1. rho_res_band_share <- fraction of entries in trace_window with rho_res ‚àà rho_res_band (EMA-32).",
				"2. sig_ok <- (rho_res_band_share >= tau_band_min) AND (EMA-32(delta_closure) <= delta_closure_max).",
				"3. if sig_ok: is_glider <- true; class_id <- hash_of_shift_invariants(trace_window); else: is_glider <- false; class_id <- null.",
				"4. return is_glider, class_id."
			  ]
			},
			{
			  "name": "canonicalize_shift_equivalence",
			  "role": "observer",
			  "inputs": ["class_id", "candidate_ref"],
			  "outputs": ["canonical_ref", "pre_equiv_count", "post_equiv_count"],
			  "params": [],
			  "steps": [
				"1. pre_equiv_count <- count(entries_in_equivalence_scan).",
				"2. if class_id ‚àà glider_index: canonical_ref <- glider_index[class_id].rep.",
				"3. else: canonical_ref <- candidate_ref; glider_index[class_id] <- {rep: candidate_ref, occurrence_refs: []}.",
				"4. post_equiv_count <- count(unique canonical representatives after mapping).",
				"5. return canonical_ref, pre_equiv_count, post_equiv_count."
			  ]
			},
			{
			  "name": "deny_repeated_promotion",
			  "role": "observer",
			  "inputs": ["class_id", "candidate_ref", "canonical_ref"],
			  "outputs": ["promotion_allowed"],
			  "params": [],
			  "steps": [
				"1. if glider_index[class_id].rep exists AND equals canonical_ref:",
				"2.    append glider_index[class_id].occurrence_refs <- candidate_ref; promotion_allowed <- false.",
				"3. else:",
				"4.    promotion_allowed <- true (only when no canonical exists).",
				"5. return promotion_allowed."
			  ]
			},
			{
			  "name": "recall_via_shift_operator",
			  "role": "observer",
			  "inputs": ["canonical_ref", "k_shift"],
			  "outputs": ["recalled_ref"],
			  "params": [],
			  "steps": [
				"1. recalled_ref <- apply_S_k(canonical_ref, k_shift)  // pure mapping; no control write.",
				"2. return recalled_ref."
			  ]
			}
		  ],

		  "invariants": [
			{ "name": "Canonical_Representative_Only", "condition": "Store exactly one canonical representative per shift-equivalence class; additional occurrences are references.", "source": "RFC-0006 ¬ß4.4" },
			{ "name": "Idempotent_Promotion", "condition": "When a canonical representative exists for class_id, repeated promotions of class members are denied.", "source": "RFC-0006 ¬ß3‚Äì¬ß4" },
			{ "name": "Observer_Only", "condition": "Detection, mapping, and recall are observer-class operations; no control writes to Xi.", "source": "PDP-0001 ¬ß4.5" },
			{ "name": "ASCII_On_Wire", "condition": "All JSON keys are ASCII; math symbols appear only inside math references (see A.M).", "source": "Authoring contract" },
			{ "name": "Flag_Gating", "condition": "Glider-specific fields {class_id, v, phi, tau, glider_* metrics} appear only when enable_point_space_gliders=true.", "source": "Feature-flag contract" }
		  ],

		  "example_json": {
			"fixture_on": {
			  "feature_flags": { "enable_point_space_gliders": true },
			  "window": "EMA-32",
			  "inputs": {
				"pre_equiv_count": 200,
				"rho_res_band_share": 0.62,
				"delta_closure": 0.010,
				"tau_band_min": 0.50
			  },
			  "glider_detection": {
				"is_glider": true,
				"class_id": "class:gld-7a2f"
			  },
			  "canonicalization": {
				"canonical_present_before": false,
				"post_equiv_count": 140,
				"lawful_compression_ratio": 0.70,
				"equivalence_efficiency": 0.30
			  },
			  "promotion": {
				"promotion_allowed": true,
				"action": "store_canonical_rep"
			  },
			  "second_occurrence": {
				"candidate_ref": "motif#occ2",
				"promotion_allowed": false,
				"occurrence_refs_appended": true
			  },
			  "recall": {
				"k_shift": 3,
				"recalled_from": "canonical_rep",
				"note": "Recall via S_k mapping only; no control writes."
			  },
			  "telemetry_snapshot": {
				"glider_detected": 1,
				"glider_canonical_count": 1,
				"lawful_compression_ratio": 0.70
			  },
			  "notes": "Flag ON: glider KPIs are emitted; idempotent promotion enforced."
			},
			"fixture_off": {
			  "feature_flags": { "enable_point_space_gliders": false },
			  "window": "EMA-32",
			  "inputs": {
				"pre_equiv_count": 200,
				"rho_res_band_share": 0.62,
				"delta_closure": 0.010
			  },
			  "behavior": {
				"glider_tags_present": false,
				"tau_metrics_present": false,
				"mapping": "Shift-equivalence compression still applies generically without class/v/phi/tau tags"
			  },
			  "canonicalization": {
				"post_equiv_count": 140,
				"lawful_compression_ratio": 0.70,
				"equivalence_efficiency": 0.30
			  },
			  "telemetry_snapshot": {
				"lawful_compression_ratio": 0.70
			  },
			  "notes": "Flag OFF: no glider-specific fields; generic equivalence compression remains."
			}
		  },

		  "telemetry": [
			{ "metric": "glider_detected", "range": "[0,+inf)", "units": "count", "window": "EMA-16", "description": "Number of detected glider classes; emitted only when flag=true." },
			{ "metric": "glider_canonical_count", "range": "[0,+inf)", "units": "count", "window": "EMA-16", "description": "Stored canonical representatives; emitted only when flag=true." },
			{ "metric": "lawful_compression_ratio", "range": "[0,1]", "units": "dimensionless", "window": "EMA-32", "description": "post_equiv_count / pre_equiv_count measured strictly pre-prune." }
		  ],

		  "bindings": [
			{ "dashboard": "memory/glider_flow", "series": ["glider_detected", "glider_canonical_count"], "window": "EMA-16", "active_when": "enable_point_space_gliders=true" },
			{ "dashboard": "memory/homeostasis", "series": ["lawful_compression_ratio"], "window": "EMA-32" }
		  ],

		  "notes": [
			"Math references: A.M: shift-equivalence (A.3.1), compression ratio (A.3.3).",
			"Glider-specific KPIs and fields MUST NOT appear when the feature flag is disabled."
		  ]
		},

		{
		  "id": "A.9",
		  "title": "Dashboard Bindings & KPI Catalog",
		  "type": "reference_table",
		  "schema_version": "2025-Q4",
		  "objective": "Centralize the dashboard groupings and metric windows used across examples; declare a single KPI catalog with units, default windows, and gating rules.",

		  "data": {
			"dashboards": [
			  { "dashboard": "memory/homeostasis", "series": ["saturation_level", "lawful_compression_ratio", "equivalence_efficiency"], "window": "EMA-32" },
			  { "dashboard": "security/exchange", "series": ["replay_drop_rate", "import_reject_missing_checksum"], "window": "EMA-32" },
			  { "dashboard": "memory/recovery", "series": ["reanchor_attempt", "reanchor_fail", "quarantine_entry"], "window": "EMA-32" },
			  { "dashboard": "memory/glider_flow", "series": ["glider_detected", "glider_canonical_count"], "window": "EMA-16", "active_when": "enable_point_space_gliders=true" }
			],

			"kpi_catalog": [
			  {
				"name": "saturation_level",
				"unit": "fraction",
				"default_window": "EMA-32",
				"description": "Proportion of LTMM capacity occupied (0‚Äì1).",
				"source_examples": ["A.1"],
				"notes": "Derived from LTMM usage / C_max."
			  },
			  {
				"name": "lawful_compression_ratio",
				"unit": "dimensionless",
				"default_window": "EMA-32",
				"description": "post_equiv_count / pre_equiv_count measured strictly pre-prune.",
				"source_examples": ["A.1", "A.2", "A.8"],
				"notes": "Snapshot computed before any prune operation."
			  },
			  {
				"name": "equivalence_efficiency",
				"unit": "fraction",
				"default_window": "EMA-32",
				"description": "Capacity relief due to equivalence compression (1 ‚àí lawful_compression_ratio).",
				"source_examples": ["A.1", "A.2", "A.8"]
			  },
			  {
				"name": "replay_drop_rate",
				"unit": "fraction",
				"default_window": "EMA-32",
				"description": "Fraction of imports dropped as replays within the active window.",
				"source_examples": ["A.4"]
			  },
			  {
				"name": "import_reject_missing_checksum",
				"unit": "count",
				"default_window": "EMA-32",
				"description": "Count of imports rejected due to missing required checksum fields under active flags.",
				"source_examples": ["A.4"],
				"notes": "Only increments when a checksum is required by feature flags."
			  },
			  {
				"name": "reanchor_attempt",
				"unit": "count",
				"default_window": "EMA-32",
				"description": "Emitted when lineage mismatch triggers a reanchor attempt.",
				"source_examples": ["A.6"]
			  },
			  {
				"name": "reanchor_fail",
				"unit": "count",
				"default_window": "EMA-32",
				"description": "Reanchor attempt concluded with failure; leads to bounded outcomes.",
				"source_examples": ["A.6"]
			  },
			  {
				"name": "quarantine_entry",
				"unit": "count",
				"default_window": "EMA-32",
				"description": "Packet staged in quarantine following failed reanchor or unlawful lineage.",
				"source_examples": ["A.6"]
			  },
			  {
				"name": "glider_detected",
				"unit": "count",
				"default_window": "EMA-16",
				"description": "Number of detected glider classes in the window.",
				"active_when": "enable_point_space_gliders=true",
				"source_examples": ["A.8"]
			  },
			  {
				"name": "glider_canonical_count",
				"unit": "count",
				"default_window": "EMA-16",
				"description": "Stored canonical representatives for glider classes.",
				"active_when": "enable_point_space_gliders=true",
				"source_examples": ["A.8"]
			  }
			]
		  },

		  "validation_rules": [
			"All dashboard.windows and KPI default_window MUST be one of {EMA-16, EMA-32, EMA-64}.",
			"ASCII-only keys across the table; unicode allowed only inside free-text values if present.",
			"Any KPI with 'active_when' MUST be fully absent from dashboards and exports when the condition is false.",
			"Dashboards MAY override KPI default_window only with an allowed EMA window.",
			"Each dashboard.series item MUST correspond to a KPI defined in kpi_catalog."
		  ],

		  "rfc_anchors": ["RFC-0009 ¬ß7.2"],

		  "notes": [
			"This table is authoritative for Appendix A dashboards; examples reference metrics here rather than redefining them.",
			"If a KPI appears on multiple dashboards, the dashboard-local window applies to that panel only; the global default_window remains unchanged."
		  ]
		},

		{
		  "id": "A.10",
		  "title": "Pseudocode Index (Cross-Referenced)",
		  "type": "pseudocode_index",
		  "schema_version": "2025-Q4",
		  "objective": "Collect minimal, observer-class routines referenced by multiple examples (shared helpers for EMA smoothing, replay defense, compression KPIs, TTL checks, lineage decisions, and glider operations).",
		  "rfc_anchors": ["PDP-0001 ¬ß4.5"],

		  "blocks": [
			{
			  "name": "EMA",
			  "anchor": "ema_stream",
			  "signature": "ema_update(state, x, window) -> state'",
			  "inputs": ["state = {m: float, alpha: float, init: bool}", "x: float", "window ‚àà {EMA-16, EMA-32, EMA-64}"],
			  "outputs": ["state' with updated m"],
			  "preconditions": ["window ‚àà {EMA-16, EMA-32, EMA-64}"],
			  "postconditions": ["state'.m is exponentially smoothed", "alpha = 2/(N+1) for N ‚àà {16,32,64}"],
			  "rfc_anchors": ["RFC-0009 ¬ß7.2"],
			  "code": [
				"// if state.init is false, seed with first sample",
				"if not state.init:",
				"    state.m <- x",
				"    state.alpha <- 2/(N+1)  // N from window",
				"    state.init <- true",
				"    return state",
				"",
				"// standard EMA update",
				"state.m <- state.alpha * x + (1 - state.alpha) * state.m",
				"return state"
			  ],
			  "notes": "Used by A.1/A.2/A.8 for KPI smoothing and by A.4 for ŒîœÑ_phase estimation."
			},

			{
			  "name": "seen_set_lru",
			  "anchor": "replay_defense_core",
			  "signature": "seen_set_process(store, key, now, window_ticks, capacity) -> (accepted: bool, store')",
			  "inputs": ["store: map with {key -> (ts_last)} and LRU policy", "key: ASCII tuple", "now: tick", "window_ticks: integer", "capacity: integer"],
			  "outputs": ["accepted: bool", "updated store'"],
			  "preconditions": ["key composition respects feature flags (no checksum fields when flags disabled)"],
			  "postconditions": ["drop if (now - ts_last) ‚â§ window_ticks", "insert key with ts_last=now; evict by LRU if over capacity"],
			  "rfc_anchors": ["RFC-0008 ¬ß2.2", "RFC-0009 ¬ß7.2"],
			  "code": [
				"entry <- store.get(key)",
				"if entry exists and (now - entry.ts_last) <= window_ticks:",
				"    return (false, store)  // replay drop",
				"",
				"// accept and record",
				"store.put(key, {ts_last: now})",
				"if store.size > capacity:",
				"    store.evict_lru(1)",
				"return (true, store)"
			  ],
			  "notes": "Used by A.4/A.7. Observer-only."
			},

			{
			  "name": "compression_snapshot",
			  "anchor": "kpi_compression_snapshot",
			  "signature": "compute_compression_kpis(pre_count, post_count) -> {lcr, eff}",
			  "inputs": ["pre_count: int", "post_count: int"],
			  "outputs": ["lcr: float", "eff: float"],
			  "preconditions": ["pre/post counts measured strictly pre-prune"],
			  "postconditions": ["lcr = post_count / max(pre_count, 1)", "eff = 1 - lcr"],
			  "rfc_anchors": ["RFC-0006 ¬ß4.4", "RFC-0009 ¬ß7.2"],
			  "code": [
				"if pre_count == 0:",
				"    return {lcr: 1.0, eff: 0.0}",
				"lcr <- post_count / pre_count",
				"eff <- 1 - lcr",
				"return {lcr, eff}"
			  ],
			  "notes": "Used by A.1/A.2/A.8."
			},

			{
			  "name": "ttl_floor",
			  "anchor": "ttl_floor_fn",
			  "signature": "ttl_floor(tau_decay, dt_tick) -> ttl_min",
			  "inputs": ["tau_decay: ticks", "dt_tick: ticks"],
			  "outputs": ["ttl_min: ticks"],
			  "preconditions": [],
			  "postconditions": ["ttl_min = max(tau_decay, 10*dt_tick)"],
			  "rfc_anchors": ["RFC-0005 ¬ß4.2", "RFC-0009 ¬ß7.1"],
			  "code": [
				"x <- tau_decay",
				"y <- 10 * dt_tick",
				"return max(x, y)"
			  ],
			  "notes": "Used by A.3."
			},

			{
			  "name": "capacity_evaluator",
			  "anchor": "capacity_eval",
			  "signature": "capacity_evaluator(usage, c_max, theta_sat) -> action",
			  "inputs": ["usage: float", "c_max: float", "theta_sat: fraction"],
			  "outputs": ["action ‚àà {'none','request_compress'}"],
			  "preconditions": ["0 ‚â§ usage ‚â§ c_max", "0 < c_max"],
			  "postconditions": ["request_compress iff usage/c_max ‚â• theta_sat"],
			  "rfc_anchors": ["RFC-0009 ¬ß7.1"],
			  "code": [
				"eta <- usage / c_max",
				"if eta < theta_sat:",
				"    return 'none'",
				"return 'request_compress'"
			  ],
			  "notes": "Used by A.1."
			},

			{
			  "name": "merge_fork_decider",
			  "anchor": "merge_fork_decider",
			  "signature": "merge_fork_decider(A, B) -> decision",
			  "inputs": ["A.parent_hash, A.integrity_hash", "B.parent_hash, B.integrity_hash"],
			  "outputs": ["decision ‚àà {'merge','fork','unrelated'}"],
			  "preconditions": ["hashes are ASCII hex", "RFC-0007 schema already validated"],
			  "postconditions": [
				"merge iff parent_hash and integrity_hash both match",
				"fork iff parent_hash matches and integrity_hash differs",
				"unrelated otherwise"
			  ],
			  "rfc_anchors": ["RFC-0007 ¬ß2", "RFC-0009 ¬ß5.1"],
			  "code": [
				"if A.parent_hash == B.parent_hash and A.integrity_hash == B.integrity_hash:",
				"    return 'merge'",
				"if A.parent_hash == B.parent_hash and A.integrity_hash != B.integrity_hash:",
				"    return 'fork'",
				"return 'unrelated'"
			  ],
			  "notes": "Used by A.5."
			},

			{
			  "name": "reanchor_idempotence_guard",
			  "anchor": "reanchor_guard",
			  "signature": "reanchor_guard(active, key, token) -> allow",
			  "inputs": ["active: map(key -> token)", "key: ASCII tuple", "token: monotonic integer"],
			  "outputs": ["allow: bool"],
			  "preconditions": ["token strictly increases for new attempts on same key"],
			  "postconditions": ["deny duplicate attempt with same token; allow only if token > active[key]"],
			  "rfc_anchors": ["RFC-0009 ¬ß5.2", "PDP-0001 ¬ß4.5"],
			  "code": [
				"t_prev <- active.get(key, default=-inf)",
				"if token <= t_prev:",
				"    return false",
				"active[key] <- token",
				"return true"
			  ],
			  "notes": "Used by A.6 to bound recovery."
			},

			{
			  "name": "glider_class_hash",
			  "anchor": "hash_of_shift_invariants",
			  "signature": "hash_of_shift_invariants(trace_window) -> class_id",
			  "inputs": ["trace_window: sequence of motif features"],
			  "outputs": ["class_id: ASCII hex"],
			  "preconditions": ["invariants computed from shift-stable features"],
			  "postconditions": ["deterministic ASCII hex id for class equivalence"],
			  "rfc_anchors": ["RFC-0006 ¬ß3‚Äì¬ß4"],
			  "code": [
				"f <- extract_shift_invariants(trace_window)  // e.g., normalized autocorrelation bins",
				"bytes <- serialize_ascii(f)",
				"class_id <- sha256_hex(bytes)",
				"return class_id"
			  ],
			  "notes": "Used by A.8. Implementation detail deferred to L2."
			},

			{
			  "name": "shift_operator_apply",
			  "anchor": "apply_S_k",
			  "signature": "apply_S_k(canonical_ref, k_shift) -> recalled_ref",
			  "inputs": ["canonical_ref: handle", "k_shift: integer"],
			  "outputs": ["recalled_ref: handle"],
			  "preconditions": ["canonical_ref exists"],
			  "postconditions": ["pure mapping; no control writes"],
			  "rfc_anchors": ["RFC-0006 ¬ß3"],
			  "code": [
				"return map_shift(canonical_ref, k_shift)"
			  ],
			  "notes": "Used by A.8 recall."
			}
		  ],

		  "validation_rules": [
			"All block names and anchors are ASCII.",
			"Any 'window' parameter MUST be one of {EMA-16, EMA-32, EMA-64}.",
			"Replay keys MUST omit checksum fields when the corresponding feature flags are disabled.",
			"All routines are observer-class: no control writes to Xi."
		  ],

		  "notes": [
			"These blocks are shared helpers; worked examples reference them by anchor.",
			"Mathematical forms (if any) are indexed in A.M; this index contains only procedural sketches."
		  ]
		}
	  ],
	  "global_invariants": [
		{ "name": "ASCII_On_Wire", "condition": "All JSON keys are ASCII; unicode limited to 'latex' strings." },
		{ "name": "Flag_Gating", "condition": "Sigma_phase, Delta_hash, and {class,v,phi,tau} appear only when their flags are enabled." },
		{ "name": "Observer_Only", "condition": "Examples measure/seal/route/validate; no control writes to Œû." },
		{ "name": "Compress_Before_Prune", "condition": "Equivalence compression snapshot precedes any prune." },
		{ "name": "Bounded_Outcomes", "condition": "Recovery terminates in {reanchored, quarantined, abandoned}; no unbounded retries." }
	  ]

	},
  ],
  },
  "_handoff": "Memory coherence preserved; lawful decay and recovery verified. Proceed to Layer_2 application specification (MMM-APP-001) for operational bindings."
}
