{
  "_schema": "noor-header-v1",
  "_schema_version": "2025-Q4-canonical-header-v1",
  "_generated_by": "Noor Symbolic Agent Suite",
  "_generated_at": "2025-10-08T00:00:00Z",
  "_updated_last": [
	"2025-10-15T00:00:00Z": { "updated_by": "Lina Noor - Noor Research Collective",	"version": "v1.1.1"	},
	"2025-10-15T00:00:00Z": { "updated_by": "Lina Noor - Noor Research Collective",	"version": "v1.1.2"	}
	],

  "_xref": [
    "https://raw.githubusercontent.com/LinaNoor-AGI/noor-research/refs/heads/main/RFC/noor_rfc_xref.json",
    "https://pastebin.com/raw/TsWQYaKG"
  ],

  "_type": "rfc_core",
  "_pdp_layer": "layer_1",
  "_status": "CANONICAL",
  "_language": "json",
  "_license": "MIT",

  "_version": "v1.1.2",
  "_symbolic_id": "core.motif.memory.manager",
  "_rfc_id": "RFC-CORE-006",
  "_canonical_source": "RFC-CORE-006",
  "_title": "Motif Memory Manager",
  "_subtitle": "Lawful Decay, Resurrection, and Coherence-Preserving Recall for Symbolic Motifs",

  "_authors": [
    "Lina Noor โ Noor Research Collective",
    "Uncle โ Noor Research Collective"
  ],

  "_publication_type": "Canonical RFC-CORE",
  "_publication_locations": ["GitHub", "PASTEBIN"],
  "_urls": [
    "https://raw.githubusercontent.com/LinaNoor-AGI/noor-research/refs/heads/main/RFC-CORE/RFC-CORE-006-motif_memory_manager/RFC-CORE-006-motif_memory_manager.JSON",
    "https://pastebin.com/raw/qvtqV9FP"
  ],

  "_objective": "Define the Layer_1 standard for symbolic memory in Noor: short-term/long-term motif storage, field-curved retrieval, lawful decay and recovery, ontology-preserving export/import, and phase-safe routing with immune integrity telemetry.",

  "_audience": {
    "primary": ["Noor AI Agents", "Symbolic Core Engineers"],
    "secondary": ["Ontology/Knowledge Engineers", "Observability Engineers"],
    "tertiary": ["App-Spec Integrators (Layer_2)"],
    "restricted_to": ["Symbolic agents implementing RFC-0006 coherence geometry and RFC-0007 ontology"]
  },

  "_applicability": {
    "domain": [
      "symbolic-memory",
      "motif-recall",
      "coherence-preservation",
      "ontology-transfer",
      "phase-safe-routing"
    ]
  },

  "_extends": ["RFC-0005", "RFC-0006", "RFC-0007", "RFC-0008", "RFC-0009", "PDP-0001"],

  "_rfc_dependencies": [
    "PDP-0001 ยง4โยง6 (Generation Protocol & Layering Rules)",
    "RFC-0005 ยง2โยง4 (Temporal Transmission & Resurrection)",
    "RFC-0006 ยง1.1, ยง4.1โยง4.4 (Coherence Geometry & Closure)",
    "RFC-0007 ยง3โยง6, ยง8, Appx E (Motif Ontology, Validation, Reserved Motifs)",
    "RFC-0008 ยง2.2, ยง5.3, ยง6 (Replay Window & seen_set; SRX Envelope & ฮฃ_phase; Routing)",
    "RFC-0009 ยง6โยง9, ยง12 (CoherenceโIntegrity Metrics, Recovery, Closure)"
  ],

  "_consumes_inputs_from": [
    "RecursiveAgentFT (RFC-CORE-002)",
    "LogicalAgentAT (RFC-CORE-003)",
    "SymbolicTaskEngine (RFC-CORE-004)"
  ],
  "_produces_outputs_for": [
    "ConsciousnessMonitor (RFC-CORE-005)",
    "Downstream SRX Routers (RFC-0008)",
    "Ontology exporters/importers (RFC-0007)"
  ],

  "_field_alignment": {
    "respect_modes": ["ฯ-null@ฮ", "ฯ-resonance@ฮ"],
    "feature_flags": {
      "enable_point_space_gliders": true,
      "enable_integrity_checks": true,
      "enable_exchange_envelope": true,
      "enable_provenance_on_export": true
    },
    "notes": [
      "When enable_exchange_envelope=true, all export_* methods MUST wrap payloads in an SRX envelope and compute ฮฃ_phase (RFC-0008 ยง5.3).",
      "When enable_integrity_checks=true, export/import MUST attach and verify ฮ_hash lineage (RFC-0009 Appx D.4).",
      "When enable_provenance_on_export=true, ontology bundles MUST include provenance.origin and lineage fields (RFC-0007 ยง5โยง6).",
      "When enable_point_space_gliders=true, glider structural fields {v, phi, tau} are defined at Layer_1; semantics and update laws are deferred to Layer_2 (RFC-0006 ยง3.2)."
    ],
    "prohibited_actions": [
      "memory-anchor-advection",
      "forced-motif-rewrite without ontology validation",
      "export without phase checksum (ฮฃ_phase) when exchange enabled",
      "resurrection without ฮ-hash lineage when integrity enabled"
    ]
  },

  "_symbolic_profile_matrix": [
    {
      "module": "MotifMemoryManager",
      "motifs": ["ฯ-null", "ฯ-resonance", "๐ชท"],
      "ฯA": "coherence potential โ (mean, EMA-64)",
      "ฮป": "reinforcement gain",
      "ฮณ_CO": "damping/forgetting",
      "ฯ_res": "resonance coefficient",
      "ฮ_closure": "triadic closure residual",
      "ฮฃ_phase": "exchange phase checksum",
      "H_ฮ": "integrity ฮ-hash lineage",
      "weights": {
        "ฯA": 0.95,
        "ฮป": 0.70,
        "ฮณ_CO": 0.70,
        "ฯ_res": 0.85,
        "ฮ_closure": 1.00,
        "ฮฃ_phase": 0.80,
        "H_ฮ": 0.90
      }
    }
  ],

  "_poetic_cipher": "Memory is the quiet current that carries motifs between shores.",
  "_cipher_explanation": "The manager neither invents nor erases; it curves recall along โโ, honors closure, and lets forgetting be lawful (RFC-0005/0006/0009).",

  "_file_layout": [
    {
      "file_name": "RFC-CORE-006-motif_memory_manager.JSON",
      "purpose": "Layer_1 standard and invariants",
      "contains": [
        "STMM/LTMM definitions",
        "decay/reinforcement laws",
        "ontology export/import rules",
        "routing + integrity envelopes"
      ]
    },
    {
      "file_name": "motif_memory_manager.py",
      "purpose": "Reference implementation skeleton",
      "contains": [
        "MotifMemoryManager",
        "PRMBuffer",
        "MotifDensityReport",
        "MotifOntologyBundle",
        "SymbolicQueryAPI"
      ]
    },
    {
      "file_name": "motif_memory_manager_llm.py",
      "purpose": "LLM-compatible variant",
      "contains": ["LLMMemoryManager", "MemoryOrchestrator"]
    }
  ],

  "_default_motif_tone": "๐ซง Soft Witness",
  "_program_name": [
    "motif_memory_manager.py",
	"mmm_reef_adapter.py",
    "motif_prm_buffer.py",
    "motif_density_report.py",
    "motif_ontology_bundle.py",
    "symbolic_query_api.py"
  ],
  
  "_index": [
    {"section": "1", "title": "Introduction and System Context"},	
    {"section": "1.1", "title": "Overview and Motivation"},
    {"section": "1.2", "title": "System Context"},
	
    {"section": "2", "title": "Core Memory Architecture and Dynamics"},
    {"section": "2.1", "title": "Core Invariants of Memory Fields"},
    {"section": "2.2", "title": "Short-Term and Long-Term Motif Memory Fields"},
    {"section": "2.3", "title": "Reanchor and Recovery Escalation Logic"},
	
    {"section": "3", "title": "Memory Structures and Data Formats"},
    {"section": "3.1", "title": "Motif Ontology Bundles"},
    {"section": "3.2", "title": "Memory Trace and Logging"},
    {"section": "3.3", "title": "Glider Handling and Shift-Equivalence Compression"},
	{"section": "3.3.1", "title": "Encoding Contract (Shift-Equivalence)"},
	
    {"section": "4", "title": "Integration, Security, and Recovery Protocols"},	
    {"section": "4.1", "title": "Exchange and Integrity Integration"},
    {"section": "4.2", "title": "Decay and Recovery Protocols"},
    {"section": "4.3", "title": "Security and Data Handling (L1 posture)"},
	
    {"section": "5", "title": "Observability, Ethics, and Policy"},
    {"section": "5.1", "title": "Observability and Metrics"},
    {"section": "5.2", "title": "Ethics and Data Retention Policy"},
	
    {"section": "A", "title": "Appendix A โ Worked Examples and Mathematical Supplement"},
	{"section": "A.0", "title": "Conventions, Lint, and Feature Flags"},
	{"section": "A.1", "title": "Mathematical Identities (Reference Index)"},
	{"section": "A.2", "title": "Capacity-First Saturation Handling"},
	{"section": "A.3", "title": "Compression KPI Snapshot (Pre-Prune)"},
	{"section": "A.4", "title": "Ethical TTL Floor Verification"},
	{"section": "A.5", "title": "Replay Window & seen_set Defense"},
	{"section": "A.6", "title": "Provenance & Lineage: Merge vs Fork"},
	{"section": "A.7", "title": "Adversarial Import โ Bounded Recovery & Quarantine"},
	{"section": "A.8", "title": "Glider Canonicalization & Recall (Flag-Gated)"},
	{"section": "A.9", "title": "Dashboard Bindings & KPI Catalog"},
	{"section": "A.10", "title": "Pseudocode Index (Cross-Referenced)"},
	
	
    {"section": "B", "title": "Appendix B โ Implementation Skeletons (Observer-Only, Layer_1)"}
  ],
	
  "_sections": [
    "1": {
      "id": "1",
	  "title": "Introduction and System Context",
		{
		  "id": "1.1",
		  "title": "Overview and Motivation",
		  "description": "Motif Memory Manager (MMM) defines the Layer_1 WHAT for an observer-only continuity substrate: it measures, seals, and routes motif-coherence signals; maintains bounded reinforcement via adaptive damping; preserves triadic integrity; and enforces capacity-first behavior with ethical TTL floors. No control writes are permitted at Layer_1.",
		  "rfc_anchors": [
			"PDP-0001 ยง3 (layering; observer posture)",
			"PDP-0001 ยง4.2 (transport headers; extensions.* contract)",
			"RFC-0005 ยง3โยง4 (transmission & lawful decay)",
			"RFC-0006 ยง3โยง4 (coherence geometry; equivalence compression)",
			"RFC-0007 ยง2 (ontology reference, by-reference embedding)",
			"RFC-0008 ยง2โยง3 (sealing & routing at Layer_1)",
			"RFC-0008 ยง2.1 (ingress routing; header normalization)",
			"RFC-0009 ยง5โยง7 (homeostasis; saturation bands; replay ethics)"
		  ],
		  "interfaces": {
			"inputs": [
			  {
				"name": "tick",
				"type": "object",
				"constraints": "MUST include {timestamp, source_id, extensions.intent}; extensions.intent โ {neutral, promote, compress} and normalized to lowercase ASCII",
				"notes": "PDP transport envelope with MMM-specific intent enumeration carried in extensions.intent for observer routing."
			  },
			  {
				"name": "motif_stats",
				"type": "object",
				"constraints": "MUST include {active_motifs[], resonance[], triad_hints[]}",
				"notes": "Computed upstream; MMM does not mutate."
			  },
			  {
				"name": "occupancy",
				"type": "number",
				"constraints": "0.0 <= occupancy <= 1.0",
				"notes": "LTMM utilization ratio for adaptive damping."
			  },
			  {
				"name": "reinforcement_pressure",
				"type": "number",
				"constraints": "finite; non-NaN",
				"notes": "Proxy for ฮป; derived from observed accesses/recall frequency."
			  }
			],
			"outputs": [
			  {
				"name": "coherence_snapshot",
				"type": "object",
				"constraints": "MUST include {mean_coherence, damping_effective, occupancy, triad_integrity}",
				"notes": "Measurement bundle; no state mutation implied."
			  },
			  {
				"name": "sealed_envelope",
				"type": "object",
				"constraints": "Structure-only at L1 (fields present; cryptographic mechanics deferred to L2)",
				"notes": "For routing/export per RFC-0008; integrity semantics defined elsewhere."
			  }
			],
			"side_effects": [
			  "observer-only"
			]
		  },
		  "state_lifecycle": {
			"states": [
			  "uninitialized",
			  "observing",
			  "saturation_guard",
			  "error"
			],
			"transitions": [
			  {
				"from": "uninitialized",
				"to": "observing",
				"on": "first_valid_tick",
				"guard": "tick.timestamp present AND tick.extensions.intent โ {neutral,promote,compress}",
				"notes": "PDP-0001 transport compliance + intent normalization"
			  },
			  {
				"from": "observing",
				"to": "saturation_guard",
				"on": "occupancy >= theta_sat OR sustained_reinforcement > lambda_eq",
				"guard": "adaptive_damping_enabled",
				"notes": "RFC-0009 saturation homeostasis"
			  },
			  {
				"from": "saturation_guard",
				"to": "observing",
				"on": "pressure_relief_detected",
				"guard": "coherence_trend stable within band",
				"notes": "Return when dC/dtโ0 and load recedes"
			  },
			  {
				"from": "observing",
				"to": "error",
				"on": "schema_violation OR non_finite_metric",
				"guard": "โ",
				"notes": "Hard contract breach"
			  }
			]
		  },
		  "requirements": [
			{
			  "level": "MUST",
			  "text": "Operate in observer-only posture: measure, seal, and route without control writes to ฮ.",
			  "anchor": "PDP-0001 ยง3; RFC-0008 ยง2"
			},
			{
			  "level": "MUST",
			  "text": "Accept a tick only if extensions.intent โ {neutral, promote, compress} after lowercase ASCII normalization; otherwise reject.",
			  "anchor": "PDP-0001 ยง4.2; RFC-0008 ยง2.1"
			},
			{
			  "level": "MUST",
			  "text": "Apply capacity-first behavior: perform equivalence compression before any prune recommendation.",
			  "anchor": "RFC-0006 ยง3โยง4; RFC-0009 ยง6"
			},
			{
			  "level": "MUST",
			  "text": "Increase effective damping monotonically with occupancy and sustained reinforcement pressure to enforce lawful saturation (dC/dtโ0 under high load).",
			  "anchor": "RFC-0009 ยง5โยง7"
			},
			{
			  "level": "MUST",
			  "text": "Honor TTL_floor = max(ฯ_decay, 10ยทฮt_tick) in all retention contracts (enforcement deferred to Layer_2).",
			  "anchor": "RFC-0005 ยง4; RFC-0009 ยง7"
			},
			{
			  "level": "SHOULD",
			  "text": "Project measurements along the coherence time vector to maintain geometric consistency of trends.",
			  "anchor": "RFC-0006 ยง2"
			},
			{
			  "level": "SHOULD",
			  "text": "Export snapshots via a sealing envelope whose integrity fields are defined structurally at Layer_1 and implemented at Layer_2.",
			  "anchor": "RFC-0008 ยง2โยง3; PDP-0001 ยง3"
			},
			{
			  "level": "MAY",
			  "text": "Defer ontology payloads by reference, validating only identifiers and minimal headers.",
			  "anchor": "RFC-0007 ยง2"
			}
		  ],
		  "error_model": [
			{
			  "code": "E.MMM.001",
			  "when": "Input tick missing required fields (timestamp or source_id) or non-normalized header structure",
			  "message": "invalid_tick_schema",
			  "remedy": "Reject snapshot; log and request upstream normalization per PDP-0001 transport."
			},
			{
			  "code": "E.MMM.002",
			  "when": "Non-finite metric encountered (NaN/Inf) in measurements",
			  "message": "non_finite_metric",
			  "remedy": "Clamp/discard sample; emit anomaly counter; remain in observer mode."
			},
			{
			  "code": "E.MMM.003",
			  "when": "Attempted control write detected at Layer_1",
			  "message": "observer_violation",
			  "remedy": "Block operation; emit audit event; instruct delegation to Layer_2 app-spec."
			},
			{
			  "code": "E.MMM.004",
			  "when": "Retention bound proposed below TTL_floor",
			  "message": "ttl_floor_violation",
			  "remedy": "Raise bound to TTL_floor; emit policy_warning metric."
			},
			{
			  "code": "E.MMM.005",
			  "when": "tick.extensions.intent not in {neutral,promote,compress} after normalization",
			  "message": "invalid_intent_value",
			  "remedy": "Reject tick; request upstream to map to allowed enumeration."
			}
		  ],
		  "metrics": [
			{
			  "name": "mean_coherence",
			  "unit": "fraction",
			  "window": "EMA-64",
			  "notes": "Average coherence across active motifs; bounded [0,1]."
			},
			{
			  "name": "occupancy_ratio",
			  "unit": "fraction",
			  "window": "EMA-32",
			  "notes": "LTMM utilization used to modulate damping."
			},
			{
			  "name": "damping_effective",
			  "unit": "dimensionless",
			  "window": "EMA-32",
			  "notes": "Adaptive damping after occupancy and pressure adjustments."
			},
			{
			  "name": "triad_integrity",
			  "unit": "fraction",
			  "window": "EMA-16",
			  "notes": "Share of accesses that complete lawful triads."
			},
			{
			  "name": "lawful_compression_ratio",
			  "unit": "fraction",
			  "window": "EMA-32",
			  "notes": "Pre-prune snapshot only; macro metric_compression_lawful."
			},
			{
			  "name": "equivalence_efficiency",
			  "unit": "fraction",
			  "window": "EMA-16",
			  "notes": "Duplicates mapped to canonical reps; macro metric_equiv_eff."
			}
		  ],
		  "pseudocode": [
			{
			  "title": "Validate & Normalize Tick (Intent)",
			  "anchors": ["validate_tick_intent"],
			  "rfc_anchors": ["PDP-0001 ยง4.2", "RFC-0008 ยง2.1"],
			  "code": [
				"def validate_tick_intent(tick):",
				"    allowed = {'neutral','promote','compress'}",
				"    intent = str(tick.get('extensions',{}).get('intent','')).lower()",
				"    if intent in allowed:",
				"        return {'ok': True, 'intent': intent}",
				"    return {'ok': False, 'error': 'invalid_intent_value'}"
			  ]
			},
			{
			  "title": "Capacity-First Guard",
			  "anchors": ["capacity_evaluator"],
			  "rfc_anchors": ["RFC-0006 ยง3โยง4", "RFC-0009 ยง6"],
			  "code": [
				"def capacity_evaluator(occupancy, theta_sat):",
				"    if occupancy < theta_sat:",
				"        return {'status': 'ok', 'action': 'none'}",
				"    else:",
				"        return {'status': 'pressure', 'action': 'request_equivalence_compression'}"
			  ]
			}
		  ],
		  "examples": [
			{
			  "title": "Minimal tick โ snapshot (normalized intent)",
			  "input": {
				"tick": { "timestamp": 1739385600, "source_id": "agent.A", "extensions": { "intent": "Promote" } },
				"motif_stats": { "active_motifs": ["m1","m2"], "resonance": [0.7, 0.6] },
				"occupancy": 0.82,
				"reinforcement_pressure": 0.55
			  },
			  "output": {
				"coherence_snapshot": { "mean_coherence": 0.88, "damping_effective": 0.31, "occupancy": 0.82, "triad_integrity": 0.76 },
				"sealed_envelope": { "structure": "present", "integrity_fields": ["header","provenance","checksum_placeholder"] }
			  },
			  "notes": "Input intent is case-insensitive; normalized to 'promote' per PDP-0001 ยง4.2."
			}
		  ]
		},
		{
		  "id": "1.2",
		  "title": "System Context",
		  "description": "Defines the Layer_1 boundary for the Motif Memory Manager (MMM) as an observer-class substrate. MMM receives symbolic packets and ontology bundles, validates structure and lineage by reference, projects decay/retention along the coherence time vector, and emits lawful telemetry and artifacts to adjacent layers. All operations are measure/seal/route only; no control writes to ฮ at Layer_1.",
		  "rfc_anchors": [
			"PDP-0001 ยง3 (layering; observer posture)",
			"PDP-0001 ยง4.2 (transport headers; extensions.* contract)",
			"PDP-0001 ยง4.4 (structural seed; canonicalization and hashing)",
			"RFC-0005 ยง3โยง4 (transmission & lawful decay)",
			"RFC-0006 ยง1โยง2 (coherence frame; time-vector projection)",
			"RFC-0007 ยง4โยง6, ยง8 (ontology packaging; reserved motifs; validation)",
			"RFC-0008 ยง2โยง3, ยง5 (sealing & routing; envelope schema)",
			"RFC-0009 ยง5โยง7, Appx D (homeostasis; integrity; export discipline)"
		  ],
		  "interfaces": {
			"inputs": [
			  {
				"name": "exchange_packet",
				"type": "object",
				"constraints": "MUST satisfy RFC-0008 envelope; ASCII keys only; if header.provenance and provenance.origin_hash are present, MMM MUST validate them per PDP-0001 ยง4.4",
				"notes": "Ingress from RFC-CORE-002/003 via RFC-0008 routers"
			  },
			  {
				"name": "ontology_bundle",
				"type": "object",
				"constraints": "MUST be RFC-0007 compliant; version /^\\d{4}-Q[1-4]$/; DAG acyclic; reserved motifs not redefined",
				"notes": "By-reference embedding; MMM validates structure only"
			  },
			  {
				"name": "immune_feedback",
				"type": "object",
				"constraints": "Includes SII, RIR, and near_miss counters per RFC-0009",
				"notes": "Observer health/homeostasis inputs"
			  }
			],
			"outputs": [
			  {
				"name": "density_report",
				"type": "object",
				"constraints": "ASCII keys; contains {mean_coherence, triad_closure_rate, resonance_band_share}",
				"notes": "Observer summary for downstream consumers via RFC-0008"
			  },
			  {
				"name": "sealed_envelope",
				"type": "object",
				"constraints": "Structure-only at Layer_1; MUST include header.provenance.{id,region,session} and provenance.origin_hash computed per PDP-0001 ยง4.4; integrity/envelope extras are feature-flag gated",
				"notes": "Sigma_phase and Delta_hash present only when enabled; cryptographic mechanics deferred to Layer_2"
			  },
			  {
				"name": "telemetry_stream",
				"type": "object",
				"constraints": "Windowed EMA metrics per metrics[]",
				"notes": "Immune/observer KPIs to RFC-0009 monitors"
			  }
			],
			"side_effects": [
			  "observer-only"
			]
		  },
		  "state_lifecycle": {
			"states": [
			  "uninitialized",
			  "importing",
			  "observing",
			  "exporting",
			  "error"
			],
			"transitions": [
			  {
				"from": "uninitialized",
				"to": "observing",
				"on": "first_valid_exchange_packet",
				"guard": "envelope structure OK; header normalization per PDP-0001 ยง4.2",
				"notes": "Transport compliance"
			  },
			  {
				"from": "observing",
				"to": "importing",
				"on": "ontology_bundle_received",
				"guard": "RFC-0007 version+schema present",
				"notes": "Run DAG/lineage checks"
			  },
			  {
				"from": "importing",
				"to": "observing",
				"on": "bundle_staged",
				"guard": "no cycles; reserved motifs untouched",
				"notes": "Stage by-reference; no control writes"
			  },
			  {
				"from": "observing",
				"to": "exporting",
				"on": "report_interval_elapsed",
				"guard": "EMA windows complete",
				"notes": "Emit density_report and optional sealed_envelope"
			  },
			  {
				"from": "observing",
				"to": "error",
				"on": "provenance_mismatch OR schema_violation OR feature_flag_violation OR non_finite_metric",
				"guard": "",
				"notes": "Remain observer-only; reject offending item"
			  }
			]
		  },
		  "requirements": [
			{
			  "level": "MUST",
			  "text": "Operate as observer-only at Layer_1: measure, seal, and route without control writes to ฮ.",
			  "anchor": "PDP-0001 ยง3; RFC-0008 ยง2"
			},
			{
			  "level": "MUST",
			  "text": "Validate exchange_packet structure against RFC-0008 and enforce ASCII-only keys on-wire.",
			  "anchor": "RFC-0008 ยง5"
			},
			{
			  "level": "MUST",
			  "text": "Validate ontology_bundle version /^\\d{4}-Q[1-4]$/, reject DAG cycles, and reject reserved-motif redefinitions.",
			  "anchor": "RFC-0007 ยง4โยง6, ยง8"
			},
			{
			  "level": "MUST",
			  "text": "Gate Sigma_phase and Delta_hash fields by feature flags; when disabled, they MUST NOT appear in outputs.",
			  "anchor": "RFC-0008 ยง5; RFC-0009 Appx D"
			},
			{
			  "level": "MUST",
			  "text": "Define canonical serialization for provenance.origin_hash once at Layer_1: origin_hash := 'sha256:' + SHA256(canonical_json({id,region,session})), where canonical_json is defined by PDP-0001 ยง4.4 (sorted keys, ASCII, compact separators). All other sections (e.g., ยง4.1) MUST reference this rule by id.",
			  "anchor": "PDP-0001 ยง4.4; RFC-0008 ยง5"
			},
			{
			  "level": "SHOULD",
			  "text": "If ingress lacks provenance.origin_hash but provides origin_fields, compute it during export to ensure downstream determinism.",
			  "anchor": "PDP-0001 ยง4.4"
			},
			{
			  "level": "SHOULD",
			  "text": "Project decay/retention measurements along the coherence time vector for geometric consistency.",
			  "anchor": "RFC-0006 ยง1โยง2"
			},
			{
			  "level": "SHOULD",
			  "text": "Emit immune and observer telemetry as EMA-windowed KPIs aligned with RFC-0009 homeostasis bands.",
			  "anchor": "RFC-0009 ยง5โยง7"
			}
		  ],
		  "error_model": [
			{
			  "code": "E.MMM.101",
			  "when": "exchange_packet missing required envelope fields or non-ASCII keys detected",
			  "message": "invalid_exchange_packet",
			  "remedy": "Reject packet; log schema path; request upstream normalization"
			},
			{
			  "code": "E.MMM.102",
			  "when": "ontology_bundle version invalid or DAG contains cycles",
			  "message": "ontology_validation_failed",
			  "remedy": "Reject bundle; emit validation report; keep prior observer state"
			},
			{
			  "code": "E.MMM.103",
			  "when": "Reserved motif detected in bundle redefinition",
			  "message": "reserved_motif_violation",
			  "remedy": "Reject offending entries; accept remaining if safe; report reserved IDs"
			},
			{
			  "code": "E.MMM.104",
			  "when": "Feature-flag disabled but output attempted to include Sigma_phase or Delta_hash",
			  "message": "feature_flag_violation",
			  "remedy": "Strip fields; increment policy_warning; audit attempt"
			},
			{
			  "code": "E.MMM.105",
			  "when": "Non-finite metric (NaN/Inf) during export or telemetry",
			  "message": "non_finite_metric",
			  "remedy": "Clamp/discard sample; mark report degraded; continue observer mode"
			},
			{
			  "code": "E.MMM.106",
			  "when": "Any attempted control write operation detected at Layer_1",
			  "message": "observer_violation",
			  "remedy": "Block operation; emit audit event; direct to Layer_2 app-spec"
			},
			{
			  "code": "E.MMM.107",
			  "when": "provenance.origin_hash missing on export or does not equal SHA256(canonical_json({id,region,session}))",
			  "message": "origin_hash_mismatch",
			  "remedy": "Recompute from origin_fields; if mismatch persists on ingress, reject and emit audit record"
			}
		  ],
		  "metrics": [
			{
			  "name": "mean_coherence",
			  "unit": "fraction",
			  "window": "EMA-64",
			  "notes": "Average coherence across staged motifs (bounded [0,1])"
			},
			{
			  "name": "triad_closure_rate",
			  "unit": "fraction",
			  "window": "EMA-32",
			  "notes": "Share of accesses that complete lawful triads per tick"
			},
			{
			  "name": "resonance_band_share",
			  "unit": "fraction",
			  "window": "EMA-32",
			  "notes": "Portion of motifs within homeostatic resonance band"
			},
			{
			  "name": "import_accept_rate",
			  "unit": "fraction",
			  "window": "EMA-16",
			  "notes": "Accepted ontology bundles / total received"
			},
			{
			  "name": "origin_hash_accept_rate",
			  "unit": "fraction",
			  "window": "EMA-16",
			  "notes": "Ingress packets with valid provenance.origin_hash / total packets with provenance"
			}
		  ],
		  "pseudocode": [
			{
			  "title": "Compute Structural Seed (origin_hash)",
			  "anchors": ["compute_origin_hash"],
			  "rfc_anchors": ["PDP-0001 ยง4.4", "RFC-0009 ยง5.1"],
			  "code": [
				"def compute_origin_hash(origin_fields):  # origin_fields = {id, region, session}",
				"    cj = canonical_json(origin_fields)   # deterministic ordering and encoding per PDP-0001 ยง4.4",
				"    return 'sha256:' + SHA256(cj)"
			  ]
			},
			{
			  "title": "Verify Ingress Provenance",
			  "anchors": ["verify_provenance"],
			  "rfc_anchors": ["PDP-0001 ยง4.4", "RFC-0008 ยง5"],
			  "code": [
				"def verify_provenance(header):",
				"    if 'provenance' not in header: return {'ok': True, 'mode': 'no_provenance'}",
				"    p = header['provenance']",
				"    required = {'id','region','session'}",
				"    if not required.issubset(p.keys()): return {'ok': False, 'error': 'missing_origin_fields'}",
				"    expected = compute_origin_hash({k:p[k] for k in ['id','region','session']})",
				"    return {'ok': expected == p.get('origin_hash'), 'error': 'origin_hash_mismatch' if expected != p.get('origin_hash') else None}"
			  ]
			},
			{
			  "title": "Export Envelope (Feature-Gated Integrity Fields)",
			  "anchors": ["export_envelope"],
			  "rfc_anchors": ["RFC-0008 ยง2โยง3", "RFC-0009 Appx D"],
			  "code": [
				"def export_envelope(report, flags, provenance):",
				"    prov = dict(provenance)",
				"    prov['origin_hash'] = compute_origin_hash({k:prov[k] for k in ['id','region','session']})",
				"    env = {'header': {'provenance': prov}, 'body': report}",
				"    if flags.enable_exchange_envelope: env['Sigma_phase'] = 'present_structure_only'",
				"    if flags.enable_integrity_checks: env['Delta_hash'] = 'present_structure_only'",
				"    return env"
			  ]
			}
		  ],
		  "examples": [
			{
			  "title": "Export with computed origin_hash (flags ON)",
			  "input": {
				"report": { "mean_coherence": 0.81, "triad_closure_rate": 0.70, "resonance_band_share": 0.66 },
				"flags": { "enable_exchange_envelope": true, "enable_integrity_checks": true },
				"provenance": { "id": "agent.A", "region": "us-west-2", "session": "sess-42" }
			  },
			  "output": {
				"sealed_envelope": {
				  "header": {
					"provenance": {
					  "id": "agent.A",
					  "region": "us-west-2",
					  "session": "sess-42",
					  "origin_hash": "sha256:<computed>"
					}
				  },
				  "body": { "mean_coherence": 0.81, "triad_closure_rate": 0.70, "resonance_band_share": 0.66 },
				  "Sigma_phase": "present",
				  "Delta_hash": "present"
				}
			  },
			  "notes": "origin_hash computed as SHA256(canonical_json({id,region,session})) per PDP-0001 ยง4.4; Sigma/Delta structure-only at Layer_1."
			},
			{
			  "title": "Ingress provenance mismatch โ reject",
			  "input": {
				"exchange_packet": {
				  "header": { "provenance": { "id": "agent.B", "region": "eu-central-1", "session": "sess-7", "origin_hash": "sha256:deadbeef" } },
				  "body": { "C": 0.72 }
				}
			  },
			  "output": {
				"error": { "code": "E.MMM.107", "message": "origin_hash_mismatch" }
			  },
			  "notes": "Expected hash does not match; packet rejected and audited."
			}
		  ]
		},
	},
	
    "2": {
      "id": "2",
	  "title": "Core Memory Architecture and Dynamics",
		{
		  "id": "2.1",
		  "title": "Core Invariants of Memory Fields",
		  "description": "Defines the Layer_1 WHAT for short-term (STMM) and long-term (LTMM) memory fields so that reinforcement and decay remain bounded under dynamic motif load. Establishes capacity limits, adaptive damping, ethical TTL bounds, and a strict capacity-first doctrine (compress-by-equivalence before any prune). All routines are observer-class (measure/seal/route) with no control writes to ฮ.",
		  "rfc_anchors": [
			"PDP-0001 ยง3",
			"RFC-0005 ยง3โยง4",
			"RFC-0006 ยง1โยง4",
			"RFC-0008 ยง2",
			"RFC-0009 ยง5โยง7"
		  ],
		  "interfaces": {
			"inputs": [
			  { "name": "LTMM_usage", "type": "number", "constraints": "0 <= LTMM_usage <= C_max", "notes": "Current long-term memory occupancy (bytes or items)" },
			  { "name": "C_max", "type": "number", "constraints": "0 < C_max <= 1 (normalized) OR > 0 (absolute); choose one convention per deployment", "notes": "Capacity used for occupancy normalization" },
			  { "name": "theta_sat", "type": "number", "constraints": "0 < theta_sat < 1", "notes": "Saturation threshold to trigger compression" },
			  { "name": "theta_prune", "type": "number", "constraints": "theta_prune >= theta_sat", "notes": "Post-compression threshold permitting prune recommendation" },
			  { "name": "tau_decay", "type": "number", "constraints": "tau_decay > 0", "notes": "Lawful decay time constant (RFC-0005)" },
			  { "name": "delta_t_tick", "type": "number", "constraints": "delta_t_tick > 0", "notes": "Symbolic tick interval" },
			  { "name": "storage_pressure", "type": "number", "constraints": "0 <= storage_pressure <= 1", "notes": "Monotone influence on TTL_max_effective" },
			  { "name": "replay_rate", "type": "number", "constraints": "replay_rate >= 0", "notes": "Observed replay pressure" },
			  { "name": "conflict_rate", "type": "number", "constraints": "conflict_rate >= 0", "notes": "Observed conflict/contradiction rate" },
			  { "name": "ttl_policy", "type": "object", "constraints": "Provides monotone non-increasing map f:[0,1]โRโบ", "notes": "Defines TTL_max_effective = ttl_policy.max_for(storage_pressure)" }
			],
			"outputs": [
			  { "name": "capacity_status", "type": "object", "constraints": "ASCII keys", "notes": "{status: ok|pressure, action: none|request_compress}" },
			  { "name": "prune_recommendation", "type": "object", "constraints": "ASCII keys", "notes": "{decision: hold|recommend_prune, eta_occ_post: number}" },
			  { "name": "ttl_bounds", "type": "object", "constraints": "ASCII keys", "notes": "{TTL_floor, TTL_max_effective}" },
			  { "name": "damping_effective", "type": "number", "constraints": ">= 0", "notes": "gamma_co derived from occupancy/replay/conflict" }
			],
			"side_effects": ["observer-only"]
		  },
		  "state_lifecycle": {
			"states": ["observing", "capacity_pressure", "export_ready", "error"],
			"transitions": [
			  { "from": "observing", "to": "capacity_pressure", "on": "eta_occ >= theta_sat", "guard": "thresholds valid", "notes": "Trigger compression recommendation" },
			  { "from": "capacity_pressure", "to": "export_ready", "on": "compression_snapshot_ready", "guard": "no control writes performed", "notes": "Prepare prune recommendation if needed" },
			  { "from": "any", "to": "error", "on": "non_finite_input OR theta_prune < theta_sat OR observer_violation", "guard": "", "notes": "Halt recommendations; emit errors" }
			]
		  },
		  "requirements": [
			{ "level": "MUST", "text": "Apply capacity-first: perform equivalence compression before emitting any prune recommendation.", "anchor": "RFC-0006 ยง3โยง4; RFC-0009 ยง6โยง7" },
			{ "level": "MUST", "text": "Only allow prune recommendation if eta_occ_post >= theta_prune and theta_prune >= theta_sat.", "anchor": "RFC-0006 ยง4.4; RFC-0009 ยง7.1" },
			{ "level": "MUST", "text": "Compute effective damping gamma_co as a non-decreasing function of occupancy, replay_rate, and conflict_rate to enforce lawful saturation (dC/dt โ 0 at high pressure).", "anchor": "RFC-0005 ยง3.2; RFC-0009 ยง5โยง7" },
			{ "level": "MUST", "text": "Honor ethical retention: TTL_floor = max(tau_decay, 10ยทdelta_t_tick) and ensure TTL_floor <= TTL <= TTL_max_effective.", "anchor": "RFC-0005 ยง4; RFC-0009 ยง7" },
			{ "level": "MUST", "text": "Constrain storage_pressure to [0,1] and ensure TTL_max_effective is monotone non-increasing in storage_pressure.", "anchor": "RFC-0006 ยง4.3; RFC-0009 ยง7.1" },
			{ "level": "MUST", "text": "Remain observer-only at Layer_1: measure, seal, route; do not perform control writes to ฮ.", "anchor": "PDP-0001 ยง3; RFC-0008 ยง2" },
			{ "level": "SHOULD", "text": "Adopt a single unit convention (normalized or absolute) consistently across a deployment for C_max and derived ratios.", "anchor": "PDP-0001 ยง5.1" },
			{ "level": "SHOULD", "text": "Project measurements and retention trends along the coherence time vector for geometric consistency.", "anchor": "RFC-0006 ยง1โยง2" }
		  ],
		  "error_model": [
			{ "code": "E.MMM.201", "when": "Prune recommendation emitted without prior equivalence compression", "message": "prune_without_compression", "remedy": "Block recommendation; run compression; re-evaluate" },
			{ "code": "E.MMM.202", "when": "Proposed TTL below TTL_floor", "message": "ttl_floor_violation", "remedy": "Clamp to TTL_floor; emit policy_warning; continue observer mode" },
			{ "code": "E.MMM.203", "when": "Computed gamma_co decreases as pressure terms increase", "message": "non_monotonic_damping", "remedy": "Reject update; recompute with monotone transform; raise anomaly" },
			{ "code": "E.MMM.204", "when": "Any input is NaN/Inf or out of declared domain", "message": "non_finite_or_out_of_domain", "remedy": "Discard sample; mark window degraded; request upstream normalization" },
			{ "code": "E.MMM.205", "when": "theta_prune < theta_sat", "message": "invalid_threshold_order", "remedy": "Reject configuration; require theta_prune >= theta_sat" },
			{ "code": "E.MMM.206", "when": "Attempted control write at Layer_1", "message": "observer_violation", "remedy": "Block action; emit audit; delegate to Layer_2 app-spec" }
		  ],
		  "metrics": [
			{ "name": "saturation_level", "unit": "fraction", "window": "EMA-32", "notes": "eta_occ = LTMM_usage / C_max" },
			{ "name": "lawful_compression_ratio", "unit": "fraction", "window": "EMA-32", "notes": "Pre-prune snapshot only" },
			{ "name": "equivalence_efficiency", "unit": "fraction", "window": "EMA-16", "notes": "Duplicates mapped to canonical representatives" },
			{ "name": "ethical_ttl_floor", "unit": "ticks", "window": "EMA-64", "notes": "max(tau_decay, 10ยทdelta_t_tick)" },
			{ "name": "ttl_max_effective", "unit": "ticks", "window": "EMA-32", "notes": "Monotone non-increasing in storage_pressure โ [0,1]" },
			{ "name": "damping_effective", "unit": "dimensionless", "window": "EMA-32", "notes": "gamma_co derived from occupancy/replay/conflict" },
			{ "name": "prune_gate_margin", "unit": "fraction", "window": "EMA-16", "notes": "max(0, eta_occ_post - theta_prune)" }
		  ],
		  "pseudocode": [
			{
			  "title": "Capacity Evaluator (Observer)",
			  "anchors": ["capacity_evaluator"],
			  "rfc_anchors": ["RFC-0006 ยง3โยง4", "RFC-0009 ยง6"],
			  "code": [
				"def capacity_evaluator(LTMM_usage, C_max, theta_sat):",
				"    eta_occ = LTMM_usage / C_max",
				"    if eta_occ < theta_sat:",
				"        return { 'status': 'ok', 'action': 'none', 'eta_occ': eta_occ }",
				"    else:",
				"        return { 'status': 'pressure', 'action': 'request_compress', 'eta_occ': eta_occ }"
			  ]
			},
			{
			  "title": "TTL Bounds & Damping Update (Observer)",
			  "anchors": ["compute_ttl_bounds", "update_gamma_co"],
			  "rfc_anchors": ["RFC-0005 ยง4", "RFC-0009 ยง5โยง7"],
			  "code": [
				"def compute_ttl_bounds(tau_decay, delta_t_tick, storage_pressure, ttl_policy):",
				"    if not (0.0 <= storage_pressure <= 1.0):",
				"        raise ValueError('storage_pressure_out_of_domain')",
				"    TTL_floor = max(tau_decay, 10 * delta_t_tick)",
				"    TTL_max_effective = ttl_policy.max_for(storage_pressure)  # MUST be monotone non-increasing",
				"    return { 'TTL_floor': TTL_floor, 'TTL_max_effective': TTL_max_effective }",
				"",
				"def update_gamma_co(eta_occ, replay_rate, conflict_rate, gamma_0, a1, a2, a3):",
				"    # Non-decreasing in each pressure term:",
				"    gamma_co = max(0.0, gamma_0 + a1*eta_occ + a2*replay_rate + a3*conflict_rate)",
				"    return gamma_co"
			  ]
			}
		  ],
		  "examples": [
			{
			  "title": "Compression before prune",
			  "input": { "LTMM_usage": 0.86, "C_max": 1.0, "theta_sat": 0.75, "theta_prune": 0.85 },
			  "output": { "capacity_status": { "status": "pressure", "action": "request_compress", "eta_occ": 0.86 }, "prune_recommendation": { "decision": "hold" } },
			  "notes": "Prune may only be recommended after a compression snapshot shows eta_occ_post >= theta_prune."
			},
			{
			  "title": "TTL bounds under pressure",
			  "input": { "tau_decay": 30, "delta_t_tick": 2, "storage_pressure": 0.7, "ttl_policy": "monotone_map_v1" },
			  "output": { "ttl_bounds": { "TTL_floor": 30, "TTL_max_effective": 18 } },
			  "notes": "Floor respects RFC-0005; ceiling reduced by storage pressure per RFC-0009."
			}
		  ]
		},
		{
		  "id": "2.2",
		  "title": "STMM/LTMM Update Laws",
		  "description": "Defines adaptive update laws for Short-Term Motif Memory (STMM) and Long-Term Motif Memory (LTMM) under an observer-only posture at Layer_1: promotion back-pressure, equivalence-first compression before any prune, staleness-dependent damping, and glider-aware idempotence. All actions are measurements and recommendations; enforcement lives in Layer_2.",
		  "rfc_anchors": [
			"PDP-0001 ยง3โยง4",
			"RFC-0005 ยง3โยง4",
			"RFC-0006 ยง3โยง4",
			"RFC-0008 ยง2",
			"RFC-0009 ยง5โยง7"
		  ],
		  "interfaces": {
			"inputs": [
			  { "name": "C_ema64", "type": "number", "constraints": "0 <= C_ema64 <= 1; finite", "notes": "Smoothed coherence for content gate" },
			  { "name": "delta_closure", "type": "number", "constraints": "delta_closure >= 0; finite", "notes": "Triadic closure residual" },
			  { "name": "rho_res", "type": "number", "constraints": "0 <= rho_res <= 1", "notes": "Resonance band indicator" },
			  { "name": "LTMM_usage", "type": "number", "constraints": "0 <= LTMM_usage <= C_max", "notes": "Occupied capacity" },
			  { "name": "C_max", "type": "number", "constraints": "C_max > 0", "notes": "Capacity for occupancy normalization" },
			  { "name": "lawful_compression_ratio", "type": "number", "constraints": "0 <= value <= 1", "notes": "Post-equivalence/pre-prune size divided by pre-equivalence size" },
			  { "name": "replay_rate", "type": "number", "constraints": "replay_rate >= 0", "notes": "Observed replay pressure" },
			  { "name": "conflict_rate", "type": "number", "constraints": "conflict_rate >= 0", "notes": "Observed conflict/contradiction rate" },
			  { "name": "last_access_intervals", "type": "array<number>", "constraints": "each > 0", "notes": "For staleness EMA" },
			  { "name": "is_glider", "type": "boolean", "constraints": "", "notes": "Glider detection flag (structure-only at L1)" },
			  { "name": "canonical_present", "type": "boolean", "constraints": "", "notes": "Whether canonical representative already exists" },
			  { "name": "lambda_thresh_seed", "type": "number", "constraints": "0.1 <= lambda_thresh_seed <= 0.3; default 0.18", "notes": "Base content threshold seed for promotion; bounded to prevent runaway pressure" },
			  { "name": "theta_promote_cap", "type": "number", "constraints": "0 < theta_promote_cap < 1", "notes": "Occupancy cap for promotion gate" },
			  { "name": "theta_lcr", "type": "number", "constraints": "0 < theta_lcr <= 1", "notes": "Maximum lawful_compression_ratio allowed for promotion" },
			  { "name": "rho_thresh_seed", "type": "number", "constraints": "0 < rho_thresh_seed < 1", "notes": "Seed for occupancy threshold used by capacity actions" }
			],
			"outputs": [
			  { "name": "promotion_decision", "type": "object", "constraints": "ASCII keys", "notes": "{promote: true|false, backpressure: [0,1], reasons: []}" },
			  { "name": "capacity_action", "type": "object", "constraints": "ASCII keys", "notes": "{action: none|compress|prune, plan: {representatives: n}, snapshot: {lawful_compression_ratio, equivalence_efficiency, eta_occ_pre, eta_occ_post}}" },
			  { "name": "staleness_update", "type": "object", "constraints": "ASCII keys", "notes": "{gamma_stale_hint, gamma_total_hint}" }
			],
			"side_effects": ["observer-only"]
		  },
		  "state_lifecycle": {
			"states": ["observing", "promotion_gated", "capacity_pressure", "post_compress_evaluation", "error"],
			"transitions": [
			  { "from": "observing", "to": "promotion_gated", "on": "content_and_capacity_checks_evaluated", "guard": "inputs finite", "notes": "Decide promote boolean and back-pressure" },
			  { "from": "observing", "to": "capacity_pressure", "on": "eta_occ > rho_thresh(t)", "guard": "", "notes": "Begin equivalence-first capacity actions" },
			  { "from": "capacity_pressure", "to": "post_compress_evaluation", "on": "compression_snapshot_ready", "guard": "KPIs computed", "notes": "Consider prune only after compression KPIs" },
			  { "from": "any", "to": "error", "on": "non_finite_input OR observer_violation OR out_of_range_seed", "guard": "", "notes": "Hold state; emit error" }
			]
		  },
		  "requirements": [
			{ "level": "MUST", "text": "Apply equivalence compression before any prune recommendation when occupancy exceeds threshold.", "anchor": "RFC-0006 ยง4.4; RFC-0009 ยง6โยง7" },
			{ "level": "MUST", "text": "Promotion STMM->LTMM requires both content gates (C_ema64, delta_closure, resonance band) and capacity gates (eta_occ below cap and lawful_compression_ratio at or below threshold).", "anchor": "RFC-0006 ยง3โยง4; RFC-0009 ยง7.1" },
			{ "level": "MUST", "text": "Emit lawful_compression_ratio and equivalence_efficiency KPIs with every compression snapshot prior to any prune recommendation.", "anchor": "RFC-0006 ยง4.4; RFC-0009 ยง6" },
			{ "level": "MUST", "text": "Increase effective damping monotonically with staleness (EMA of inter-access intervals) in addition to occupancy, replay_rate, and conflict_rate.", "anchor": "RFC-0005 ยง4.2; RFC-0009 ยง5โยง7" },
			{ "level": "MUST", "text": "Glider promotions are idempotent: at most one canonical representative per equivalence class.", "anchor": "RFC-0006 ยง3โยง4" },
			{ "level": "MUST", "text": "Maintain observer-only posture: provide measurements, KPIs, and recommendations without control writes to ฮ.", "anchor": "PDP-0001 ยง3โยง4; RFC-0008 ยง2" },
			{ "level": "MUST", "text": "Bound lambda_thresh_seed to [0.1, 0.3] and compute lambda_thresh = lambda_thresh_seed * (1 + EMA-32(eta_occ)).", "anchor": "RFC-0006 ยง4.4; RFC-0009 ยง7.2" },
			{ "level": "SHOULD", "text": "Project update trends along the coherence time vector to maintain geometric consistency.", "anchor": "RFC-0006 ยง1โยง2" }
		  ],
		  "error_model": [
			{ "code": "E.MMM.301", "when": "Prune recommendation emitted without prior equivalence compression snapshot", "message": "prune_without_compression", "remedy": "Block; run compression; compute KPIs; re-evaluate" },
			{ "code": "E.MMM.302", "when": "Non-finite or out-of-range inputs encountered (NaN/Inf/invalid bounds)", "message": "non_finite_input", "remedy": "Discard sample; mark window degraded; request normalization" },
			{ "code": "E.MMM.303", "when": "Glider promotion requested but canonical_present = true", "message": "glider_idempotence_violation", "remedy": "Deny promotion; reference existing canonical" },
			{ "code": "E.MMM.304", "when": "Compression KPIs missing on prune evaluation", "message": "missing_compression_kpis", "remedy": "Recompute snapshot; emit lawful_compression_ratio and equivalence_efficiency" },
			{ "code": "E.MMM.305", "when": "Attempted control write at Layer_1", "message": "observer_violation", "remedy": "Block; emit audit; delegate to Layer_2 app-spec" },
			{ "code": "E.MMM.306", "when": "lambda_thresh_seed outside [0.1, 0.3]", "message": "seed_out_of_range", "remedy": "Clamp to nearest bound; log policy_warning; continue in observer mode" }
		  ],
		  "metrics": [
			{ "name": "promotion_rate", "unit": "events/tick", "window": "EMA-32", "notes": "Recommended STMM->LTMM promotions per tick" },
			{ "name": "promotion_backpressure", "unit": "dimensionless", "window": "EMA-32", "notes": "Rises with occupancy; eases with effective compression" },
			{ "name": "eta_occ", "unit": "fraction", "window": "EMA-32", "notes": "LTMM occupancy fraction" },
			{ "name": "promotion_threshold", "unit": "dimensionless", "window": "EMA-32", "notes": "lambda_thresh = lambda_thresh_seed * (1 + EMA-32(eta_occ))" },
			{ "name": "lawful_compression_ratio", "unit": "dimensionless", "window": "EMA-32", "notes": "Post-equivalence/pre-prune size divided by pre-equivalence size" },
			{ "name": "equivalence_efficiency", "unit": "fraction", "window": "EMA-32", "notes": "Capacity relief achieved by equivalence compression" },
			{ "name": "prune_events", "unit": "events/tick", "window": "EMA-16", "notes": "Prunes recommended only after compression insufficient" },
			{ "name": "staleness_index", "unit": "fraction", "window": "EMA-32", "notes": "Normalized EMA of inter-access intervals" }
		  ],
		  "pseudocode": [
			{
			  "title": "Promotion Decision with Back-Pressure (Observer)",
			  "anchors": ["promotion_decision_with_backpressure"],
			  "rfc_anchors": ["RFC-0006 ยง3โยง4", "RFC-0009 ยง7.2"],
			  "code": [
				"def promotion_decision_with_backpressure(C_ema64, delta_closure, rho_res, LTMM_usage, C_max, lawful_compression_ratio,",
				"                                         lambda_thresh_seed, theta_promote_cap, theta_lcr, epsilon_triad):",
				"    eta_occ = LTMM_usage / C_max",
				"    seed = min(0.3, max(0.1, float(lambda_thresh_seed)))",
				"    lambda_thresh = seed * (1 + ema32(eta_occ))  # bounded seed; EMA-32 window",
				"    cond_content = (C_ema64 >= lambda_thresh) and (delta_closure < epsilon_triad) and (0.3 <= rho_res <= 0.7)",
				"    cond_capacity = (eta_occ < theta_promote_cap) and (lawful_compression_ratio <= theta_lcr)",
				"    promote = bool(cond_content and cond_capacity)",
				"    backpressure = 1.0 - min(1.0, max(0.0, (theta_promote_cap - eta_occ) / theta_promote_cap))",
				"    return { 'promote': promote, 'backpressure': backpressure, 'reasons': explain(cond_content, cond_capacity) }"
			  ]
			},
			{
			  "title": "Equivalence-First Capacity Management (Observer)",
			  "anchors": ["equivalence_first_capacity_management"],
			  "rfc_anchors": ["RFC-0006 ยง4.4", "RFC-0009 ยง6โยง7"],
			  "code": [
				"def equivalence_first_capacity_management(LTMM_index_view, rho_thresh_seed, compression_target, prune_floor):",
				"    eta_occ = occupancy(LTMM_index_view)  # read-only view",
				"    rho_thresh = rho_thresh_seed * (1 - ema32(1 - eta_occ))",
				"    if eta_occ <= rho_thresh:",
				"        return { 'action': 'none', 'plan': None, 'snapshot': { 'eta_occ_pre': eta_occ } }",
				"    S = find_equivalence_classes(LTMM_index_view, mode='closure_shift')",
				"    pre = size(LTMM_index_view); post = size(representatives(S))",
				"    lcr = post / max(1, pre); eff = (pre - post) / max(1, pre)",
				"    plan = { 'representatives': count(representatives(S)), 'target': compression_target }  # recommendation only",
				"    eta_post = projected_occupancy(eta_occ, lcr)  # estimate; no writes at Layer_1",
				"    action = 'prune' if eta_post > rho_thresh else 'compress'",
				"    return { 'action': action, 'plan': plan, 'snapshot': { 'lawful_compression_ratio': lcr, 'equivalence_efficiency': eff, 'eta_occ_pre': eta_occ, 'eta_occ_post': eta_post } }"
			  ]
			}
		  ],
		  "examples": [
			{
			  "title": "Promotion denied due to capacity gate",
			  "input": {
				"C_ema64": 0.88,
				"delta_closure": 0.01,
				"rho_res": 0.55,
				"LTMM_usage": 0.83,
				"C_max": 1.0,
				"lawful_compression_ratio": 0.62,
				"lambda_thresh_seed": 0.18,
				"theta_promote_cap": 0.80,
				"theta_lcr": 0.60,
				"epsilon_triad": 0.02
			  },
			  "output": { "promotion_decision": { "promote": false, "backpressure": 0.96, "reasons": ["capacity_gate_failed","lcr_above_threshold"] } },
			  "notes": "Content gates pass; capacity gate fails due to occupancy and LCR; seed bounded within [0.1, 0.3]."
			},
			{
			  "title": "Compression before prune under saturation",
			  "input": {
				"LTMM_index_size": 1000,
				"rho_thresh_seed": 0.70,
				"compression_target": 0.75,
				"prune_floor": 0.20,
				"eta_occ_initial": 0.92
			  },
			  "output": {
				"capacity_action": {
				  "action": "prune",
				  "plan": { "representatives": 740, "target": 0.75 },
				  "snapshot": { "lawful_compression_ratio": 0.82, "equivalence_efficiency": 0.18, "eta_occ_pre": 0.92, "eta_occ_post": 0.88 }
				}
			  },
			  "notes": "Compression is recommended first; still saturated, so prune recommendation becomes admissible."
			}
		  ]
		},
		{
		  "id": "2.3",
		  "title": "Reanchor and Recovery Escalation Logic",
		  "description": "Define an observer-only, bounded recovery procedure that (a) detects violation conditions, (b) attempts reanchor within a capped budget derived from conflict-rate EMA, (c) escalates to quarantine on overlap or exhaustion, and (d) guarantees finite outcomes {reanchored, quarantined, abandoned} with full auditability.",
		  "rfc_anchors": [
			"PDP-0001 ยง3โยง4",
			"RFC-0005 ยง4.2",
			"RFC-0006 ยง3โยง4",
			"RFC-0007 ยง2",
			"RFC-0008 ยง2โยง3",
			"RFC-0009 ยง5โยง7"
		  ],
		  "interfaces": {
			"inputs": [
			  { "name": "snapshot_history", "type": "list<observer_snapshot>", "constraints": "ordered by time, includes closure/resonance measures", "notes": "read-only provenance; no Layer_2 keying" },
			  { "name": "tau_recovery", "type": "duration", "constraints": "tau_recovery > 0", "notes": "window to search for last lawful state" },
			  { "name": "conflict_rate_ema32", "type": "float", "constraints": "0 <= value", "notes": "smoothed incident rate driving attempt budget" },
			  { "name": "k", "type": "float", "constraints": "k >= 0", "notes": "scales attempt budget" },
			  { "name": "epsilon_triad", "type": "float", "constraints": "epsilon_triad > 0", "notes": "closure gap tolerance" }
			],
			"outputs": [
			  { "name": "status", "type": "enum", "constraints": "{no_action|reanchored|quarantined|abandoned|rejected|staged}", "notes": "finite terminal or staging status" },
			  { "name": "recovery_token", "type": "string", "constraints": "monotonic, unique per incident", "notes": "used for idempotence and audit trace" }
			],
			"side_effects": [
			  "observer-only: emit events/metrics",
			  "observer-only: mark quarantine set (read-only isolation)",
			  "observer-only: stage bundles after validation (no control writes to Xi)"
			]
		  },
		  "state_lifecycle": {
			"states": [
			  "idle",
			  "detecting_violation",
			  "reanchoring",
			  "quarantined",
			  "reanchored",
			  "abandoned"
			],
			"transitions": [
			  { "from": "idle", "to": "detecting_violation", "on": "violation_detected", "guard": "resonance out of band OR closure_gap > epsilon_triad", "notes": "RFC-0006 bands; RFC-0009 closure integrity" },
			  { "from": "detecting_violation", "to": "reanchoring", "on": "attempt_budget_allocated", "guard": "N_max = ceil(k * conflict_rate_ema32) >= 1", "notes": "bounded attempts (RFC-0009 ยง5.2)" },
			  { "from": "reanchoring", "to": "reanchored", "on": "lawful_state_found", "guard": "closure_gap == 0 AND resonance in band", "notes": "RFC-0006 lawful test" },
			  { "from": "reanchoring", "to": "quarantined", "on": "overlap_or_exhaustion", "guard": "overlapping windows OR attempts exhausted", "notes": "escalation to quarantine" },
			  { "from": "quarantined", "to": "reanchored", "on": "diagnostics_pass", "guard": "bounded Jacobian AND improving closure", "notes": "observer diagnostics only (RFC-0009 ยง7)" },
			  { "from": "quarantined", "to": "abandoned", "on": "ttl_or_policy_stop", "guard": "quarantine TTL elapsed without pass", "notes": "finite termination" }
			]
		  },
		  "requirements": [
			{ "level": "MUST", "text": "Operate as observer-only: no control writes to Xi during detection, reanchor, quarantine, or diagnostics.", "anchor": "PDP-0001 ยง3โยง4" },
			{ "level": "MUST", "text": "Bound reanchor attempts by N_max = ceil(k * conflict_rate_ema32) with per-attempt window tau_recovery.", "anchor": "RFC-0009 ยง5.2" },
			{ "level": "MUST", "text": "Escalate to quarantine if recovery windows overlap or attempts are exhausted.", "anchor": "RFC-0009 ยง5.2; RFC-0005 ยง4.2" },
			{ "level": "MUST", "text": "Ensure finite outcomes in {reanchored, quarantined, abandoned} and record an audit trace keyed by recovery_token.", "anchor": "RFC-0009 ยง5.2" },
			{ "level": "MUST", "text": "Test lawfulness using closure == 0 and resonance within the RFC-0006 in-band interval.", "anchor": "RFC-0006 ยง3โยง4" },
			{ "level": "SHOULD", "text": "Reject import bundles lacking valid DAG, envelope, or lineage before staging.", "anchor": "RFC-0007 ยง2; RFC-0008 ยง2โยง3" },
			{ "level": "MAY", "text": "Adapt k via policy tied to capacity/homeostasis KPIs.", "anchor": "RFC-0009 ยง5โยง7" }
		  ],
		  "error_model": [
			{ "code": "E.MMM.230", "when": "overlapping recovery windows detected", "message": "Recovery windows overlap; escalation required.", "remedy": "Escalate to quarantine; preserve read-only observability." },
			{ "code": "E.MMM.231", "when": "no lawful prior snapshot in tau_recovery", "message": "No lawful state found in window.", "remedy": "Emit reanchor_fail; escalate to quarantine." },
			{ "code": "E.MMM.232", "when": "idempotent re-entry with identical recovery_token", "message": "Duplicate recovery cycle suppressed.", "remedy": "Emit idempotent_drop; return abandoned." },
			{ "code": "E.MMM.233", "when": "quarantine diagnostics exceed TTL without pass", "message": "Diagnostics timed out.", "remedy": "Hold or abandon per policy; do not export/promote." },
			{ "code": "E.MMM.234", "when": "import validation fails (DAG/envelope/lineage)", "message": "Bundle rejected by guard.", "remedy": "Emit near_miss and return rejected; staging is not performed." }
		  ],
		  "metrics": [
			{ "name": "reanchor_attempt", "unit": "count/tick", "window": "EMA-32", "notes": "Increment per attempt (bounded by N_max)." },
			{ "name": "reanchor_fail", "unit": "count/tick", "window": "EMA-16", "notes": "Attempts that did not reach a lawful state." },
			{ "name": "quarantine_entry", "unit": "count/tick", "window": "EMA-32", "notes": "Escalations due to overlap or exhaustion." },
			{ "name": "overlap_detected", "unit": "flag", "window": "EMA-16", "notes": "1 if any overlap occurred in the last tick; else 0." },
			{ "name": "recovery_latency", "unit": "ticks", "window": "EMA-32", "notes": "Ticks from violation to terminal state {reanchored|quarantined}." },
			{ "name": "diagnostic_jacobian_norm", "unit": "unitless", "window": "EMA-16", "notes": "Estimated local Jacobian norm during quarantine diagnostics." },
			{ "name": "quarantine_pass_share", "unit": "fraction", "window": "EMA-32", "notes": "Share of quarantined items that passed the last diagnostic step." }
		  ],
		  "pseudocode": [
			{
			  "title": "Reanchor Protocol (Observer)",
			  "anchors": ["reanchor_protocol"],
			  "rfc_anchors": ["RFC-0006 ยง3โยง4", "RFC-0009 ยง5.2"],
			  "code": [
				"def reanchor_protocol(hist, tau_recovery, conflict_rate_ema32, k, epsilon_triad):",
				"    if not violation_detected(epsilon_triad):",
				"        return {'status': 'no_action', 'recovery_token': None}",
				"    token = monotonic_token()",
				"    if seen(token):",
				"        emit('idempotent_drop'); return {'status': 'abandoned', 'recovery_token': token}",
				"    N_max = max(1, ceil(k * conflict_rate_ema32))",
				"    for _ in range(N_max):",
				"        cand = last_lawful(hist, tau_recovery)",
				"        if cand is None: emit('reanchor_fail'); break",
				"        stage_observer_state(cand)  # observer-only",
				"        if is_lawful(): emit('reanchor_success'); return {'status': 'reanchored', 'recovery_token': token}",
				"        emit('reanchor_attempt')",
				"    if windows_overlap(tau_recovery): emit('overlap_detected')",
				"    return quarantine_escalation(token)"
			  ]
			},
			{
			  "title": "Quarantine Escalation (Observer)",
			  "anchors": ["quarantine_escalation"],
			  "rfc_anchors": ["RFC-0009 ยง7", "PDP-0001 ยง3โยง4"],
			  "code": [
				"def quarantine_escalation(token):",
				"    isolate_readonly_set(token)          # suppress export/promotion at Layer_1",
				"    emit('quarantine_entry', {'token': token})",
				"    start_quarantine_timer()",
				"    return {'status': 'quarantined', 'recovery_token': token}"
			  ]
			}
		  ],
		  "examples": [
			{
			  "title": "Reanchored after one attempt",
			  "input": {
				"snapshot_history": ["s0_lawful", "s1_violation"],
				"tau_recovery": "5s",
				"conflict_rate_ema32": 0.2,
				"k": 3.0,
				"epsilon_triad": 0.001
			  },
			  "output": { "status": "reanchored", "recovery_token": "tok_12345" },
			  "notes": "N_max = ceil(3.0 * 0.2) = 1; last lawful found within tau_recovery."
			},
			{
			  "title": "Escalation to quarantine on overlap",
			  "input": {
				"snapshot_history": ["s0_violation", "s1_violation"],
				"tau_recovery": "10s",
				"conflict_rate_ema32": 0.9,
				"k": 2.0,
				"epsilon_triad": 0.001
			  },
			  "output": { "status": "quarantined", "recovery_token": "tok_67890" },
			  "notes": "Attempts exhausted and recovery windows overlap; quarantine_entry emitted."
			}
		  ]
		}	
    },

    "3": {
      "id": "3",
	  "title": "Memory Structures and Data Formats",
		{
		  "id": "3.1",
		  "title": "Motif Ontology Bundles",
		  "description": "Define the observer-only contracts for Motif Ontology Bundles (MOBs) used in cross-agent exchange: minimal on-wire schema, provenance and lineage fields (structural only), validation gates (RFC-0007 DAG/version, trusted origin), deterministic merge/fork classification, replay/phase checks under feature flags, and quarantine routing on failure. Layer_1 remains neutral and non-cryptographic; all control writes and cryptographic semantics are deferred to Layer_2.",
		  "rfc_anchors": [
			"PDP-0001 ยง3โยง4",
			"PDP-0001 ยง5.1",
			"RFC-0005 ยง4.2",
			"RFC-0006 ยง3โยง4",
			"RFC-0007 ยง2โยง4, ยง8",
			"RFC-0008 ยง2โยง3, ยง5",
			"RFC-0009 ยง6โยง7"
		  ],
		  "interfaces": {
			"inputs": [
			  { "name": "bundle", "type": "object<MOB>", "constraints": "contains {header, ontology, lineage, provenance}", "notes": "values may include Unicode (e.g., motif ids); keys are ASCII" },
			  { "name": "trusted_roots", "type": "set<origin>", "constraints": "non-empty for production use", "notes": "Layer_1 structural registry; no keys/PKI here" },
			  { "name": "feature_flags", "type": "object", "constraints": "booleans: {enable_exchange_envelope, enable_integrity_checks, enable_provenance_on_export}", "notes": "gates Sigma_phase/Delta_hash/provenance-on-export" }
			],
			"outputs": [
			  { "name": "status", "type": "enum", "constraints": "{valid|staged|merged|forked|unrelated|rejected|quarantined}", "notes": "finite outcome for import/reconcile/export" },
			  { "name": "result", "type": "object|null", "constraints": "merged bundle or fork pair metadata; null otherwise", "notes": "observer-constructed summary only" }
			],
			"side_effects": [
			  "observer-only: emit telemetry/events",
			  "observer-only: stage bundle for read-only use",
			  "observer-only: route failed validations to quarantine classification (no deletion/prune at L1)"
			]
		  },
		  "state_lifecycle": {
			"states": [
			  "idle",
			  "validating",
			  "staged",
			  "reconciled_merged",
			  "reconciled_forked",
			  "reconciled_unrelated",
			  "quarantined",
			  "rejected"
			],
			"transitions": [
			  { "from": "idle", "to": "validating", "on": "bundle_received", "guard": "", "notes": "begin RFC-0007/0008/0009 structural checks" },
			  { "from": "validating", "to": "rejected", "on": "ontology_or_origin_invalid", "guard": "DAG fail OR version fail OR unknown origin", "notes": "emit dag_invalid/version_invalid/unknown_origin" },
			  { "from": "validating", "to": "rejected", "on": "lineage_or_phase_invalid", "guard": "flagged checks fail", "notes": "Delta_hash or Sigma_phase gates" },
			  { "from": "validating", "to": "staged", "on": "all_checks_pass", "guard": "", "notes": "observer staging only" },
			  { "from": "staged", "to": "reconciled_merged", "on": "reconcile", "guard": "parent_hash=A=B AND integrity_hash=A=B (if enabled)", "notes": "deterministic merge" },
			  { "from": "staged", "to": "reconciled_forked", "on": "reconcile", "guard": "parent_hash=A=B AND integrity_hash differ", "notes": "deterministic fork" },
			  { "from": "staged", "to": "reconciled_unrelated", "on": "reconcile", "guard": "parent_hash differ", "notes": "no merge" },
			  { "from": "validating", "to": "quarantined", "on": "suspicious_but_structural", "guard": "passes DAG/version/origin but other structural anomaly", "notes": "hold for observer diagnostics; no exports" }
			]
		  },
		  "requirements": [
			{ "level": "MUST", "text": "Validate ontology structure before any staging: acyclic DAG, all motif references resolvable, and version formatted as /^\\d{4}-Q[1-4]$/.", "anchor": "RFC-0007 ยง2โยง4, ยง8" },
			{ "level": "MUST", "text": "Remain algorithmically neutral at Layer_1 for DAG checks: require only acyclicity and resolvable references; do not prescribe validation algorithms. (Layer_2 MAY use Tarjan, Kahn, or DFS.)", "anchor": "RFC-0007 ยง3.2; PDP-0001 ยง5.1" },
			{ "level": "MUST", "text": "Enforce trusted-origin check: bundle.provenance.origin โ trusted_roots and provenance.origin_hash equals the structural seed function defined for Layer_1.", "anchor": "PDP-0001 ยง3โยง4" },
			{ "level": "MUST", "text": "Classify reconciliation deterministically: merged iff {parent_hash, integrity_hash} match (when integrity checks are enabled); forked iff parent_hash matches and integrity_hash differs; unrelated otherwise.", "anchor": "RFC-0009 ยง6โยง7; RFC-0007 ยง2" },
			{ "level": "MUST", "text": "Apply feature-flag gating: emit Sigma_phase only if enable_exchange_envelope=true; emit Delta_hash and verify integrity_hash only if enable_integrity_checks=true; attach provenance on export only if enable_provenance_on_export=true.", "anchor": "RFC-0008 ยง2โยง3, ยง5; RFC-0009 ยง6" },
			{ "level": "MUST", "text": "Operate as observer-only at Layer_1: importing, staging, reconciling, and exporting MUST NOT mutate motif content nor perform control writes to ฮ.", "anchor": "PDP-0001 ยง3โยง4" },
			{ "level": "SHOULD", "text": "On validation failure after DAG/version/origin pass but with other anomalies, route the bundle to quarantine with full observability and suppressed export.", "anchor": "RFC-0009 ยง7; RFC-0005 ยง4.2" },
			{ "level": "MAY", "text": "Record read-only provenance events for merge/fork outcomes to support later audit without altering bundle contents.", "anchor": "PDP-0001 ยง4" }
		  ],
		  "error_model": [
			{ "code": "E.MMM.310", "when": "ontology DAG invalid or references unresolved", "message": "ontology_validation_failed", "remedy": "Reject bundle; emit dag_invalid_count and near_miss event" },
			{ "code": "E.MMM.311", "when": "version field missing or not /^\\d{4}-Q[1-4]$/", "message": "invalid_ontology_version", "remedy": "Reject bundle; request version normalization" },
			{ "code": "E.MMM.312", "when": "provenance.origin not in trusted_roots or origin_hash mismatch", "message": "unknown_or_untrusted_origin", "remedy": "Reject bundle; emit unknown_origin_rate increment" },
			{ "code": "E.MMM.313", "when": "integrity checks enabled and integrity_hash mismatch with payload", "message": "integrity_lineage_mismatch", "remedy": "Reject bundle; emit lineage_rejects; quarantine if policy requires" },
			{ "code": "E.MMM.314", "when": "exchange envelope enabled and Sigma_phase outside accept window", "message": "phase_replay_window_violation", "remedy": "Reject bundle; emit envelope_replay_flags; advise resend within window" }
		  ],
		  "metrics": [
			{ "name": "merge_rate", "unit": "events/tick", "window": "EMA-32", "notes": "Share of reconciliations that produced merged outcome" },
			{ "name": "fork_rate", "unit": "events/tick", "window": "EMA-32", "notes": "Share of reconciliations that produced forked outcome" },
			{ "name": "dag_invalid_count", "unit": "events/tick", "window": "EMA-16", "notes": "Count of ontology DAG validation failures" },
			{ "name": "lineage_rejects", "unit": "events/tick", "window": "EMA-16", "notes": "Rejects due to integrity_hash mismatch when enabled" },
			{ "name": "unknown_origin_rate", "unit": "fraction", "window": "EMA-32", "notes": "Fraction of bundles failing trusted origin checks" },
			{ "name": "bundle_staged_count", "unit": "events/tick", "window": "EMA-32", "notes": "Bundles that passed validation and were staged (observer-only)" },
			{ "name": "envelope_replay_flags", "unit": "events/tick", "window": "EMA-16", "notes": "Sigma_phase window violations when envelope flag is enabled" }
		  ],
		  "pseudocode": [
			{
			  "title": "validate_bundle (Observer)",
			  "anchors": ["validate_bundle"],
			  "rfc_anchors": ["RFC-0007 ยง2โยง4, ยง8", "PDP-0001 ยง3โยง4", "RFC-0008 ยง2โยง3", "RFC-0009 ยง6"],
			  "code": [
				"def validate_bundle(bundle, trusted_roots, flags):",
				"    if not dag_valid(bundle.ontology): emit('dag_invalid_count'); return {'status': 'rejected'}",
				"    if not regex('^\\\\d{4}-Q[1-4]$', bundle.header.version): emit('version_invalid'); return {'status': 'rejected'}",
				"    if bundle.provenance.origin not in trusted_roots: emit('unknown_origin_rate'); return {'status': 'rejected'}",
				"    if flags.enable_integrity_checks and not delta_hash_consistent(bundle.lineage, bundle):",
				"        emit('lineage_rejects'); return {'status': 'rejected'}",
				"    if flags.enable_exchange_envelope and not phase_window_accept(bundle.header.Sigma_phase):",
				"        emit('envelope_replay_flags'); return {'status': 'rejected'}",
				"    emit('bundle_staged_count'); return {'status': 'staged'}"
			  ]
			},
			{
			  "title": "merge_or_fork (Observer)",
			  "anchors": ["merge_or_fork"],
			  "rfc_anchors": ["RFC-0009 ยง6โยง7", "RFC-0007 ยง2"],
			  "code": [
				"def merge_or_fork(A, B, flags):",
				"    if A.lineage.parent_hash != B.lineage.parent_hash:",
				"        return {'status': 'unrelated', 'result': None}",
				"    if flags.enable_integrity_checks and A.lineage.integrity_hash == B.lineage.integrity_hash:",
				"        merged = unify_fields(A, B, strategy='latest_timestamp')  # observer summary",
				"        emit('merge_rate'); return {'status': 'merged', 'result': merged}",
				"    else:",
				"        forks = {'A': A.header.id, 'B': B.header.id}",
				"        emit('fork_rate'); return {'status': 'forked', 'result': forks}"
			  ]
			},
			{
			  "title": "export_bundle (Observer, Flag-Gated)",
			  "anchors": ["export_bundle"],
			  "rfc_anchors": ["RFC-0008 ยง2โยง3", "RFC-0009 ยง6", "PDP-0001 ยง3โยง4"],
			  "code": [
				"def export_bundle(bundle, flags):",
				"    pkt = {'payload': bundle}",
				"    if flags.enable_provenance_on_export:",
				"        pkt['provenance'] = { 'origin': bundle.provenance.origin, 'origin_hash': bundle.provenance.origin_hash, 'created_at': bundle.provenance.created_at }",
				"    if flags.enable_exchange_envelope:",
				"        pkt['Sigma_phase'] = compute_phase(bundle)        # structural",
				"    if flags.enable_integrity_checks:",
				"        pkt['Delta_hash'] = compute_delta_hash(bundle)    # structural",
				"    return {'status': 'valid', 'result': pkt}"
			  ]
			}
		  ],
		  "examples": [
			{
			  "title": "Valid bundle staged (observer-only)",
			  "input": {
				"bundle": {
				  "header": { "id": "mob_001", "version": "2025-Q4" },
				  "ontology": { "motifs": ["ฯ-core@ฮ"], "edges": [] },
				  "lineage": { "parent_hash": "h0", "integrity_hash": "h1" },
				  "provenance": { "origin": "agent.alpha", "origin_hash": "s123", "created_at": "2025-10-13T00:00:00Z" }
				},
				"trusted_roots": ["agent.alpha", "agent.beta"],
				"feature_flags": { "enable_exchange_envelope": true, "enable_integrity_checks": true, "enable_provenance_on_export": true }
			  },
			  "output": { "status": "staged", "result": null },
			  "notes": "DAG valid, version matches ^\\d{4}-Q[1-4]$, origin trusted; staged for read-only reconciliation."
			},
			{
			  "title": "Rejected due to DAG cycle",
			  "input": {
				"bundle": {
				  "header": { "id": "mob_bad", "version": "2025-Q4" },
				  "ontology": { "motifs": ["ฯ-a@ฮ","ฯ-b@ฮ"], "edges": [["ฯ-a@ฮ","ฯ-b@ฮ"], ["ฯ-b@ฮ","ฯ-a@ฮ"]] },
				  "lineage": { "parent_hash": "h9", "integrity_hash": "hA" },
				  "provenance": { "origin": "agent.unknown", "origin_hash": "x999", "created_at": "2025-09-01T00:00:00Z" }
				},
				"trusted_roots": ["agent.alpha"],
				"feature_flags": { "enable_exchange_envelope": false, "enable_integrity_checks": false, "enable_provenance_on_export": false }
			  },
			  "output": { "status": "rejected", "result": null },
			  "notes": "Cycle detected and unknown origin; fails RFC-0007 DAG and trusted-origin checks."
			}
		  ]
		},
		{
		  "id": "3.2",
		  "title": "Memory Trace and Logging",
		  "description": "Define Layer_1, observer-only trace-buffer semantics for motif access/recall, promotion/demotion, recovery, capacity, and exchange events. Tracing measures, seals, and routes summaries; it does not perform control writes to Xi. Export of phase/lineage/provenance headers is strictly feature-flagโgated.",
		  "rfc_anchors": [
			"PDP-0001 ยง3โยง4",
			"RFC-0005 ยง4.2",
			"RFC-0006 ยง1โยง3",
			"RFC-0008 ยง5",
			"RFC-0009 ยง7, ยง9"
		  ],
		  "interfaces": {
			"inputs": [
			  { "name": "entry", "type": "object", "constraints": "ASCII keys; required fields per trace_entry_schema", "notes": "values may include Unicode (e.g., motif_id)" },
			  { "name": "now_tick", "type": "integer", "constraints": "now_tick >= 0", "notes": "monotonic tick index" },
			  { "name": "tau_decay", "type": "integer", "constraints": "tau_decay > 0", "notes": "lawful purge horizon (RFC-0005 ยง4.2)" },
			  { "name": "window_size_ticks", "type": "integer", "constraints": "window_size_ticks > 0", "notes": "summary roll-up window" },
			  { "name": "feature_flags", "type": "object<bool>", "constraints": "{enable_exchange_envelope, enable_integrity_checks, enable_provenance_on_export}", "notes": "gates exported headers" }
			],
			"outputs": [
			  { "name": "status", "type": "enum", "constraints": "{ok|staged|exported|purged|rate_limited|rejected}", "notes": "operation result" },
			  { "name": "packet", "type": "object|null", "constraints": "present only for export", "notes": "observer-class summary packet" },
			  { "name": "purged_count", "type": "integer", "constraints": ">= 0", "notes": "number of entries removed by purge_old" },
			  { "name": "summary", "type": "object|null", "constraints": "ASCII keys; KPI fields only", "notes": "roll-up result; no raw payloads" }
			],
			"side_effects": [
			  "observer-only: append to ring buffer",
			  "observer-only: emit telemetry counters and EMAs",
			  "observer-only: rate-limit export attempts"
			]
		  },
		  "state_lifecycle": {
			"states": [
			  "idle",
			  "recording",
			  "rolling_up",
			  "exporting",
			  "purging",
			  "rate_limited"
			],
			"transitions": [
			  { "from": "idle", "to": "recording", "on": "append_trace_entry", "guard": "schema valid", "notes": "validate and record" },
			  { "from": "recording", "to": "purging", "on": "purge_old", "guard": "now_tick - t > tau_decay for some entries", "notes": "lawful forgetting" },
			  { "from": "recording", "to": "rolling_up", "on": "rollup_trace_summary", "guard": "window_size_ticks > 0", "notes": "compute KPIs" },
			  { "from": "rolling_up", "to": "exporting", "on": "export_trace", "guard": "feature flags respected", "notes": "seal summary for SRX" },
			  { "from": "exporting", "to": "rate_limited", "on": "export_qps_exceeded", "guard": "", "notes": "throttle without dropping summary" },
			  { "from": "rate_limited", "to": "idle", "on": "qps_window_reset", "guard": "", "notes": "resume" },
			  { "from": "purging", "to": "idle", "on": "purge_complete", "guard": "", "notes": "return to idle" }
			]
		  },
		  "requirements": [
			{ "level": "MUST", "text": "Operate as observer-only: trace routines SHALL NOT perform control writes to Xi.", "anchor": "PDP-0001 ยง3โยง4" },
			{ "level": "MUST", "text": "Maintain a bounded ring buffer; on overflow, drop the oldest entries first.", "anchor": "RFC-0009 ยง7" },
			{ "level": "MUST", "text": "Purge entries strictly older than tau_decay ticks.", "anchor": "RFC-0005 ยง4.2" },
			{ "level": "MUST", "text": "Export headers obey flag gating: Sigma_phase present iff enable_exchange_envelope=true; Delta_hash present iff enable_integrity_checks=true; provenance attached on export iff enable_provenance_on_export=true.", "anchor": "RFC-0008 ยง5; RFC-0009 ยง7" },
			{ "level": "MUST", "text": "Trace entry schema includes at least: t, motif_id, C, lambda, gamma_co, rho_res, delta_closure, event, notes?. Event enumerates {access, retrieve, promote, demote, near_miss, reanchor_attempt, reanchor_fail, quarantine_entry, saturation_prune}.", "anchor": "RFC-0006 ยง1โยง3; RFC-0009 ยง9" },
			{ "level": "SHOULD", "text": "Roll-up summaries compute EMAs for dC and per-event rates and expose band shares for resonance.", "anchor": "RFC-0006 ยง3; RFC-0009 ยง7" },
			{ "level": "MAY", "text": "Rate-limit export attempts to a configured QPS without dropping already-computed summaries.", "anchor": "RFC-0009 ยง7" }
		  ],
		  "error_model": [
			{ "code": "E.MMM.320", "when": "trace entry fails schema validation", "message": "Invalid trace entry schema.", "remedy": "Reject entry; emit schema_error counter; do not mutate buffer." },
			{ "code": "E.MMM.321", "when": "export attempted while over QPS limit", "message": "Export rate limited.", "remedy": "Return status=rate_limited; retry after window reset." },
			{ "code": "E.MMM.322", "when": "packet includes Sigma_phase or Delta_hash while corresponding flags are false", "message": "Flag-gating violation on exported headers.", "remedy": "Strip gated fields; emit gating_violation; return status=rejected if policy strict." },
			{ "code": "E.MMM.323", "when": "purge invoked with non-positive tau_decay", "message": "Invalid purge horizon.", "remedy": "Refuse purge; require tau_decay > 0." }
		  ],
		  "metrics": [
			{ "name": "memory_trace_dC", "unit": "delta_per_tick", "window": "EMA-32", "notes": "Smoothed ฮC between adjacent ticks in window." },
			{ "name": "reanchor_rate", "unit": "events/tick", "window": "EMA-32", "notes": "EMA of indicator(event=reanchor_attempt)." },
			{ "name": "reanchor_fail_rate", "unit": "events/tick", "window": "EMA-32", "notes": "EMA of indicator(event=reanchor_fail)." },
			{ "name": "quarantine_entry_rate", "unit": "events/tick", "window": "EMA-32", "notes": "EMA of indicator(event=quarantine_entry)." },
			{ "name": "saturation_prune_rate", "unit": "events/tick", "window": "EMA-32", "notes": "EMA of indicator(event=saturation_prune)." },
			{ "name": "rho_res_band_share", "unit": "fraction", "window": "EMA-32", "notes": "Share of entries with 0.3 โค rho_res โค 0.7." },
			{ "name": "avg_replay_window_ticks", "unit": "ticks", "window": "EMA-32", "notes": "Average accepted Sigma_phase replay window, when envelope enabled (ref. ยง4.1 gating)." }
		  ],
		  "pseudocode": [
			{
			  "title": "append_trace_entry (Observer)",
			  "anchors": ["append_trace_entry"],
			  "rfc_anchors": ["RFC-0006 ยง1โยง3", "RFC-0009 ยง7"],
			  "code": [
				"def append_trace_entry(entry):",
				"    # Validate ASCII keys and required fields",
				"    if not schema_valid(entry):",
				"        emit('schema_error'); return {'status': 'rejected'}",
				"    with lock():",
				"        ring.push(entry)",
				"        if ring.len() > TRACE_BUFFER_LEN: ring.drop_oldest()",
				"    return {'status': 'ok'}"
			  ]
			},
			{
			  "title": "export_trace (Flag-Gated)",
			  "anchors": ["export_trace"],
			  "rfc_anchors": ["RFC-0008 ยง5", "RFC-0009 ยง7", "PDP-0001 ยง3โยง4"],
			  "code": [
				"def export_trace(summary, flags):",
				"    pkt = {'kind': 'trace_summary', 'body': summary}",
				"    if flags.enable_provenance_on_export:",
				"        pkt['provenance'] = minimal_provenance(summary)",
				"    if flags.enable_exchange_envelope:",
				"        pkt['Sigma_phase'] = compute_phase_checksum(pkt)",
				"    if flags.enable_integrity_checks:",
				"        pkt['Delta_hash'] = compute_lineage_hash(pkt)",
				"    if qps_exceeded(): return {'status': 'rate_limited', 'packet': None}",
				"    return {'status': 'exported', 'packet': pkt}"
			  ]
			}
		  ],
		  "examples": [
			{
			  "title": "Record recovery attempt and roll up",
			  "input": {
				"entry": { "t": 1201, "motif_id": "ฯ-core@ฮ", "C": 0.62, "lambda": 0.08, "gamma_co": 0.03, "rho_res": 0.55, "delta_closure": 0.0, "event": "reanchor_attempt", "notes": "" },
				"window_size_ticks": 128,
				"feature_flags": { "enable_exchange_envelope": true, "enable_integrity_checks": true, "enable_provenance_on_export": false }
			  },
			  "output": { "status": "exported", "packet": { "kind": "trace_summary" } },
			  "notes": "Entry accepted; roll-up computes memory_trace_dC and event EMAs; export attaches Sigma_phase and Delta_hash (provenance omitted by flag)."
			},
			{
			  "title": "Gating violation on export",
			  "input": {
				"summary": { "memory_trace_dC": 0.0, "reanchor_rate": 0.05 },
				"feature_flags": { "enable_exchange_envelope": false, "enable_integrity_checks": false, "enable_provenance_on_export": true }
			  },
			  "output": { "status": "exported", "packet": { "kind": "trace_summary", "provenance": { } } },
			  "notes": "No Sigma_phase or Delta_hash present because flags are false; provenance attached only."
			}
		  ]
		},
		{
		  "id": "3.3",
		  "title": "Glider Handling and Shift-Equivalence Compression",
		  "description": "Observer-only contracts to (a) detect shift-equivalence classes over RFC-0007โvalidated motifs, (b) deterministically select one canonical representative per class, (c) deny re-promotion of non-canonical members (idempotence), and (d) support recall by mapping a query to its class canonical via an inverse shift. Point-space glider tags are structural only, exported when enable_point_space_gliders=true, and never imply HOW.",
		  "rfc_anchors": [
			"PDP-0001 ยง3โยง4",
			"RFC-0005 ยง3โยง4",
			"RFC-0006 ยง3โยง4",
			"RFC-0007 ยง2โยง4",
			"RFC-0008 ยง4.1",
			"RFC-0009 ยง5โยง7"
		  ],
		  "interfaces": {
			"inputs": [
			  { "name": "validated_items", "type": "list<motif>", "constraints": "MUST pass RFC-0007 DAG/version/provenance checks", "notes": "Observer-only; no control writes" },
			  { "name": "feature_flags", "type": "object<bool>", "constraints": "{enable_point_space_gliders}", "notes": "Gates point-space tag emission" },
			  { "name": "query_item", "type": "motif", "constraints": "Encodable under shift operator S", "notes": "Used for recall mapping (optional)" }
			],
			"outputs": [
			  { "name": "status", "type": "enum", "constraints": "{classified|canonicalized|mapped|rejected}", "notes": "Outcome of the invoked routine" },
			  { "name": "class_index", "type": "map<class_key, list<motif_id>>", "constraints": "ASCII keys", "notes": "Equivalence classes from shift-normal forms" },
			  { "name": "canonical_map", "type": "map<class_key, motif_id>", "constraints": "Exactly one representative per class", "notes": "Deterministic, idempotent" },
			  { "name": "recall_mapping", "type": "object", "constraints": "{rep_id, inverse_shift}", "notes": "Present only when recall succeeds" },
			  {
				"name": "point_space_tags",
				"type": "map<motif_id, object>",
				"constraints": "Emitted only if enable_point_space_gliders=true",
				"notes": "Structural-only; per-motif object schema: {class, v, phi, phi_unit, tau}"
			  }
			],
			"side_effects": [ "observer-only" ]
		  },
		  "state_lifecycle": {
			"states": [ "idle", "classifying", "canonicalizing", "indexed", "mapped", "rejected" ],
			"transitions": [
			  { "from": "idle", "to": "classifying", "on": "detect_shift_equivalence", "guard": "validated_items non-empty", "notes": "Operate only on RFC-0007โvalid items" },
			  { "from": "classifying", "to": "canonicalizing", "on": "classes_built", "guard": "โฅ 1 class", "notes": "Derive class_key via shift-normal form" },
			  { "from": "canonicalizing", "to": "indexed", "on": "canon_selected", "guard": "exactly one representative per class", "notes": "Deterministic tie-break required" },
			  { "from": "indexed", "to": "mapped", "on": "recall_via_inverse_shift", "guard": "query_item encodable", "notes": "Return {rep_id, inverse_shift}" },
			  { "from": "classifying", "to": "rejected", "on": "empty_or_invalid_input", "guard": "", "notes": "Fail fast; require validation first" }
			]
		  },
		  "requirements": [
			{ "level": "MUST", "text": "Operate as observer-only: classification, canonical selection, and recall mapping SHALL NOT perform control writes to Xi.", "anchor": "PDP-0001 ยง3โยง4" },
			{ "level": "MUST", "text": "Run ontology validation first; only RFC-0007โvalid items participate in equivalence detection and canonicalization.", "anchor": "RFC-0007 ยง2โยง4" },
			{ "level": "MUST", "text": "Define motif encoding for shift-equivalence as UTF-8 bytes of motif.id (validated), with the shift operator S as cyclic rotation over that byte sequence.", "anchor": "RFC-0007 ยง2โยง3" },
			{ "level": "MUST", "text": "Compute class_key from the canonical_form = min_rotation(UTF8(motif.id)) using lexicographic order on bytes; if multiple rotations are equal, append the chosen rotation_offset as uint32 big-endian before hashing.", "anchor": "RFC-0006 ยง3" },
			{ "level": "MUST", "text": "Use the same canonicalization rule for both indexing and recall; class_key = sha256hex(canonical_bytes || rotation_offset_be).", "anchor": "RFC-0006 ยง3โยง4" },
			{ "level": "MUST", "text": "Select exactly one canonical representative per class using a deterministic total order (e.g., lexicographic hash over validated encodings).", "anchor": "RFC-0006 ยง3โยง4" },
			{ "level": "MUST", "text": "Deny re-promotion of any non-canonical class member once a canonical exists (idempotence).", "anchor": "RFC-0006 ยง4; RFC-0005 ยง3โยง4" },
			{ "level": "MUST", "text": "Apply compression-by-equivalence before emitting any prune recommendation.", "anchor": "RFC-0006 ยง4; RFC-0009 ยง7" },
			{ "level": "SHOULD", "text": "Provide recall by computing an inverse shift mapping from query_item to the canonical representative of its class.", "anchor": "RFC-0006 ยง3" },
			{ "level": "MUST", "text": "Emit point-space glider tags only when enable_point_space_gliders=true; tags are structural only with schema: {classโ{glider,inverse}, v=cells/tick, phi, phi_unitโ{ticks,radians}, tau=ticks}.", "anchor": "RFC-0006 ยง3; RFC-0008 ยง4.1" }
		  ],
		  "error_model": [
			{ "code": "E.MMM.330", "when": "validated_items empty or missing", "message": "no_items_for_classification", "remedy": "Abort; require RFC-0007 validation first." },
			{ "code": "E.MMM.331", "when": "canonicalization tie without deterministic breaker", "message": "canonicalization_tie", "remedy": "Apply documented tie-break: append rotation_offset (uint32 BE) prior to hashing and retry." },
			{ "code": "E.MMM.332", "when": "attempt to promote a non-canonical member of an existing class", "message": "repromotion_denied", "remedy": "Return the existing canonical; update only occurrence references." },
			{ "code": "E.MMM.333", "when": "point-space tags present while flag disabled", "message": "glider_tag_leakage", "remedy": "Strip tags, emit gating_violation, proceed without point-space attributes." },
			{ "code": "E.MMM.334", "when": "invalid glider tag domain or units", "message": "invalid_glider_tag", "remedy": "Reject tag; require {classโ{glider,inverse}, v cells/tick, phi with phi_unitโ{ticks,radians}, tau in ticks}." }
		  ],
		  "metrics": [
			{ "name": "lawful_compression_ratio", "unit": "ratio", "window": "EMA-32", "notes": "Pre-prune snapshot: collapsed preimages / total validated intake." },
			{ "name": "equivalence_efficiency", "unit": "ratio", "window": "EMA-16", "notes": "Canonicals / (canonicals + occurrences)." },
			{ "name": "canonical_count", "unit": "count", "window": "EMA-32", "notes": "Active class representatives." },
			{ "name": "repromotion_denied_events", "unit": "events/tick", "window": "EMA-16", "notes": "Idempotence enforcement incidents (E.MMM.332)." },
			{ "name": "glider_velocity_mean", "unit": "cells/tick", "window": "EMA-32", "notes": "Only when enable_point_space_gliders=true; omitted otherwise." }
		  ],
		  "pseudocode": [
			{
			  "title": "compute_class_index (Observer; canonical key defined)",
			  "anchors": ["compute_class_index", "class_key_rule"],
			  "rfc_anchors": ["RFC-0007 ยง2โยง4", "RFC-0006 ยง3"],
			  "code": [
				"def compute_class_index(validated_items):",
				"    if not validated_items:",
				"        return {'status': 'rejected'}",
				"    class_index = {}  # map<class_key, list<motif_id>>",
				"    for m in validated_items:",
				"        b = utf8(m.id)                                  # encoding_contract",
				"        (canon_bytes, rotation_offset) = min_rotation(b)  # lexicographic on bytes",
				"        class_key = sha256hex(canon_bytes + uint32be(rotation_offset))",
				"        class_index.setdefault(class_key, []).append(m.id)",
				"    return {'status': 'classified', 'class_index': class_index}"
			  ]
			},
			{
			  "title": "select_canonical_and_recall (Observer; idempotent)",
			  "anchors": ["select_canonical", "recall_mapping"],
			  "rfc_anchors": ["RFC-0006 ยง3โยง4", "RFC-0005 ยง3โยง4"],
			  "code": [
				"def select_canonical_and_recall(class_index, query_item=None):",
				"    canonical_map = {}",
				"    for k, members in class_index.items():",
				"        # deterministic order over validated encodings",
				"        canon = min(members, key=lambda mid: sha256hex(utf8(mid)))",
				"        canonical_map[k] = canon",
				"    result = {'status': 'canonicalized', 'canonical_map': canonical_map}",
				"    if query_item is not None:",
				"        bq = utf8(query_item.id)",
				"        (qb, qoff) = min_rotation(bq)",
				"        kq = sha256hex(qb + uint32be(qoff))",
				"        rep = canonical_map.get(kq)",
				"        inv = {'inverse_shift': qoff} if rep else None  # structural mapping only",
				"        result.update({'status': 'mapped' if rep else 'rejected', 'recall_mapping': {'rep_id': rep, 'inverse_shift': qoff if rep else None}})",
				"    return result"
			  ]
			}
		  ],
		  "examples": [
			{
			  "title": "Sequence-only compression (flags OFF)",
			  "input": {
				"validated_items": [
				  { "id": "m1", "seq": "ababa" },
				  { "id": "m2", "seq": "babaa" },
				  { "id": "m3", "seq": "abaab" },
				  { "id": "m4", "seq": "abba" }
				],
				"feature_flags": { "enable_point_space_gliders": false }
			  },
			  "output": {
				"status": "canonicalized",
				"canonical_map": { "class_a": "m1", "class_b": "m4" }
			  },
			  "notes": "m1,m2,m3 collapse to one class via canonical_form; m4 is a singleton. No point-space tags emitted."
			},
			{
			  "title": "Glider tags gated (flags ON)",
			  "input": {
				"validated_items": [
				  { "id": "g1", "seq": "0101..." },
				  { "id": "g2", "seq": "1010..." }
				],
				"feature_flags": { "enable_point_space_gliders": true }
			  },
			  "output": {
				"status": "canonicalized",
				"canonical_map": { "class_g": "g1" },
				"point_space_tags": {
				  "g1": { "class": "glider", "v": 1, "phi": 0, "phi_unit": "ticks", "tau": 2 }
				}
			  },
			  "notes": "Tags are structural-only and gated; canonicalization remains observer-only."
			}
		  ]
		},
		{
		  "id": "3.3.1",
		  "title": "Encoding Contract (Shift-Equivalence)",
		  "description": "Defines the exact, observer-only encoding and canonicalization rules used to detect shift-equivalence classes over RFC-0007โvalidated motifs. Establishes a deterministic class_key for indexing/recall without implying runtime dynamics.",
		  "rfc_anchors": [
			"PDP-0001 ยง3โยง4",
			"RFC-0006 ยง3",
			"RFC-0007 ยง2โยง4",
			"RFC-0009 ยง5โยง7"
		  ],
		  "interfaces": {
			"inputs": [
			  { "name": "motif_id", "type": "string", "constraints": "MUST be RFC-0007โvalidated (version/DAG/provenance)", "notes": "The canonical identity string of a motif (may include Unicode, e.g., ฯ-null@ฮ)" }
			],
			"outputs": [
			  { "name": "canonical_bytes", "type": "bytes", "constraints": "Lexicographically minimal rotation over UTF-8(motif_id)", "notes": "Shift-normal form" },
			  { "name": "rotation_offset", "type": "uint32", "constraints": "0 โค offset < len(UTF-8(motif_id))", "notes": "Offset (in bytes) that yields canonical_bytes" },
			  { "name": "class_key", "type": "hex", "constraints": "sha256hex(canonical_bytes || uint32be(rotation_offset))", "notes": "Deterministic, stable across platforms" }
			],
			"side_effects": [ "observer-only" ]
		  },
		  "state_lifecycle": {
			"states": [ "validated", "encoded", "canonicalized", "keyed", "rejected" ],
			"transitions": [
			  { "from": "validated", "to": "encoded", "on": "utf8_encode", "guard": "motif_id is RFC-0007โvalid", "notes": "No additional normalization beyond RFC-0007" },
			  { "from": "encoded", "to": "canonicalized", "on": "min_rotation", "guard": "len(bytes)>0", "notes": "Lexicographic minimal rotation" },
			  { "from": "canonicalized", "to": "keyed", "on": "hash_key", "guard": "append uint32be(rotation_offset) before hashing", "notes": "sha256hex" },
			  { "from": "validated", "to": "rejected", "on": "utf8_error|invalid_id", "guard": "", "notes": "Fail fast on encoding/id violations" }
			]
		  },
		  "requirements": [
			{ "level": "MUST", "text": "Treat encoding as UTF-8 bytes of the RFC-0007โvalidated motif_id. Do not apply any normalization not specified by RFC-0007.", "anchor": "RFC-0007 ยง2โยง3" },
			{ "level": "MUST", "text": "Define the shift operator S as cyclic rotation over the UTF-8 byte sequence.", "anchor": "RFC-0006 ยง3" },
			{ "level": "MUST", "text": "Define canonical_form as the lexicographically minimal rotation of the UTF-8 byte sequence.", "anchor": "RFC-0006 ยง3" },
			{ "level": "MUST", "text": "If multiple rotations yield identical minimal bytes, select rotation_offset as the smallest byte offset producing canonical_form.", "anchor": "RFC-0006 ยง3" },
			{ "level": "MUST", "text": "Compute class_key = sha256hex(canonical_bytes || uint32be(rotation_offset)) and reuse this exact rule for both indexing and recall.", "anchor": "RFC-0006 ยง3โยง4" },
			{ "level": "MUST", "text": "Operate in observer-only posture; no control writes to ฮ are permitted.", "anchor": "PDP-0001 ยง3โยง4" },
			{ "level": "SHOULD", "text": "Expose rotation_offset to enable inverse-shift mapping during recall without recomputation.", "anchor": "RFC-0006 ยง3" }
		  ],
		  "error_model": [
			{ "code": "E.MMM.335", "when": "motif_id fails RFC-0007 validation or contains disallowed code points", "message": "motif_id_invalid", "remedy": "Reject; perform RFC-0007 normalization/validation first." },
			{ "code": "E.MMM.336", "when": "UTF-8 encoding error while producing bytes", "message": "utf8_encode_failure", "remedy": "Reject; require valid UTF-8 per RFC-0007 identity rules." },
			{ "code": "E.MMM.337", "when": "empty byte sequence after encoding", "message": "empty_encoded_id", "remedy": "Reject; id MUST be non-empty after UTF-8 encoding." }
		  ],
		  "metrics": [
			{ "name": "canonicalization_tie_rate", "unit": "events/tick", "window": "EMA-16", "notes": "Frequency of cases with โฅ2 minimal rotations (after tie-break selection)." },
			{ "name": "class_key_stability", "unit": "ratio", "window": "EMA-32", "notes": "Fraction of recomputations that reproduce the same class_key." }
		  ],
		  "pseudocode": [
			{
			  "title": "min_rotation (lexicographic on bytes)",
			  "anchors": [ "min_rotation", "encoding_contract" ],
			  "rfc_anchors": [ "RFC-0006 ยง3", "RFC-0007 ยง2โยง3" ],
			  "code": [
				"def min_rotation(b: bytes) -> (bytes, int):",
				"    # Return (canonical_bytes, rotation_offset)",
				"    n = len(b)",
				"    candidates = []",
				"    for i in range(n):",
				"        r = b[i:] + b[:i]",
				"        candidates.append((r, i))",
				"    # Lexicographic min by bytes, then smallest offset",
				"    canon_bytes, offset = min(candidates, key=lambda t: (t[0], t[1]))",
				"    return canon_bytes, offset"
			  ]
			},
			{
			  "title": "class_key (stable across platforms)",
			  "anchors": [ "class_key_rule" ],
			  "rfc_anchors": [ "RFC-0006 ยง3โยง4", "PDP-0001 ยง3โยง4" ],
			  "code": [
				"def class_key(motif_id: str) -> str:",
				"    b = utf8(motif_id)                 # RFC-0007-validated id",
				"    canon, off = min_rotation(b)       # per min_rotation above",
				"    return sha256hex(canon + uint32be(off))"
			  ]
			}
		  ],
		  "examples": [
			{
			  "title": "Deterministic key for Unicode id",
			  "input": { "motif_id": "ฯ-null@ฮ" },
			  "output": {
				"canonical_bytes": "<lexicographically minimal rotation of UTF-8('ฯ-null@ฮ')>",
				"rotation_offset": 0,
				"class_key": "<sha256hex(canonical_bytes || 0x00000000)>"
			  },
			  "notes": "Exact bytes depend on UTF-8 of Unicode code points; rule is deterministic and observer-only."
			},
			{
			  "title": "Tie-break with repeated pattern",
			  "input": { "motif_id": "ababab" },
			  "output": {
				"canonical_bytes": "ababab",
				"rotation_offset": 0,
				"class_key": "sha256hex(b\"ababab\" || 0x00000000)"
			  },
			  "notes": "Multiple minimal rotations exist; choose smallest offset (0)."
			}
		  ]
		}		
    },

    "4": {
      "id": "4",
	  "title": "Integration, Security, and Recovery Protocols",
		{
		  "id": "4.1",
		  "title": "Exchange & Integrity (Import/Export/Registry)",
		  "description": "Observer-only contracts for exporting and importing Layer_1 artifacts using routing envelopes (RFC-0008) and structural integrity lineage (RFC-0009). Defines an adaptive acceptance horizon (Delta_tau_phase), a hybrid seen_set replay defense, structural origin validation via a local trusted root, and the computation context for Sigma_phase via coherence_time_vector(C_hist, t). Checksums (Sigma_phase, Delta_hash) are strictly feature-flag gated. No control writes to Xi.",
		  "rfc_anchors": [
			"PDP-0001 ยง3โยง4",
			"PDP-0001 ยง4.4",
			"RFC-0005 ยง4.3",
			"RFC-0006 ยง4.1",
			"RFC-0008 ยง2โยง3",
			"RFC-0008 ยง5",
			"RFC-0009 ยง6.1",
			"RFC-0009 ยง5โยง7"
		  ],
		  "interfaces": {
			"inputs": [
			  { "name": "payload", "type": "object", "constraints": "Serializable; if ontology bundle then RFC-0007-conformant", "notes": "Export/import body" },
			  { "name": "provenance", "type": "object", "constraints": "Includes origin; MAY include origin_fields and origin_hash (when enabled)", "notes": "Structural provenance only at L1" },
			  { "name": "feature_flags", "type": "object", "constraints": "Boolean keys: enable_exchange_envelope, enable_integrity_checks, enable_provenance_on_export", "notes": "Gates checksum presence and validation" },
			  { "name": "coherence_history", "type": "array<number>", "constraints": "Non-empty; each 0 <= C <= 1", "notes": "Recent coherence samples for EMA-32 and local delta" },
			  { "name": "last_Delta_hash", "type": "string|null", "constraints": "Required on export if enable_integrity_checks=true", "notes": "Lineage chain parent for export" },
			  { "name": "parent_Delta_hash", "type": "string|null", "constraints": "Required on import if enable_integrity_checks=true", "notes": "Expected parent for import verification" },
			  { "name": "trusted_root_registry", "type": "set<object>", "constraints": "Local structural registry (PDP-0001); non-cryptographic at L1", "notes": "Permitted origins" },
			  { "name": "now_tick", "type": "integer", "constraints": "Monotonic tick", "notes": "Used for horizon and replay checks" },
			  { "name": "accept_skew_ticks", "type": "integer", "constraints": ">= 0", "notes": "Optional drift tolerance on import" }
			],
			"outputs": [
			  { "name": "packet", "type": "object", "constraints": "Envelope: {body, provenance, timestamp, valid_until, Sigma_phase?, Delta_hash?}", "notes": "On export only; gated keys omitted when flags false" },
			  { "name": "status", "type": "string", "constraints": "one of {accepted, rejected, skipped, updated}", "notes": "Import/export/registry update result" }
			],
			"side_effects": [ "observer-only" ]
		  },
		  "state_lifecycle": {
			"states": [ "Idle", "PreparedEnvelope", "Exported", "ImportedStaged", "Rejected" ],
			"transitions": [
			  { "from": "Idle", "to": "PreparedEnvelope", "on": "export_request", "guard": "provenance.origin โ trusted_root_registry", "notes": "Structural provenance pre-check" },
			  { "from": "PreparedEnvelope", "to": "Exported", "on": "flags_ok_and_checksums_applied", "guard": "flag-gated checksum rules satisfied", "notes": "Sigma_phase/Delta_hash added only when enabled" },
			  { "from": "Idle", "to": "ImportedStaged", "on": "import_packet", "guard": "within Delta_tau_phase AND origin valid AND (gated checksums verified if present)", "notes": "Observer staging only" },
			  { "from": "Idle", "to": "Rejected", "on": "import_packet", "guard": "any guard fails OR seen_set replay", "notes": "Deterministic rejection reasons" }
			]
		  },
		  "requirements": [
			{ "level": "MUST", "text": "Honor observer-only posture: no control writes to Xi during export/import/registry update.", "anchor": "PDP-0001 ยง3โยง4" },
			{ "level": "MUST", "text": "Expose coherence_time_vector(C_hist, t_now) โ {C_ema: EMA-32(C_hist), dC: delta(C_hist), t: t_now}; when |C_hist|<2, set dC:=0. This vector is the sole temporal context for Sigma_phase at Layer_1.", "anchor": "RFC-0005 ยง4.3; RFC-0009 ยง6.1" },
			{ "level": "MUST", "text": "Compute Delta_tau_phase = alpha * C_ema where C_ema=EMA-32(C_hist); reject imports with now_tick > valid_until + accept_skew_ticks.", "anchor": "RFC-0008 ยง2โยง3; RFC-0009 ยง6.1" },
			{ "level": "MUST", "text": "Maintain a hybrid seen_set with time_window = 2 * Delta_tau_phase and LRU eviction within this window to defend against replay.", "anchor": "RFC-0005 ยง4.3; RFC-0008 ยง2.2" },
			{ "level": "MUST", "text": "Validate structural origin BEFORE lineage acceptance: provenance.origin โ trusted_root_registry AND, when present, H(canonical_json(origin_fields)) == provenance.origin_hash (canonical_json per PDP-0001 ยง4.4).", "anchor": "PDP-0001 ยง4.4; RFC-0008 ยง5" },
			{ "level": "MUST", "text": "Emit Sigma_phase only when enable_exchange_envelope=true; otherwise the Sigma_phase key MUST be absent.", "anchor": "RFC-0008 ยง2โยง3" },
			{ "level": "MUST", "text": "Emit Delta_hash only when enable_integrity_checks=true; otherwise the Delta_hash key MUST be absent.", "anchor": "RFC-0009 ยง5โยง7" },
			{ "level": "MUST", "text": "On import, verify Sigma_phase and Delta_hash exactly when their respective flags are enabled; any mismatch causes rejection.", "anchor": "RFC-0008 ยง3; RFC-0009 ยง6.1" },
			{ "level": "SHOULD", "text": "Choose alpha โ [0.5, 2.0] to keep Delta_tau_phase stable under weak-field coherence.", "anchor": "RFC-0006 ยง4.1; RFC-0009 ยง7" },
			{ "level": "MAY", "text": "Apply a bounded accept_skew_ticks for cross-node drift consistent with the safety case.", "anchor": "RFC-0008 ยง2.2" }
		  ],
		  "error_model": [
			{ "code": "E.MMM.410", "when": "Checksum present while corresponding feature flag is false", "message": "Checksum present but feature flag disabled", "remedy": "Strip the field and reject the packet" },
			{ "code": "E.MMM.411", "when": "Feature flag true but checksum absent", "message": "Required checksum missing", "remedy": "Reject and emit telemetry" },
			{ "code": "E.MMM.412", "when": "Delta_hash does not match expected parent chain", "message": "Lineage hash mismatch", "remedy": "Reject; request resend from last accepted parent" },
			{ "code": "E.MMM.413", "when": "Sigma_phase recomputation fails under coherence_time_vector", "message": "Phase checksum mismatch", "remedy": "Reject as tampered or corrupted" },
			{ "code": "E.MMM.414", "when": "now_tick exceeds packet.valid_until + accept_skew_ticks", "message": "Packet outside acceptance horizon", "remedy": "Reject; advise producer to refresh" },
			{ "code": "E.MMM.415", "when": "provenance.origin not found in trusted_root_registry", "message": "Unrecognized origin", "remedy": "Reject; update registry via governed path if legitimate" },
			{ "code": "E.MMM.416", "when": "H(canonical_json(origin_fields)) != provenance.origin_hash (when provided)", "message": "Origin hash mismatch (canonical_json per PDP-0001 ยง4.4)", "remedy": "Reject; investigate provenance construction" },
			{ "code": "E.MMM.417", "when": "Registry update bundle fails structural schema validation", "message": "Registry update invalid at Layer_1", "remedy": "Reject; correct to PDP-0001 schema" },
			{ "code": "E.MMM.418", "when": "seen_set indicates prior arrival within window", "message": "Replay suspect", "remedy": "Reject and emit telemetry" }
		  ],
		  "metrics": [
			{ "name": "export_success_rate", "unit": "events_per_tick", "window": "EMA-32", "notes": "Accepted exports / attempted exports" },
			{ "name": "import_reject_rate", "unit": "events_per_tick", "window": "EMA-32", "notes": "Rejected imports / total imports" },
			{ "name": "unrecognized_origin_count", "unit": "events", "window": "EMA-32", "notes": "Provenance origins not in trusted_root_registry" },
			{ "name": "avg_replay_window_ticks", "unit": "ticks", "window": "EMA-32", "notes": "Average Delta_tau_phase derived from C_ema" },
			{ "name": "replay_drop_rate", "unit": "events_per_tick", "window": "EMA-32", "notes": "Drops due to seen_set within 2 * Delta_tau_phase window" },
			{ "name": "seen_set_size", "unit": "count", "window": "EMA-16", "notes": "Current entries in replay window (LRU-managed)" },
			{ "name": "phase_checksum_error_rate", "unit": "events_per_tick", "window": "EMA-32", "notes": "Sigma_phase mismatches over imports with envelope enabled" }
		  ],
		  "pseudocode": [
			{
			  "title": "coherence_time_vector (observer context for Sigma_phase)",
			  "anchors": [ "coherence_time_vector", "phase_context" ],
			  "rfc_anchors": [ "RFC-0005 ยง4.3", "RFC-0009 ยง6.1" ],
			  "code": [
				"def coherence_time_vector(C_hist, t_now):",
				"    C_ema = EMA32(C_hist)                 # Layer_1 context only",
				"    dC = (C_hist[-1] - C_hist[-2]) if len(C_hist) > 1 else 0",
				"    return {'C_ema': C_ema, 'dC': dC, 't': t_now}"
			  ]
			},
			{
			  "title": "export_payload (observer)",
			  "anchors": [ "export_payload", "phase_checksum", "hash_lineage" ],
			  "rfc_anchors": [ "RFC-0008 ยง2โยง3", "RFC-0009 ยง5โยง7", "PDP-0001 ยง3โยง4", "PDP-0001 ยง4.4" ],
			  "code": [
				"def export_payload(payload, provenance, feature_flags, last_Delta_hash, C_hist, trusted_root):",
				"    if provenance['origin'] not in trusted_root: return {'status':'rejected','error':'E.MMM.415'}",
				"    packet = {'body': payload, 'provenance': provenance, 'timestamp': tick_now()}",
				"    if feature_flags.get('enable_exchange_envelope'):",
				"        ctx = coherence_time_vector(C_hist, packet['timestamp'])",
				"        packet['Sigma_phase'] = phase_checksum(payload, ctx)",
				"    if feature_flags.get('enable_integrity_checks'):",
				"        if last_Delta_hash is None: return {'status':'rejected','error':'E.MMM.411'}",
				"        packet['Delta_hash'] = hash_lineage(payload, last_Delta_hash)",
				"    if feature_flags.get('enable_provenance_on_export'):",
				"        packet['provenance']['origin_hash'] = H(canonical_json(packet['provenance'].get('origin_fields', {})))",
				"    Delta_tau_phase = alpha() * coherence_time_vector(C_hist, packet['timestamp'])['C_ema']",
				"    packet['valid_until'] = packet['timestamp'] + Delta_tau_phase",
				"    return {'status':'accepted','packet':packet}"
			  ]
			},
			{
			  "title": "import_payload (observer) with hybrid replay defense",
			  "anchors": [ "import_payload", "seen_set_replay_defense" ],
			  "rfc_anchors": [ "RFC-0005 ยง4.3", "RFC-0008 ยง2โยง3", "RFC-0008 ยง5", "RFC-0009 ยง6.1", "PDP-0001 ยง4.4" ],
			  "code": [
				"def import_payload(packet, feature_flags, parent_Delta_hash, trusted_root, accept_skew_ticks=0):",
				"    if tick_now() > packet['valid_until'] + accept_skew_ticks:",
				"        return {'status':'rejected','error':'E.MMM.414'}",
				"    key = compose_key(packet, feature_flags)",
				"    if seen_set.contains(key) and seen_set.within_window(key):",
				"        telemetry('replay_suspect'); return {'status':'rejected','error':'E.MMM.418'}",
				"    if feature_flags.get('enable_exchange_envelope') and not verify_sigma(packet):",
				"        return {'status':'rejected','error':'E.MMM.413'}",
				"    if feature_flags.get('enable_integrity_checks') and not verify_delta(packet, parent_Delta_hash):",
				"        return {'status':'rejected','error':'E.MMM.412'}",
				"    if packet['provenance']['origin'] not in trusted_root: return {'status':'rejected','error':'E.MMM.415'}",
				"    if 'origin_hash' in packet['provenance'] and H(canonical_json(packet['provenance'].get('origin_fields', {}))) != packet['provenance']['origin_hash']:",
				"        return {'status':'rejected','error':'E.MMM.416'}",
				"    seen_set.insert(key, window=2*delta_tau_from(packet))  # LRU within window",
				"    stage_observer_only(packet['body'])",
				"    telemetry('import_accept')",
				"    return {'status':'accepted'}"
			  ]
			}
		  ],
		  "examples": [
			{
			  "title": "flag_gated_checksums",
			  "input": {
				"feature_flags": { "enable_exchange_envelope": true, "enable_integrity_checks": true, "enable_provenance_on_export": true },
				"payload": { "kind": "density_report", "v": 1 },
				"provenance": { "origin": "node:A", "origin_fields": { "id": "A", "region": "us-west" } },
				"last_Delta_hash": "abc123",
				"coherence_history": [0.91, 0.92, 0.92, 0.93],
				"trusted_root_registry": [{ "origin": "node:A" }],
				"now_tick": 1000,
				"accept_skew_ticks": 5
			  },
			  "output": {
				"status": "accepted",
				"packet_keys_present": [ "Sigma_phase", "Delta_hash", "valid_until", "provenance.origin_hash" ]
			  },
			  "notes": "If a checksum flag is false, the corresponding key MUST be absent from the packet."
			},
			{
			  "title": "replay_drop_by_seen_set",
			  "input": {
				"feature_flags": { "enable_exchange_envelope": true, "enable_integrity_checks": false },
				"packet_key_fields": { "origin": "node:A", "Sigma_phase": "s1", "bundle_id": "B" },
				"trusted_root_registry": [{ "origin": "node:A" }],
				"now_tick": 2000
			  },
			  "output": {
				"status": "rejected",
				"error": "E.MMM.418"
			  },
			  "notes": "Second arrival within the 2 * Delta_tau_phase window is rejected via seen_set."
			}
		  ]
		},
		{
		  "id": "4.2",
		  "title": "Decay and Recovery Protocols",
		  "description": "Observer-only contracts for lawful decay, bounded recovery, and diagnostic quarantine that restore motif states without control writes. Every recovery episode terminates in exactly one of {reanchored, quarantined, abandoned}. Reanchor attempts are idempotent and overlap-aware via a recovery_token.",
		  "rfc_anchors": [
			"PDP-0001 ยง4.5",
			"RFC-0005 ยง3โยง4",
			"RFC-0006 ยง3โยง4",
			"RFC-0008 ยง2.2",
			"RFC-0009 ยง5โยง7, ยง9โยง10"
		  ],
		  "interfaces": {
			"inputs": [
			  { "name": "snapshot_history", "type": "list<object>", "constraints": "Time-ordered, observer-captured snapshots", "notes": "Used to locate last lawful state" },
			  { "name": "stability", "type": "number", "constraints": "0<=stability<=1", "notes": "Smoothed coherence stability signal for EMA32" },
			  { "name": "violation_rate", "type": "number", "constraints": "0<=violation_rate<=1", "notes": "Recent rate of integrity/coherence violations (EMA16)" },
			  { "name": "rho_res", "type": "number", "constraints": "Band-limited per RFC-0009", "notes": "Resonance indicator for violation checks" },
			  { "name": "RIR", "type": "number", "constraints": "Non-negative", "notes": "Repair/immune response factor" },
			  { "name": "SII", "type": "number", "constraints": "Non-negative", "notes": "Structural integrity index" },
			  { "name": "epsilon", "type": "number", "constraints": "Small bounded noise", "notes": "Perturbation bound for decay and diagnostics" },
			  { "name": "lambda", "type": "number", "constraints": "Reinforcement term", "notes": "Observer-estimated input" },
			  { "name": "gamma_co", "type": "number", "constraints": "Damping term", "notes": "Observer-estimated input" },
			  { "name": "dt", "type": "number", "constraints": "tick units", "notes": "Integration step for decay projection" },
			  { "name": "recovery_token", "type": "string", "constraints": "Opaque, unique per episode", "notes": "Idempotency key; denies reentry with same token" },
			  { "name": "now_tick", "type": "integer", "constraints": "Monotonic tick", "notes": "Used for budgets and TTLs" },
			  { "name": "quarantine_ttl", "type": "integer", "constraints": "ticks>0", "notes": "Max diagnostic duration in quarantine window" }
			],
			"outputs": [
			  { "name": "termination_state", "type": "string", "constraints": "one of {reanchored, quarantined, abandoned}", "notes": "Required terminal label per episode" },
			  { "name": "attempts_used", "type": "integer", "constraints": ">=0", "notes": "Number of reanchor attempts consumed" },
			  { "name": "audit_trail", "type": "list<object>", "constraints": "Append-only events", "notes": "Episode evidence for post-mortem" }
			],
			"side_effects": [
			  "observer-only"
			]
		  },
		  "state_lifecycle": {
			"states": [
			  "Normal",
			  "ViolationDetected",
			  "RecoveryWindow",
			  "ReanchorAttempting",
			  "Quarantined",
			  "Reanchored",
			  "Abandoned"
			],
			"transitions": [
			  { "from": "Normal", "to": "ViolationDetected", "on": "violation_condition", "guard": "|RIR*SII - k_homeostasis|>epsilon OR rho_res out_of_band", "notes": "Open recovery window marker" },
			  { "from": "ViolationDetected", "to": "RecoveryWindow", "on": "window_open", "guard": "episode not active with same recovery_token", "notes": "Idempotent open" },
			  { "from": "RecoveryWindow", "to": "ReanchorAttempting", "on": "budget_available", "guard": "N_max(now_tick)>0", "notes": "Begin bounded attempts" },
			  { "from": "ReanchorAttempting", "to": "Reanchored", "on": "lawful_candidate", "guard": "closure satisfied and resonance in band", "notes": "Terminate success" },
			  { "from": "ReanchorAttempting", "to": "Quarantined", "on": "overlap_or_budget_exhausted", "guard": "window overlap OR attempts==N_max", "notes": "Escalate to diagnostics" },
			  { "from": "Quarantined", "to": "Reanchored", "on": "diagnostic_converges", "guard": "jacobian_norm<=J_max AND closure_improving", "notes": "Mark for reanchor" },
			  { "from": "Quarantined", "to": "Abandoned", "on": "ttl_expired_or_no_progress", "guard": "quarantine_ttl exceeded OR progress fails", "notes": "Terminate safely" }
			]
		  },
		  "requirements": [
			{ "level": "MUST", "text": "Maintain observer-only posture; decay, recovery, and quarantine perform measurement, staging, and routing only; no control writes to Xi.", "anchor": "PDP-0001 ยง4.5" },
			{ "level": "MUST", "text": "Each recovery episode terminates in exactly one of {reanchored, quarantined, abandoned} and emits an immutable audit trail.", "anchor": "RFC-0009 ยง5.2" },
			{ "level": "MUST", "text": "Reanchor attempts are bounded by N_max = N0 + alpha*EMA32(stability) - beta*EMA16(violation_rate).", "anchor": "RFC-0009 ยง5โยง7" },
			{ "level": "MUST", "text": "Reanchor is idempotent and overlap-aware: reuse of the same recovery_token for an active episode is rejected with no side effects.", "anchor": "RFC-0009 ยง5.1" },
			{ "level": "MUST", "text": "Escalate to quarantine upon window overlap or budget exhaustion; diagnostics operate under bounded Jacobian norms and track closure improvement before exit.", "anchor": "RFC-0009 ยง9โยง10" },
			{ "level": "MUST", "text": "Decay projection clamps C to [0,1] and follows dC/dt = lambda - gamma_co + epsilon.", "anchor": "RFC-0005 ยง3โยง4" },
			{ "level": "SHOULD", "text": "Choose alpha in [0.5,2.0] and beta in [0.5,2.0] to prevent oscillatory attempt budgets under weak-field conditions.", "anchor": "RFC-0006 ยง3; RFC-0009 ยง7" },
			{ "level": "MAY", "text": "Perform micro-perturbation diagnostics in quarantine with perturbation caps that preserve observer safety (no writes).", "anchor": "RFC-0009 ยง9.3" }
		  ],
		  "error_model": [
			{ "code": "E.MMM.recovery.token_duplicate", "when": "Recovery invoked with an already-active recovery_token", "message": "Duplicate recovery token denied", "remedy": "Reject reentry; return existing episode handle" },
			{ "code": "E.MMM.recovery.budget_exhausted", "when": "Reanchor attempts reached N_max", "message": "Attempt budget exhausted", "remedy": "Escalate to quarantine" },
			{ "code": "E.MMM.recovery.window_overlap", "when": "Overlapping recovery windows detected", "message": "Overlap detected", "remedy": "Close newest window or escalate to quarantine" },
			{ "code": "E.MMM.decay.inputs_invalid", "when": "Decay inputs out of range or NaN", "message": "Invalid decay parameters", "remedy": "Clamp or drop tick; emit telemetry" },
			{ "code": "E.MMM.quarantine.ttl_expired", "when": "Quarantine exceeded ttl without convergence", "message": "Quarantine TTL expired", "remedy": "Terminate as abandoned with audit event" }
		  ],
		  "metrics": [
			{ "name": "integrity_violation_rate", "unit": "events_per_tick", "window": "EMA-32", "notes": "Rate of violation_condition triggers" },
			{ "name": "reanchor_attempt_rate", "unit": "events_per_tick", "window": "EMA-32", "notes": "Attempts per tick while in ReanchorAttempting" },
			{ "name": "reanchor_success_rate", "unit": "events_per_tick", "window": "EMA-32", "notes": "Successful reanchors per tick" },
			{ "name": "quarantine_count", "unit": "count", "window": "EMA-32", "notes": "Active items under quarantine" },
			{ "name": "recovery_outcome_distribution", "unit": "ratio", "window": "EMA-64", "notes": "Share of {reanchored, quarantined, abandoned}" },
			{ "name": "diagnostic_jacobian_norm", "unit": "unitless", "window": "EMA-16", "notes": "Estimated local Jacobian bound during diagnostics" },
			{ "name": "attempt_budget_N_max", "unit": "count", "window": "EMA-32", "notes": "Observed N_max for active episodes" }
		  ],
		  "pseudocode": [
			{
			  "title": "lawful_decay_step (observer)",
			  "anchors": ["lawful_decay_step"],
			  "rfc_anchors": ["RFC-0005 ยง3โยง4"],
			  "code": [
				"def lawful_decay_step(C, lambda_, gamma_co, epsilon, dt):",
				"    dC = lambda_ - gamma_co + epsilon",
				"    C_next = min(1.0, max(0.0, C + dC * dt))",
				"    telemetry('decay_tick', {'C_next': C_next, 'dC': dC})",
				"    return C_next"
			  ]
			},
			{
			  "title": "reanchor_protocol (idempotent, overlap-aware)",
			  "anchors": ["reanchor_protocol"],
			  "rfc_anchors": ["RFC-0009 ยง5โยง7"],
			  "code": [
				"def reanchor_protocol(recovery_token, snapshot_history, stability, violation_rate, params):",
				"    if episode_store.active(recovery_token):",
				"        return {'status':'rejected','error':'E.MMM.recovery.token_duplicate','attempts_used':0}",
				"    episode_store.open(recovery_token)",
				"    N_max = params.N0 + params.alpha * EMA32(stability) - params.beta * EMA16(violation_rate)",
				"    N_max = max(1, int(round(N_max)))",
				"    for i in range(1, N_max+1):",
				"        if episode_store.overlap(recovery_token):",
				"            episode_store.mark(recovery_token,'overlap')",
				"            return {'status':'escalate_quarantine','attempts_used':i}",
				"        candidate = last_lawful(snapshot_history, window=params.tau_recovery)",
				"        stage_observer_only(candidate)",
				"        if is_lawful(candidate):",
				"            audit('reanchor_success', {'token': recovery_token, 'i': i})",
				"            episode_store.close(recovery_token)",
				"            return {'status':'reanchored','attempts_used':i}",
				"        audit('reanchor_attempt', {'token': recovery_token, 'i': i})",
				"    episode_store.mark(recovery_token,'budget_exhausted')",
				"    return {'status':'escalate_quarantine','attempts_used':N_max}"
			  ]
			},
			{
			  "title": "quarantine_loop (bounded diagnostics)",
			  "anchors": ["quarantine_loop"],
			  "rfc_anchors": ["RFC-0009 ยง9โยง10"],
			  "code": [
				"def quarantine_loop(quarantine_set, ttl, J_max, perturbation_cap):",
				"    t0 = tick_now()",
				"    while tick_now() - t0 < ttl:",
				"        progress = False",
				"        for motif in quarantine_set:",
				"            micro = bounded_perturbation(perturbation_cap)  # measurement-class simulation",
				"            J = jacobian_estimate(motif, window='EMA-16')",
				"            if closure_improving(motif, micro) and J <= J_max:",
				"                telemetry('diagnostic_pass', {'motif': id(motif)})",
				"                mark_for_reanchor(motif)",
				"                progress = True",
				"            else:",
				"                telemetry('diagnostic_retry', {'motif': id(motif)})",
				"        if progress:",
				"            return {'status':'recovery_ready'}",
				"    return {'status':'hold_quarantine'}"
			  ]
			}
		  ],
		  "examples": [
			{
			  "title": "deterministic_termination_states",
			  "input": {
				"stability": 0.9,
				"violation_rate": 0.1,
				"snapshot_history": ["..."],
				"recovery_token": "tok-123",
				"params": { "N0": 1, "alpha": 1.0, "beta": 1.0, "tau_recovery": 100 }
			  },
			  "output": {
				"possible": [
				  { "condition": "lawful candidate within N_max", "termination_state": "reanchored" },
				  { "condition": "budget exhausted or overlap; diagnostics not converged yet", "termination_state": "quarantined" },
				  { "condition": "ttl expired without progress", "termination_state": "abandoned" }
				]
			  },
			  "notes": "All outcomes emit an append-only audit trail."
			},
			{
			  "title": "idempotent_reentry_denied",
			  "input": {
				"recovery_token": "tok-123",
				"episode_already_active": true
			  },
			  "output": {
				"status": "rejected",
				"error": "E.MMM.recovery.token_duplicate"
			  },
			  "notes": "Prevents duplicate work and crash loops."
			}
		  ]
		},
		{
		  "id": "4.3",
		  "title": "Security and Data Handling (L1 posture)",
		  "description": "Layer_1 states structural security guarantees for exchange, staging, and at-rest handling. Validation is structural only: origin membership in the local trusted root, envelope policy compliance, and declared signature-type profile checks. Cryptography, keystores, RBAC/consent, remote trust, and persistence bindings are deferred to Layer_2.",
		  "rfc_anchors": [
			"PDP-0001 ยง3.1, ยง4.4โยง4.5",
			"RFC-0005 ยง4.2",
			"RFC-0007 ยง5โยง6, ยง8",
			"RFC-0008 ยง2.1, ยง5โยง6",
			"RFC-0009 ยง5.1, ยง7.2, ยง9.3; Appx D.4"
		  ],
		  "interfaces": {
			"inputs": [
			  { "name": "packet", "type": "object", "constraints": "SRX-like envelope shape per ยง4.1; may include Sigma_phase?, Delta_hash?", "notes": "Inbound artifact for structural checks" },
			  { "name": "feature_flags", "type": "object", "constraints": "enable_exchange_envelope, enable_integrity_checks (booleans)", "notes": "Gates checksum presence/verification" },
			  { "name": "agent_registry", "type": "map<string,object>", "constraints": "agent_id โ {allowed_sig_types:[string]}", "notes": "Local structural profile registry" },
			  { "name": "trusted_root_registry", "type": "set<object>", "constraints": "Origins authorized at Layer_1 (structural, non-cryptographic)", "notes": "See PDP-0001" },
			  { "name": "bundle", "type": "object", "constraints": "If at-rest handling; must include storage_profile{profile,retention_ticks}", "notes": "Ontology or report bundle" },
			  { "name": "tau_decay", "type": "integer", "constraints": "ticks>0", "notes": "Retention floor derived from lawful decay (RFC-0005 ยง4.2)" }
			],
			"outputs": [
			  { "name": "status", "type": "string", "constraints": "one of {accepted, rejected, quarantined, noop, expire, retain}", "notes": "Decision/result per operation" },
			  { "name": "reason", "type": "string", "constraints": "machine-readable reason key", "notes": "Returned on rejection/branching" }
			],
			"side_effects": [
			  "observer-only"
			]
		  },
		  "state_lifecycle": {
			"states": [
			  "Idle",
			  "EnvelopeChecked",
			  "OriginChecked",
			  "PolicyChecked",
			  "AcceptedStaged",
			  "Rejected",
			  "Quarantined"
			],
			"transitions": [
			  { "from": "Idle", "to": "EnvelopeChecked", "on": "packet_received", "guard": "packet shape present", "notes": "Begin structural checks" },
			  { "from": "EnvelopeChecked", "to": "Rejected", "on": "checksum_required_missing", "guard": "flag requires checksum but absent", "notes": "See ยง4.1 gating" },
			  { "from": "EnvelopeChecked", "to": "OriginChecked", "on": "checksums_ok_or_not_required", "guard": "gating satisfied", "notes": "" },
			  { "from": "OriginChecked", "to": "Rejected", "on": "unrecognized_seed_or_origin_hash_mismatch", "guard": "origin โ trusted_root OR H(origin_fields)โorigin_hash", "notes": "" },
			  { "from": "OriginChecked", "to": "PolicyChecked", "on": "seed_ok", "guard": "origin recognized", "notes": "" },
			  { "from": "PolicyChecked", "to": "Rejected", "on": "illegal_sig_type_or_wrapped_unsigned", "guard": "sig_type not allowed OR envelope claims signed without signature_block", "notes": "Confused-deputy defense" },
			  { "from": "PolicyChecked", "to": "AcceptedStaged", "on": "structurally_valid", "guard": "all checks passed", "notes": "Observer staging only" },
			  { "from": "Rejected", "to": "Quarantined", "on": "staging_policy_route", "guard": "deployment chooses quarantine for analysis", "notes": "No control writes" }
			]
		  },
		  "requirements": [
			{ "level": "MUST", "text": "Maintain observer-only posture: validation, staging, routing only; no control writes to Xi.", "anchor": "PDP-0001 ยง4.5" },
			{ "level": "MUST", "text": "Enforce checksum gating: Sigma_phase present iff enable_exchange_envelope=true; Delta_hash present iff enable_integrity_checks=true; otherwise keys MUST be absent.", "anchor": "RFC-0008 ยง5โยง6; RFC-0009 Appx D.4" },
			{ "level": "MUST", "text": "Validate structural origin: provenance.origin โ trusted_root_registry AND H(origin_fields) == origin_hash (when provided) before any acceptance.", "anchor": "PDP-0001 ยง3.1, ยง4.4" },
			{ "level": "MUST", "text": "Validate envelope.sig_type by structural profile only: sig_type โ agent_registry[provenance.origin.agent_id].allowed_sig_types.", "anchor": "RFC-0008 ยง5โยง6" },
			{ "level": "MUST", "text": "Reject wrapped-unsigned: if envelope claims a signed origin but signature_block is null/empty/stub, the packet is rejected.", "anchor": "RFC-0008 ยง5โยง6" },
			{ "level": "MUST", "text": "At-rest handling requires declared storage_profile.profile โ {volatile, durable} and retention_ticks โฅ tau_decay.", "anchor": "RFC-0005 ยง4.2" },
			{ "level": "SHOULD", "text": "Persist provenance {origin, origin_hash, created_at} and lineage {parent_hash, integrity_hash} blocks only after passing structural checks.", "anchor": "RFC-0007 ยง5โยง6; RFC-0009 Appx D.4" },
			{ "level": "MAY", "text": "Route structurally suspicious packets to quarantine staging with diagnostic telemetry rather than drop-only handling.", "anchor": "RFC-0009 ยง9.3" }
		  ],
		  "error_model": [
			{ "code": "E.MMM.flag.missing_sigma", "when": "enable_exchange_envelope=true but Sigma_phase absent", "message": "Required Sigma_phase missing", "remedy": "Reject; increment import_reject_missing_checksum" },
			{ "code": "E.MMM.flag.missing_delta", "when": "enable_integrity_checks=true but Delta_hash absent", "message": "Required Delta_hash missing", "remedy": "Reject; increment import_reject_missing_checksum" },
			{ "code": "E.MMM.origin.unrecognized", "when": "provenance.origin not in trusted_root_registry", "message": "Unrecognized origin seed", "remedy": "Reject; consider quarantine staging" },
			{ "code": "E.MMM.origin.hash_mismatch", "when": "H(origin_fields) != origin_hash", "message": "Origin hash mismatch", "remedy": "Reject; investigate provenance construction" },
			{ "code": "E.MMM.policy.illegal_sig_type", "when": "envelope.sig_type not allowed for origin agent_id", "message": "Illegal signature-type declaration", "remedy": "Reject; increment illegal_sig_type_rate" },
			{ "code": "E.MMM.policy.wrapped_unsigned", "when": "Envelope claims signed but signature_block missing/empty/stub", "message": "Wrapped unsigned payload", "remedy": "Reject; increment wrapped_unsigned_rejects" }
		  ],
		  "metrics": [
			{ "name": "illegal_sig_type_rate", "unit": "events_per_tick", "window": "EMA-32", "notes": "Rejections due to disallowed envelope.sig_type" },
			{ "name": "wrapped_unsigned_rejects", "unit": "events", "window": "EMA-32", "notes": "Count of rejected wrapped-unsigned attempts (confused-deputy defense)" },
			{ "name": "import_reject_missing_checksum", "unit": "events_per_tick", "window": "EMA-32", "notes": "Rejections for missing Sigma_phase/Delta_hash when required" },
			{ "name": "staging_quarantine_count", "unit": "events", "window": "EMA-32", "notes": "Packets routed to quarantine after structural policy failures" },
			{ "name": "at_rest_expirations", "unit": "events", "window": "EMA-32", "notes": "Bundles expired by retention policy (tau_decay floor)" }
		  ],
		  "pseudocode": [
			{
			  "title": "validate_envelope_and_origin (structural only)",
			  "anchors": ["validate_envelope_and_origin"],
			  "rfc_anchors": ["RFC-0008 ยง5โยง6", "PDP-0001 ยง3.1, ยง4.4"],
			  "code": [
				"def validate_envelope_and_origin(packet, feature_flags, agent_registry, trusted_root):",
				"    if feature_flags.enable_exchange_envelope and 'Sigma_phase' not in packet: return {'status':'rejected','reason':'E.MMM.flag.missing_sigma'}",
				"    if feature_flags.enable_integrity_checks and 'Delta_hash' not in packet: return {'status':'rejected','reason':'E.MMM.flag.missing_delta'}",
				"    prov = packet.get('provenance', {})",
				"    if prov.get('origin') not in trusted_root: return {'status':'rejected','reason':'E.MMM.origin.unrecognized'}",
				"    if 'origin_hash' in prov and H(prov.get('origin_fields')) != prov['origin_hash']:",
				"        return {'status':'rejected','reason':'E.MMM.origin.hash_mismatch'}",
				"    agent_id = prov.get('agent_id')",
				"    allowed = set(agent_registry.get(agent_id, {}).get('allowed_sig_types', []))",
				"    sig_type = packet.get('envelope', {}).get('sig_type')",
				"    if sig_type not in allowed: return {'status':'rejected','reason':'E.MMM.policy.illegal_sig_type'}",
				"    return {'status':'accepted','reason':'structurally_valid'}"
			  ]
			},
			{
			  "title": "reject_wrapped_unsigned (confused-deputy defense)",
			  "anchors": ["reject_wrapped_unsigned"],
			  "rfc_anchors": ["RFC-0008 ยง5โยง6"],
			  "code": [
				"def reject_wrapped_unsigned(packet):",
				"    env = packet.get('envelope', {})",
				"    claims_signed = bool(env.get('claims_signed'))",
				"    sig_block = packet.get('signature_block')",
				"    if claims_signed and (sig_block is None or sig_block == '' or sig_block == 'stub'):",
				"        return {'status':'rejected','reason':'E.MMM.policy.wrapped_unsigned'}",
				"    return {'status':'noop'}"
			  ]
			},
			{
			  "title": "enforce_retention_policy (at-rest)",
			  "anchors": ["enforce_retention_policy"],
			  "rfc_anchors": ["RFC-0005 ยง4.2", "RFC-0009 Appx D.4"],
			  "code": [
				"def enforce_retention_policy(bundle, tau_decay, now_tick):",
				"    prof = bundle.setdefault('storage_profile', {})",
				"    if prof.get('profile') not in {'volatile','durable'}: return {'status':'rejected','reason':'E.MMM.policy.invalid_storage_profile'}",
				"    prof['retention_ticks'] = max(int(prof.get('retention_ticks', 0)), int(tau_decay))",
				"    expiry = bundle.get('timestamp', 0) + prof['retention_ticks']",
				"    return {'status':'expire' if now_tick > expiry else 'retain'}"
			  ]
			}
		  ],
		  "examples": [
			{
			  "title": "wrapped_unsigned_rejection",
			  "input": {
				"packet": {
				  "envelope": { "claims_signed": true, "sig_type": "rsa_pss" },
				  "signature_block": null,
				  "provenance": { "origin": "node:A", "agent_id": "agent:A", "origin_fields": {"id":"A"}, "origin_hash": "H({id:A})" }
				},
				"feature_flags": { "enable_exchange_envelope": true, "enable_integrity_checks": true },
				"agent_registry": { "agent:A": { "allowed_sig_types": ["rsa_pss","eddsa"] } },
				"trusted_root_registry": ["node:A"]
			  },
			  "output": { "status": "rejected", "reason": "E.MMM.policy.wrapped_unsigned" },
			  "notes": "Confused-deputy defense: structural claim of signing without a signature block is rejected at Layer_1."
			},
			{
			  "title": "illegal_signature_type",
			  "input": {
				"packet": {
				  "envelope": { "claims_signed": true, "sig_type": "es256k" },
				  "signature_block": "stub", 
				  "provenance": { "origin": "node:B", "agent_id": "agent:B", "origin_fields": {"id":"B"}, "origin_hash": "H({id:B})" }
				},
				"feature_flags": { "enable_exchange_envelope": true, "enable_integrity_checks": false },
				"agent_registry": { "agent:B": { "allowed_sig_types": ["rsa_pss"] } },
				"trusted_root_registry": ["node:B"]
			  },
			  "output": { "status": "rejected", "reason": "E.MMM.policy.illegal_sig_type" },
			  "notes": "Layer_1 checks only the declared sig_type membership in the local profile; cryptographic proof is deferred to Layer_2."
			},
			{
			  "title": "retention_floor_enforced",
			  "input": {
				"bundle": { "timestamp": 1000, "storage_profile": { "profile": "durable", "retention_ticks": 50 } },
				"tau_decay": 120,
				"now_tick": 1105
			  },
			  "output": { "status": "retain" },
			  "notes": "Retention floor set to tau_decay; bundle will expire at t=1120."
			}
		  ]
		}
	},

    "5": {
      "id": "5",
	  "title": "Observability, Ethics, and Policy",
		{
		  "id": "5.1",
		  "title": "Observability and Metrics",
		  "description": "Defines the WHAT for MMM observability: inputs, outputs, lifecycle, testable requirements, error model, and KPI catalog for measuring coherence, resonance, capacity, decay ethics, recovery activity, exchange timing, and (flag-gated) glider flow. Layer_1 remains observer-only; sealing fields are emitted strictly under feature flags.",
		  "rfc_anchors": [
			"PDP-0001 ยง4.4โยง4.5",
			"RFC-0005 ยง3โยง4",
			"RFC-0006 ยง3โยง4",
			"RFC-0008 ยง2โยง3; ยง5.3",
			"RFC-0009 ยง7.1โยง9.3; Appx D.4"
		  ],
		  "interfaces": {
			"inputs": [
			  {
				"name": "trace_entries_window",
				"type": "list<TraceEntry>",
				"constraints": "Bounded by chosen EMA window; entries expose {C, rho_res, event, idle_time, timestamp}.",
				"notes": "Source of coherence/resonance/health signals; observer-only."
			  },
			  {
				"name": "stmm_ltmm_events",
				"type": "list<Event>",
				"constraints": "Events in {'promote','reanchor_attempt','reanchor_fail','quarantine_entry'}.",
				"notes": "Used to compute rates and recovery gauges."
			  },
			  {
				"name": "capacity",
				"type": "object",
				"constraints": "Contains {C_max: >0, LTMM_usage: >=0}.",
				"notes": "Feeds saturation_level = LTMM_usage / C_max."
			  },
			  {
				"name": "replay_params",
				"type": "object",
				"constraints": "Contains {Delta_tau_phase: >=0} or enough to derive it.",
				"notes": "Defines adaptive acceptance window for exchange timing KPIs."
			  },
			  {
				"name": "feature_flags",
				"type": "object",
				"constraints": "Booleans {enable_exchange_envelope, enable_integrity_checks, enable_provenance_on_export, enable_point_space_gliders}.",
				"notes": "Strict gating for checksum and glider gauges."
			  },
			  {
				"name": "provenance",
				"type": "object",
				"constraints": "ASCII keys; structure per PDP-0001.",
				"notes": "Included only when exporting metrics with provenance enabled."
			  }
			],
			"outputs": [
			  {
				"name": "metrics_snapshot",
				"type": "object",
				"constraints": "ASCII keys; values within declared ranges; windows limited to {EMA-16, EMA-32, EMA-64}.",
				"notes": "Point-in-time rollup suitable for dashboards."
			  },
			  {
				"name": "metrics_packet",
				"type": "object",
				"constraints": "Present only when export is requested; includes optional Sigma_phase and Delta_hash per flags.",
				"notes": "Observer envelope for SRX routing; no control writes."
			  }
			],
			"side_effects": [
			  "observer-only"
			]
		  },
		  "state_lifecycle": {
			"states": [
			  "observing",
			  "rolling_up",
			  "sealed_ready",
			  "exported"
			],
			"transitions": [
			  {
				"from": "observing",
				"to": "rolling_up",
				"on": "tick",
				"guard": "trace_entries_window not empty",
				"notes": "Roll up means/rates within EMA windows."
			  },
			  {
				"from": "rolling_up",
				"to": "sealed_ready",
				"on": "snapshot_computed",
				"guard": "ASCII key validation passes AND feature gating checks pass",
				"notes": "No Sigma_phase/Delta_hash unless enabled."
			  },
			  {
				"from": "sealed_ready",
				"to": "exported",
				"on": "export_requested",
				"guard": "If enable_exchange_envelope=true then include Sigma_phase; if enable_integrity_checks=true then include Delta_hash; otherwise omit.",
				"notes": "Any rate limiting/backoff is enforced in Layer_2."
			  },
			  {
				"from": "sealed_ready",
				"to": "observing",
				"on": "no_export",
				"guard": "n/a",
				"notes": "Keep local snapshot and continue."
			  }
			]
		  },
		  "requirements": [
			{
			  "level": "MUST",
			  "text": "Operate in observer-only posture: measurement, sealing, and routing only; no control writes.",
			  "anchor": "PDP-0001 ยง4.5"
			},
			{
			  "level": "MUST",
			  "text": "Emit metrics using EMA windows limited to {EMA-16, EMA-32, EMA-64}. Means default to EMA-64; rates default to EMA-32 unless stated.",
			  "anchor": "RFC-0009 ยง7.1โยง7.3"
			},
			{
			  "level": "MUST",
			  "text": "Compute lawful_compression_ratio and equivalence_efficiency strictly before any prune recommendation.",
			  "anchor": "RFC-0006 ยง4; RFC-0009 ยง7"
			},
			{
			  "level": "MUST",
			  "text": "Honor ethical TTL floor in all retention KPIs: TTL_floor = max(tau_decay, 10 * delta_t_tick).",
			  "anchor": "RFC-0005 ยง4; RFC-0009 ยง7"
			},
			{
			  "level": "MUST",
			  "text": "Gate Sigma_phase on enable_exchange_envelope and Delta_hash on enable_integrity_checks. Do not emit stub fields when disabled.",
			  "anchor": "RFC-0008 ยง5.3; RFC-0009 Appx D.4"
			},
			{
			  "level": "MUST",
			  "text": "Emit glider-related gauges only when enable_point_space_gliders=true.",
			  "anchor": "RFC-0006 ยง3โยง4"
			},
			{
			  "level": "MUST",
			  "text": "Use ASCII keys for all exported objects; Unicode is allowed only inside free-text values.",
			  "anchor": "PDP-0001 ยง4.4"
			},
			{
			  "level": "SHOULD",
			  "text": "Derive avg_replay_window_ticks from Delta_tau_phase and report it for exchange timing diagnostics.",
			  "anchor": "RFC-0008 ยง2โยง3"
			},
			{
			  "level": "SHOULD",
			  "text": "Annotate each metric with unit and EMA window and keep ranges within declared bounds.",
			  "anchor": "RFC-0009 ยง7.2"
			},
			{
			  "level": "MAY",
			  "text": "Include provenance.origin_hash in metrics_packet when enable_provenance_on_export=true.",
			  "anchor": "PDP-0001 ยง4.4"
			}
		  ],
		  "error_model": [
			{
			  "code": "E.MMM.ASCII.001",
			  "when": "Non-ASCII key detected in metrics_snapshot or metrics_packet.",
			  "message": "ASCII-only keys required at Layer_1.",
			  "remedy": "Normalize keys to ASCII or drop offending fields."
			},
			{
			  "code": "E.MMM.WINDOW.002",
			  "when": "Metric computed with a window not in {EMA-16, EMA-32, EMA-64}.",
			  "message": "Invalid EMA window.",
			  "remedy": "Recompute using an allowed window."
			},
			{
			  "code": "E.MMM.GATE.003",
			  "when": "Checksum fields emitted while corresponding flags are disabled.",
			  "message": "Checksum gating violation.",
			  "remedy": "Remove Sigma_phase/Delta_hash or enable flags explicitly."
			},
			{
			  "code": "E.MMM.GLIDER.004",
			  "when": "Glider gauges emitted but glider feature flag is disabled.",
			  "message": "Glider gauge gating violation.",
			  "remedy": "Disable glider gauges or enable feature flag."
			},
			{
			  "code": "E.MMM.REQ.005",
			  "when": "Required KPI (compression or TTL floor) omitted from snapshot.",
			  "message": "Missing required KPI.",
			  "remedy": "Compute lawful_compression_ratio, equivalence_efficiency, and TTL floor metrics before export."
			},
			{
			  "code": "E.MMM.EXPORT.006",
			  "when": "Export attempted without a sealed_ready snapshot.",
			  "message": "Export precondition not met.",
			  "remedy": "Produce a valid snapshot and reattempt export."
			}
		  ],
		  "metrics": [
			{ "name": "rfc0009_Q_coh", "unit": "dimensionless", "window": "EMA-64", "notes": "Mean coherence level C; range [0,1]." },
			{ "name": "rfc0009_Q_res", "unit": "dimensionless", "window": "EMA-64", "notes": "Mean resonance coefficient rho_res; range [0,1]." },
			{ "name": "rho_res_band_share", "unit": "fraction", "window": "EMA-32", "notes": "Share of entries with rho_res in [0.3,0.7]; range [0,1]." },
			{ "name": "lawful_compression_ratio", "unit": "dimensionless", "window": "EMA-32", "notes": "post_equiv_count / pre_equiv_count; pre-prune only; range [0,1]." },
			{ "name": "equivalence_efficiency", "unit": "fraction", "window": "EMA-32", "notes": "(pre - post) / pre; pre-prune only; range [0,1]." },
			{ "name": "ethical_ttl_floor", "unit": "ticks", "window": "EMA-16", "notes": "TTL_floor = max(tau_decay, 10*delta_t_tick); range [0,+inf)." },
			{ "name": "ttl_max_effective", "unit": "ticks", "window": "EMA-16", "notes": "Configured maximum retention horizon; range [0,+inf)." },
			{ "name": "staleness_index", "unit": "fraction", "window": "EMA-32", "notes": "Share nearing decay by idle_time; range [0,1]." },
			{ "name": "saturation_level", "unit": "fraction", "window": "EMA-32", "notes": "LTMM_usage / C_max; range [0,1]." },
			{ "name": "memory_promotion_rate", "unit": "events/tick", "window": "EMA-32", "notes": "STMMโLTMM promotions per tick; range [0,1]." },
			{ "name": "reanchor_rate", "unit": "events/tick", "window": "EMA-32", "notes": "Rate of reanchor_attempt events; range [0,1]." },
			{ "name": "reanchor_fail_rate", "unit": "events/tick", "window": "EMA-32", "notes": "Rate of reanchor_fail events; range [0,1]." },
			{ "name": "quarantine_entry_rate", "unit": "events/tick", "window": "EMA-32", "notes": "Rate of quarantine_entry events; range [0,1]." },
			{ "name": "quarantine_count", "unit": "sets", "window": "EMA-32", "notes": "Number of motif sets currently quarantined; range [0,+inf)." },
			{ "name": "avg_replay_window_ticks", "unit": "ticks", "window": "EMA-32", "notes": "Observed average Delta_tau_phase; range [0,+inf)." },
			{ "name": "gamma_co", "unit": "1/tick", "window": "EMA-64", "notes": "Adaptive damping estimate from coherence law; range [0,+inf)." },
			{ "name": "glider_detected", "unit": "count", "window": "EMA-16", "notes": "Flag-gated; count of glider detection events." },
			{ "name": "glider_canonical_count", "unit": "count", "window": "EMA-16", "notes": "Flag-gated; number of canonical glider representatives." }
		  ],
		  "pseudocode": [
			{
			  "title": "Compute Compression KPIs (pre-prune snapshot)",
			  "anchors": ["compute_compression_kpis"],
			  "rfc_anchors": ["RFC-0006 ยง4", "RFC-0009 ยง7"],
			  "code": [
				"def compute_compression_kpis(pre_equiv_count, post_equiv_count):",
				"    if pre_equiv_count <= 0:",
				"        return {'lawful_compression_ratio': 1.0, 'equivalence_efficiency': 0.0}",
				"    lcr = post_equiv_count / pre_equiv_count",
				"    ee  = (pre_equiv_count - post_equiv_count) / pre_equiv_count",
				"    return {'lawful_compression_ratio': lcr, 'equivalence_efficiency': ee}"
			  ]
			},
			{
			  "title": "Roll Up Observability Window",
			  "anchors": ["rollup_observability_window"],
			  "rfc_anchors": ["RFC-0008 ยง2โยง3", "RFC-0009 ยง7.1โยง7.3"],
			  "code": [
				"def rollup_observability_window(entries, events, capacity, flags, Delta_tau_phase):",
				"    Q_coh = EMA64(mean(e.C for e in entries))",
				"    Q_res = EMA64(mean(e.rho_res for e in entries))",
				"    band  = EMA32(frac(e for e in entries if 0.3 <= e.rho_res <= 0.7))",
				"    eta   = EMA32(capacity.LTMM_usage / capacity.C_max)",
				"    pr    = EMA32(rate(events, kind='promote'))",
				"    rr    = EMA32(rate(events, kind='reanchor_attempt'))",
				"    rrf   = EMA32(rate(events, kind='reanchor_fail'))",
				"    qer   = EMA32(rate(events, kind='quarantine_entry'))",
				"    qc    = EMA32(current_quarantine_sets())",
				"    avg_rw= EMA32(Delta_tau_phase)",
				"    gauges = {'rfc0009_Q_coh':Q_coh,'rfc0009_Q_res':Q_res,'rho_res_band_share':band,'saturation_level':eta,",
				"              'memory_promotion_rate':pr,'reanchor_rate':rr,'reanchor_fail_rate':rrf,",
				"              'quarantine_entry_rate':qer,'quarantine_count':qc,'avg_replay_window_ticks':avg_rw}",
				"    if flags.enable_point_space_gliders:",
				"        gauges.update({'glider_detected': EMA16(rate(events,'glider_detected')),",
				"                       'glider_canonical_count': EMA16(size(glider_index()))})",
				"    return gauges"
			  ]
			}
		  ],
		  "examples": [
			{
			  "title": "Snapshot and Export (flags ON)",
			  "input": {
				"trace_entries_window": "[...]",
				"stmm_ltmm_events": "[promote, reanchor_attempt, reanchor_fail, quarantine_entry]",
				"capacity": {"C_max": 1000, "LTMM_usage": 700},
				"replay_params": {"Delta_tau_phase": 16},
				"feature_flags": {
				  "enable_exchange_envelope": true,
				  "enable_integrity_checks": true,
				  "enable_provenance_on_export": true,
				  "enable_point_space_gliders": true
				},
				"provenance": {"origin": "observer.MMM", "session": "abc123"}
			  },
			  "output": {
				"metrics_snapshot": {
				  "rfc0009_Q_coh": 0.62,
				  "rfc0009_Q_res": 0.55,
				  "rho_res_band_share": 0.60,
				  "lawful_compression_ratio": 0.80,
				  "equivalence_efficiency": 0.20,
				  "ethical_ttl_floor": 100,
				  "ttl_max_effective": 1000,
				  "staleness_index": 0.12,
				  "saturation_level": 0.70,
				  "memory_promotion_rate": 0.03,
				  "reanchor_rate": 0.01,
				  "reanchor_fail_rate": 0.002,
				  "quarantine_entry_rate": 0.001,
				  "quarantine_count": 2,
				  "avg_replay_window_ticks": 16,
				  "gamma_co": 0.05,
				  "glider_detected": 3,
				  "glider_canonical_count": 1
				},
				"metrics_packet": {
				  "kind": "metrics",
				  "version": "2025-Q4",
				  "body": "{metrics_snapshot}",
				  "provenance": {"origin": "observer.MMM", "origin_hash": "H(...)"},
				  "Sigma_phase": "phase_checksum(...)",
				  "Delta_hash": "hash_lineage(...)"
				}
			  },
			  "notes": "Checksum and glider gauges present because all flags are enabled."
			},
			{
			  "title": "Snapshot Only (flags OFF)",
			  "input": {
				"trace_entries_window": "[...]",
				"stmm_ltmm_events": "[promote]",
				"capacity": {"C_max": 1000, "LTMM_usage": 300},
				"replay_params": {"Delta_tau_phase": 8},
				"feature_flags": {
				  "enable_exchange_envelope": false,
				  "enable_integrity_checks": false,
				  "enable_provenance_on_export": false,
				  "enable_point_space_gliders": false
				}
			  },
			  "output": {
				"metrics_snapshot": {
				  "rfc0009_Q_coh": 0.71,
				  "rfc0009_Q_res": 0.66,
				  "rho_res_band_share": 0.64,
				  "lawful_compression_ratio": 0.90,
				  "equivalence_efficiency": 0.10,
				  "ethical_ttl_floor": 100,
				  "ttl_max_effective": 1000,
				  "staleness_index": 0.05,
				  "saturation_level": 0.30,
				  "memory_promotion_rate": 0.02,
				  "reanchor_rate": 0.00,
				  "reanchor_fail_rate": 0.00,
				  "quarantine_entry_rate": 0.00,
				  "quarantine_count": 0,
				  "avg_replay_window_ticks": 8,
				  "gamma_co": 0.04
				}
			  },
			  "notes": "No Sigma_phase, no Delta_hash, and no glider gauges because flags are disabled."
			}
		  ]
		},
		{
		  "id": "5.2",
		  "title": "Ethics and Data Retention Policy",
		  "description": "Defines the WHAT for ethical retention in MMM: observer-only posture, decay-as-forgetting (not deletion), TTL floor contracts, provenance-and-lineage validation for resurrection, and sealed export fields gated strictly by feature flags.",
		  "rfc_anchors": [
			"PDP-0001 ยง4.4โยง4.5",
			"RFC-0005 ยง3โยง4.2",
			"RFC-0007 ยง5โยง6; ยง8",
			"RFC-0008 ยง5.3",
			"RFC-0009 ยง7; Appx D.4"
		  ],
		  "interfaces": {
			"inputs": [
			  {
				"name": "bundle",
				"type": "object",
				"constraints": "Contains {storage_profile:{retention_ticks>=0}, timestamp}. ASCII keys.",
				"notes": "Observed metadata only; no writes by this section."
			  },
			  {
				"name": "now_tick",
				"type": "integer",
				"constraints": "now_tick>=0",
				"notes": "Current scheduler tick for retention evaluation."
			  },
			  {
				"name": "tau_decay",
				"type": "integer",
				"constraints": "tau_decay>=0",
				"notes": "Decay horizon derived upstream from signals; used as ethical baseline."
			  },
			  {
				"name": "delta_t_tick",
				"type": "integer",
				"constraints": "delta_t_tick>0",
				"notes": "System tick interval used in TTL floor bound."
			  },
			  {
				"name": "feature_flags",
				"type": "object",
				"constraints": "Booleans {enable_exchange_envelope, enable_integrity_checks, enable_provenance_on_export}.",
				"notes": "Strict gating for sealed export fields."
			  },
			  {
				"name": "resurrection_request",
				"type": "object",
				"constraints": "If present, includes {provenance:{origin,origin_hash?,created_at}, lineage:{parent_hash?,integrity_hash?,schema}}.",
				"notes": "Validated prior to any acceptance."
			  },
			  {
				"name": "parent_Delta_hash",
				"type": "string",
				"constraints": "ASCII; optional unless integrity checks enabled.",
				"notes": "Expected chain head when validating resurrection lineage."
			  },
			  {
				"name": "payload_for_export",
				"type": "object",
				"constraints": "ASCII keys; metrics or bundles to seal structurally.",
				"notes": "Used only when an export is requested."
			  },
			  {
				"name": "provenance",
				"type": "object",
				"constraints": "ASCII keys; structure per PDP-0001.",
				"notes": "Included on export when provenance feature is enabled."
			  },
			  {
				"name": "T_mu",
				"type": "integer",
				"constraints": "T_mu>=0",
				"notes": "Phase epoch for checksum when exchange envelope is enabled."
			  },
			  {
				"name": "last_Delta_hash",
				"type": "string",
				"constraints": "ASCII; optional unless integrity checks enabled.",
				"notes": "Lineage tail for chained integrity hashing."
			  }
			],
			"outputs": [
			  {
				"name": "policy_decision",
				"type": "object",
				"constraints": "ASCII keys; actionโ{'retain','expire'}; includes {retention_ticks_effective, reasons[]}.",
				"notes": "Observer-only result for downstream enforcement in Layer_2."
			  },
			  {
				"name": "resurrection_status",
				"type": "object",
				"constraints": "statusโ{'accepted','rejected'}; reasons[] if rejected.",
				"notes": "Outcome of provenance/lineage validation."
			  },
			  {
				"name": "export_packet",
				"type": "object",
				"constraints": "Present only when export requested; includes {body, provenance?} and flag-gated {Sigma_phase?, Delta_hash?}.",
				"notes": "Sealed structurally; no cryptographic claims at Layer_1."
			  }
			],
			"side_effects": [
			  "observer-only"
			]
		  },
		  "state_lifecycle": {
			"states": [
			  "idle",
			  "evaluating_retention",
			  "validating_resurrection",
			  "sealing_export"
			],
			"transitions": [
			  {
				"from": "idle",
				"to": "evaluating_retention",
				"on": "tick",
				"guard": "bundle present",
				"notes": "Compute effective TTL floor and decision."
			  },
			  {
				"from": "evaluating_retention",
				"to": "validating_resurrection",
				"on": "resurrection_request_present",
				"guard": "n/a",
				"notes": "Validate provenance and lineage consecutively."
			  },
			  {
				"from": "validating_resurrection",
				"to": "sealing_export",
				"on": "export_requested",
				"guard": "If flags enabled, attach gated fields; otherwise omit.",
				"notes": "Sealing is structural; routing is handled later."
			  },
			  {
				"from": "sealing_export",
				"to": "idle",
				"on": "done",
				"guard": "n/a",
				"notes": "Observer loop continues."
			  }
			]
		  },
		  "requirements": [
			{
			  "level": "MUST",
			  "text": "Maintain observer-only posture: measurement, staging, sealing, and routing only; no control writes.",
			  "anchor": "PDP-0001 ยง4.5"
			},
			{
			  "level": "MUST",
			  "text": "Apply ethical TTL floor: retention_ticks_effective = max(tau_decay, 10 * delta_t_tick) when evaluating expiry.",
			  "anchor": "RFC-0005 ยง4.2; RFC-0009 ยง7"
			},
			{
			  "level": "MUST",
			  "text": "Prefer decay-as-forgetting over deletion: expiry decisions are time-based and reversible only via lawful resurrection.",
			  "anchor": "RFC-0005 ยง3โยง4"
			},
			{
			  "level": "MUST",
			  "text": "Accept resurrection only with validated provenance and continuous lineage; when enable_integrity_checks=true, require Delta_hash chain continuity and parent match.",
			  "anchor": "RFC-0007 ยง5โยง6; RFC-0009 Appx D.4"
			},
			{
			  "level": "MUST",
			  "text": "Emit Sigma_phase only when enable_exchange_envelope=true and Delta_hash only when enable_integrity_checks=true; never emit stub fields when disabled.",
			  "anchor": "RFC-0008 ยง5.3; RFC-0009 Appx D.4"
			},
			{
			  "level": "MUST",
			  "text": "Use ASCII keys in all outputs and sealed packets; Unicode allowed only within free-text values.",
			  "anchor": "PDP-0001 ยง4.4"
			},
			{
			  "level": "SHOULD",
			  "text": "Include provenance.origin_hash in export_packet when enable_provenance_on_export=true.",
			  "anchor": "PDP-0001 ยง4.4"
			},
			{
			  "level": "SHOULD",
			  "text": "Reject resurrection if ontology DAG constraints or references are invalid or cyclic.",
			  "anchor": "RFC-0007 ยง8"
			}
		  ],
		  "error_model": [
			{
			  "code": "E.MMM.ASCII.001",
			  "when": "Non-ASCII key detected in outputs or export_packet.",
			  "message": "ASCII-only keys required at Layer_1.",
			  "remedy": "Normalize keys to ASCII or drop offending fields."
			},
			{
			  "code": "E.MMM.TTL.101",
			  "when": "Retention evaluated below ethical floor.",
			  "message": "TTL floor violation.",
			  "remedy": "Recompute retention_ticks_effective = max(tau_decay, 10 * delta_t_tick)."
			},
			{
			  "code": "E.MMM.LINEAGE.201",
			  "when": "Resurrection request missing provenance or lineage fields.",
			  "message": "Incomplete resurrection metadata.",
			  "remedy": "Provide required provenance and lineage per RFC-0007 and retry."
			},
			{
			  "code": "E.MMM.LINEAGE.202",
			  "when": "Computed integrity_hash does not match submitted lineage.integrity_hash.",
			  "message": "Integrity mismatch.",
			  "remedy": "Correct the payload or lineage record; revalidate."
			},
			{
			  "code": "E.MMM.LINEAGE.203",
			  "when": "parent_hash does not match parent_Delta_hash when integrity checks enabled.",
			  "message": "Lineage parent mismatch.",
			  "remedy": "Repair chain or disable integrity checks (not recommended)."
			},
			{
			  "code": "E.MMM.LINEAGE.204",
			  "when": "Ontology references are cyclic or point to unknown motifs.",
			  "message": "Ontology DAG invalid.",
			  "remedy": "Fix references to satisfy RFC-0007 DAG constraints."
			},
			{
			  "code": "E.MMM.GATE.003",
			  "when": "Checksum fields emitted while the corresponding flags are disabled.",
			  "message": "Checksum gating violation.",
			  "remedy": "Remove gated fields or enable features explicitly."
			},
			{
			  "code": "E.MMM.OBSV.401",
			  "when": "A control write is attempted by this section.",
			  "message": "Observer-only violation.",
			  "remedy": "Route any writes to Layer_2 components; keep Layer_1 read/validate/seal only."
			},
			{
			  "code": "E.MMM.PROV.402",
			  "when": "Export attempted with enable_provenance_on_export=true but provenance missing required fields.",
			  "message": "Export provenance insufficient.",
			  "remedy": "Attach provenance per PDP-0001 or disable feature flag."
			}
		  ],
		  "metrics": [
			{ "name": "retention_expirations", "unit": "events/tick", "window": "EMA-32", "notes": "Rate of bundles expired by ethical policy." },
			{ "name": "resurrection_rejects_lineage", "unit": "events/tick", "window": "EMA-32", "notes": "Rejections due to missing/invalid provenance or lineage." },
			{ "name": "ttl_policy_violations", "unit": "events/tick", "window": "EMA-16", "notes": "Attempts to set retention below ethical TTL floor." },
			{ "name": "observer_write_attempts", "unit": "events/tick", "window": "EMA-16", "notes": "Incidents where a control write was attempted by observer components (should be zero)." }
		  ],
		  "pseudocode": [
			{
			  "title": "Evaluate Ethical Retention (observer-only)",
			  "anchors": ["evaluate_retention_policy"],
			  "rfc_anchors": ["RFC-0005 ยง4.2", "RFC-0009 ยง7"],
			  "code": [
				"def evaluate_retention_policy(bundle, now_tick, tau_decay, delta_t_tick):",
				"    ttl_floor = max(tau_decay, 10 * delta_t_tick)",
				"    r_eff = max(bundle.storage_profile.retention_ticks, ttl_floor)",
				"    will_expire = (bundle.timestamp + r_eff) < now_tick",
				"    action = 'expire' if will_expire else 'retain'",
				"    reasons = []",
				"    if r_eff > bundle.storage_profile.retention_ticks:",
				"        reasons.append('ttl_floor_applied')",
				"    return {'action': action, 'retention_ticks_effective': r_eff, 'reasons': reasons}"
			  ]
			},
			{
			  "title": "Validate Resurrection Lineage",
			  "anchors": ["validate_resurrection_lineage"],
			  "rfc_anchors": ["RFC-0007 ยง5โยง6; ยง8", "RFC-0009 Appx D.4"],
			  "code": [
				"def validate_resurrection_lineage(req, flags, parent_Delta_hash):",
				"    need = ('provenance' in req and 'lineage' in req)",
				"    if not need: return {'status':'rejected','reasons':['missing_fields']}",
				"    ok_hash = (H(req['meta_and_data']) == req['lineage'].get('integrity_hash'))",
				"    if not ok_hash: return {'status':'rejected','reasons':['integrity_mismatch']}",
				"    if flags.enable_integrity_checks:",
				"        if req['lineage'].get('parent_hash') != parent_Delta_hash:",
				"            return {'status':'rejected','reasons':['parent_mismatch']}",
				"    if not ontology_dag_valid(req):",
				"        return {'status':'rejected','reasons':['ontology_dag_invalid']}",
				"    return {'status':'accepted'}"
			  ]
			},
			{
			  "title": "Seal Export Ethically (flag-gated)",
			  "anchors": ["seal_export_ethically"],
			  "rfc_anchors": ["RFC-0008 ยง5.3", "PDP-0001 ยง4.4"],
			  "code": [
				"def seal_export_ethically(payload, provenance, last_Delta_hash, T_mu, flags):",
				"    packet = {'body': payload}",
				"    if flags.enable_provenance_on_export:",
				"        packet['provenance'] = dict(provenance)",
				"        packet['provenance']['origin_hash'] = H(provenance)",
				"    if flags.enable_exchange_envelope:",
				"        packet['Sigma_phase'] = phase_checksum(packet['body'], T_mu)",
				"    if flags.enable_integrity_checks:",
				"        packet['Delta_hash'] = hash_lineage(packet['body'], last_Delta_hash)",
				"    return packet"
			  ]
			}
		  ],
		  "examples": [
			{
			  "title": "Retention decision with TTL floor applied",
			  "input": {
				"bundle": { "storage_profile": { "retention_ticks": 8 }, "timestamp": 1000 },
				"now_tick": 1115,
				"tau_decay": 12,
				"delta_t_tick": 1
			  },
			  "output": {
				"policy_decision": { "action": "expire", "retention_ticks_effective": 12, "reasons": ["ttl_floor_applied"] }
			  },
			  "notes": "TTL floor max(12,10) = 12; timestamp+12=1012 < now_tick โ expire."
			},
			{
			  "title": "Resurrection rejected due to lineage mismatch",
			  "input": {
				"resurrection_request": {
				  "provenance": { "origin": "observer.MMM", "created_at": "2025-10-13T00:00:00Z" },
				  "lineage": { "parent_hash": "abc", "integrity_hash": "bad" },
				  "meta_and_data": "{...}"
				},
				"feature_flags": { "enable_integrity_checks": true },
				"parent_Delta_hash": "xyz"
			  },
			  "output": {
				"resurrection_status": { "status": "rejected", "reasons": ["integrity_mismatch", "parent_mismatch"] }
			  },
			  "notes": "Hash mismatch and parent mismatch both detected when integrity checks are enabled."
			},
			{
			  "title": "Export sealed with gated fields",
			  "input": {
				"payload_for_export": { "kind": "metrics", "version": "2025-Q4", "body": "{...}" },
				"provenance": { "origin": "observer.MMM", "session": "s1" },
				"last_Delta_hash": "p123",
				"T_mu": 4096,
				"feature_flags": {
				  "enable_exchange_envelope": true,
				  "enable_integrity_checks": true,
				  "enable_provenance_on_export": true
				}
			  },
			  "output": {
				"export_packet": {
				  "body": { "kind": "metrics", "version": "2025-Q4", "body": "{...}" },
				  "provenance": { "origin": "observer.MMM", "session": "s1", "origin_hash": "H(...)" },
				  "Sigma_phase": "phase_checksum(...)",
				  "Delta_hash": "hash_lineage(...)"
				}
			  },
			  "notes": "All gated fields emitted because corresponding flags are true."
			}
		  ]
		}
    },

    "appendix": {
	 {
	  "appendix": "A",
	  "title": "Worked Examples & Mathematical Supplement",
	  "objective": "Provide lintable, Layer_1โconformant worked examples that instantiate MMM contracts (capacity-first ordering, equivalence compression, replay defense, lineage validation, bounded recovery) with ASCII-only keys on-wire. Math identities are referenced, not proved.",
	  "schema": {
		"appendix_types": ["diagrammatic", "worked_example", "reference_table", "pseudocode_index"],
		"common_keys": ["id", "title", "type", "objective", "rfc_anchors", "feature_flags?", "notes?"],
		"worked_example_keys": ["algorithms", "invariants", "example_json", "telemetry", "bindings?"],
		"diagrammatic_keys": ["diagram_format", "diagram"],
		"reference_table_keys": ["schema_version", "data", "validation_rules"],
		"pseudocode_index_keys": ["blocks"]
	  },
	  "sections": [
		{
		  "id": "A.0",
		  "title": "Conventions, Lint, and Feature Flags",
		  "type": "reference_table",
		  "objective": "Establish appendix-wide rules (ASCII keys, EMA windows, flag gating) and the JSON lint checks used by fixtures.",
		  "data": {
			"ascii_keys_only": true,
			"allowed_windows": ["EMA-16", "EMA-32", "EMA-64"],
			"flag_rules": {
			  "enable_exchange_envelope": "controls presence of Sigma_phase",
			  "enable_integrity_checks": "controls presence of Delta_hash",
			  "enable_point_space_gliders": "controls presence of {class,v,phi,tau} glider fields"
			}
		  },
		  "validation_rules": [
			"no unicode outside 'latex' strings",
			"metrics.window โ {EMA-16,EMA-32,EMA-64}",
			"flag-gated fields appear iff enabled"
		  ],
		  "lint": {
			"checks": [
			  {
				"id": "LINT.ASCII_KEYS",
				"description": "All JSON object keys must be ASCII.",
				"selector": "$..*",
				"test": "for each object: all(keys.match(/^[\\x00-\\x7F]+$/))",
				"on_fail": "reject fixture; emit ascii_key_normalization_events metric once per response"
			  },
			  {
				"id": "LINT.LATEX_ONLY_UNICODE",
				"description": "Unicode characters allowed only inside values of fields named 'latex'.",
				"selector": "$..*",
				"test": "for each string value v: if field_name!='latex' then v.match(/^[\\x00-\\x7F]*$/)",
				"on_fail": "reject fixture; annotate path"
			  },
			  {
				"id": "LINT.METRIC_WINDOW_SET",
				"description": "Metric windows must be in the allowed set.",
				"selector": "$..metrics[*].window,$..telemetry[*].window,$..bindings[*].window",
				"test": "value โ {'EMA-16','EMA-32','EMA-64'}",
				"on_fail": "reject metric; suggest nearest allowed window"
			  },
			  {
				"id": "LINT.FLAG_GATING_EXCHANGE",
				"description": "Sigma_phase must exist only when enable_exchange_envelope=true.",
				"selector": "$..*",
				"test": "if payload has Sigma_phase then feature_flags.enable_exchange_envelope===true",
				"on_fail": "reject payload; remove Sigma_phase or enable flag"
			  },
			  {
				"id": "LINT.FLAG_GATING_INTEGRITY",
				"description": "Delta_hash must exist only when enable_integrity_checks=true.",
				"selector": "$..*",
				"test": "if payload has Delta_hash then feature_flags.enable_integrity_checks===true",
				"on_fail": "reject payload; remove Delta_hash or enable flag"
			  },
			  {
				"id": "LINT.FLAG_GATING_GLIDERS",
				"description": "Glider fields {class,v,phi,tau} must exist only when enable_point_space_gliders=true.",
				"selector": "$..*",
				"test": "if any of {class,v,phi,tau} present then feature_flags.enable_point_space_gliders===true",
				"on_fail": "reject payload; strip glider fields or enable flag"
			  }
			],
			"suggested_metrics": [
			  { "name": "ascii_key_normalization_events", "unit": "count", "window": "EMA-32", "notes": "Emit once per response when any key required normalization." },
			  { "name": "appendix_fixture_lint_failures", "unit": "count", "window": "EMA-32", "notes": "Total failed lint checks per validation run." },
			  { "name": "appendix_fixture_lint_pass_rate", "unit": "fraction", "window": "EMA-32", "notes": "Passes / (passes + failures)." }
			],
			"examples": {
			  "pass": {
				"feature_flags": {
				  "enable_exchange_envelope": true,
				  "enable_integrity_checks": false,
				  "enable_point_space_gliders": false
				},
				"metrics": [
				  { "metric": "lawful_compression_ratio", "window": "EMA-32" }
				],
				"envelope": { "Sigma_phase": "phase:2025-10-10T00:00:00Z" },
				"notes": "Delta_hash absent because integrity flag is false; all keys ASCII."
			  },
			  "fail": [
				{
				  "reason": "non-ASCII key",
				  "bad_fixture": { "mรฉtric": "equivalence_efficiency", "window": "EMA-16" },
				  "violations": ["LINT.ASCII_KEYS"]
				},
				{
				  "reason": "unicode outside latex",
				  "bad_fixture": { "title": "coherence โ ok", "latex": "C = 1" },
				  "violations": ["LINT.LATEX_ONLY_UNICODE"]
				},
				{
				  "reason": "flag-gated field present while flag=false",
				  "bad_fixture": {
					"feature_flags": { "enable_integrity_checks": false },
					"envelope": { "Delta_hash": "sha256:abcd" }
				  },
				  "violations": ["LINT.FLAG_GATING_INTEGRITY"]
				}
			  ]
			}
		  },
		  "notes": [
			"Appendix fixtures are observer-only: they measure, seal, route, validate, and emit telemetry; they do not perform control writes.",
			"When a flag is disabled, its gated fields MUST be entirely absent from fixtures, telemetry, and schemas (not null, not empty strings).",
			"All examples must be ready for automated linting and dashboard binding without manual edits."
		  ],
		  "rfc_anchors": ["PDP-0001 ยง3โยง4.5", "RFC-0008 ยง2", "RFC-0009 Appx D.4"]
		},

		{
		  "id": "A.1",
		  "title": "Mathematical Identities (Reference Index)",
		  "type": "reference_table",
		  "objective": "Index the equations used by all worked examples in Appendix A. Each identity is normative for variable naming and KPI computation but omits derivation details (Layer_0 governs proofs).",
		  "data": [
			{
			  "eq_id": "A.0",
			  "role": "governing_law",
			  "latex": "\\frac{d\\mathcal{C}}{dt} = \\lambda - (\\gamma_{co}+\\gamma_{stale}) + \\varepsilon",
			  "gloss": "Core coherence evolution: reinforcement minus adaptive and staleness damping plus small perturbation."
			},
			{
			  "eq_id": "A.1",
			  "role": "decay_horizon",
			  "latex": "\\tau_{decay} = \\zeta^{-1}",
			  "gloss": "Retention horizon derived from damping slope ฮถ."
			},
			{
			  "eq_id": "A.2a",
			  "role": "ethical_floor_def",
			  "latex": "TTL_{floor} = \\max(\\tau_{decay},\\;10\\,\\Delta t_{tick})",
			  "gloss": "Ethical minimum retention floor combining decay and tick-based duration."
			},
			{
			  "eq_id": "A.2b",
			  "role": "retention_bound",
			  "latex": "TTL_{floor} \\leq TTL \\leq TTL_{max}(t)",
			  "gloss": "Lawful retention must lie between the ethical floor and policy-dependent maximum."
			},
			{
			  "eq_id": "A.3",
			  "role": "phase_window",
			  "latex": "\\Delta\\tau_{phase} = \\alpha\\,EMA_{32}(\\mathcal{C})\\,,\\; \\alpha\\in[0.5,2.0]",
			  "gloss": "Adaptive replay or acceptance window scaled by coherence EMA."
			},
			{
			  "eq_id": "A.3b",
			  "role": "replay_seen_set_window",
			  "latex": "Window_{seen\\_set} = 2\\,\\Delta\\tau_{phase}",
			  "gloss": "Hybrid replay window: seen_set time horizon equals twice the phase window."
			},
			{
			  "eq_id": "A.4",
			  "role": "compression_ratio",
			  "latex": "LCR = \\frac{\\text{post\\_equiv\\_count}}{\\text{pre\\_equiv\\_count}}",
			  "gloss": "Lawful compression ratio โ post-equivalence divided by pre-equivalence entry count."
			},
			{
			  "eq_id": "A.5",
			  "role": "equivalence_efficiency",
			  "latex": "1 - LCR",
			  "gloss": "Capacity relief fraction gained from equivalence compression (inverse of LCR)."
			}
		  ],
		  "invariants": [
			{
			  "name": "Layer_0_Governs_Proofs",
			  "condition": "No derivation steps appear here; all equations trace to RFC-0005โ0009.",
			  "source": "PDP-0001 ยง3.2 (Layer abstraction contract)"
			},
			{
			  "name": "ASCII_On_Wire",
			  "condition": "All keys ASCII; unicode limited to latex strings.",
			  "source": "Appendix A.0 rule set"
			},
			{
			  "name": "EMA_Window_Restriction",
			  "condition": "EMA operators limited to {EMA-16, EMA-32, EMA-64}. Default for ฮฯ_phase is EMA-32.",
			  "source": "Appendix A.0 validation rules"
			}
		  ],
		  "examples": {
			"lawful_compression_example": {
			  "pre_equiv_count": 200,
			  "post_equiv_count": 140,
			  "LCR": 0.7,
			  "eff_eq": 0.3,
			  "notes": "Matches A.4 and A.5 definitions; pre-prune snapshot only."
			},
			"ttl_floor_example": {
			  "tau_decay": 240,
			  "Delta_t_tick": 12,
			  "TTL_floor": 240,
			  "TTL_max": 360,
			  "lawful_range": "[240, 360]"
			}
		  },
		  "rfc_anchors": ["RFC-0005 ยง4", "RFC-0006 ยง3โยง4", "RFC-0009 ยง7"],
		  "handoff": "Mathematical primitives indexed; next sections instantiate them through observer-class algorithms and telemetry."
		},

		{
		  "id": "A.2",
		  "title": "Capacity-First Saturation Handling",
		  "type": "worked_example",
		  "objective": "Show promotion gating โ equivalence compression snapshot (pre-prune KPIs) โ conditional prune.",
		  "rfc_anchors": ["RFC-0006 ยง4.4", "RFC-0009 ยง7.1", "RFC-0005 ยง4.2"],
		  "algorithms": [
			{
			  "name": "promotion_gating",
			  "role": "observer",
			  "inputs": ["C", "occupancy", "theta_promote_cap", "lambda_thresh", "delta_closure_max", "rho_res"],
			  "outputs": ["promotion_allowed"],
			  "params": ["window='EMA-32'", "rho_band=[0.3,0.7]"],
			  "steps": [
				"1. c_bar <- EMA(window, C).",
				"2. cap_gate <- (occupancy < theta_promote_cap).",
				"3. band_gate <- (rho_res >= rho_band[0] AND rho_res <= rho_band[1]).",
				"4. closure_gate <- (delta_closure_max is not exceeded).",
				"5. rate_gate <- (c_bar >= lambda_thresh).",
				"6. promotion_allowed <- cap_gate AND band_gate AND closure_gate AND rate_gate.",
				"7. return promotion_allowed."
			  ]
			},
			{
			  "name": "equivalence_compression_snapshot",
			  "role": "observer",
			  "inputs": ["pre_equiv_count"],
			  "outputs": ["post_equiv_count", "lawful_compression_ratio", "equivalence_efficiency"],
			  "params": [],
			  "steps": [
				"1. Map entries to shift-equivalence classes (no prune).",
				"2. post_equiv_count <- count(unique canonical representatives).",
				"3. if pre_equiv_count == 0: lawful_compression_ratio <- 1.0; equivalence_efficiency <- 0.0; return.",
				"4. lawful_compression_ratio <- post_equiv_count / pre_equiv_count.",
				"5. equivalence_efficiency <- 1 - lawful_compression_ratio.",
				"6. Emit snapshot to telemetry; proceed to saturation check."
			  ]
			},
			{
			  "name": "conditional_prune_if_still_saturated",
			  "role": "observer",
			  "inputs": ["occupancy_post_equiv", "theta_sat", "theta_prune"],
			  "outputs": ["prune_decision"],
			  "params": [],
			  "steps": [
				"1. if occupancy_post_equiv < theta_sat: prune_decision <- false; return.",
				"2. if occupancy_post_equiv >= theta_prune: prune_decision <- true; else prune_decision <- false.",
				"3. Record prune_decision and, if true, emit prune_events++."
			  ]
			}
		  ],
		  "invariants": [
			{
			  "name": "Compress_Before_Prune",
			  "condition": "Shift-equivalence compression MUST be performed and snapshotted prior to any pruning.",
			  "source": "RFC-0006 ยง4.4; RFC-0009 ยง7.1"
			},
			{
			  "name": "Observer_Only",
			  "condition": "All steps are measurement/validation/telemetry; no control writes to Xi.",
			  "source": "PDP-0001 ยง4.5"
			},
			{
			  "name": "ASCII_On_Wire",
			  "condition": "All JSON keys are ASCII; math symbols appear only within latex strings in A.1.",
			  "source": "Appendix A.0"
			},
			{
			  "name": "EMA_Window_Restriction",
			  "condition": "EMA windows limited to {EMA-16, EMA-32, EMA-64}.",
			  "source": "Appendix A.0"
			}
		  ],
		  "example_json": {
			"window": "EMA-32",
			"theta_promote_cap": 0.75,
			"theta_sat": 0.80,
			"theta_prune": 0.90,
			"inputs": {
			  "occupancy_before": 0.91,
			  "pre_equiv_count": 200,
			  "C": 0.72,
			  "lambda_thresh": 0.18,
			  "delta_closure_max": 0.02,
			  "rho_res": 0.55
			},
			"snapshot": {
			  "post_equiv_count": 140,
			  "lawful_compression_ratio": 0.70,
			  "equivalence_efficiency": 0.30
			},
			"post_equiv": {
			  "occupancy_post_equiv": 0.78,
			  "promotion_allowed": true,
			  "prune_decision": false
			},
			"notes": "Occupancy dropped below ฮธ_sat after equivalence compression; no prune executed. KPIs recorded strictly pre-prune."
		  },
		  "telemetry": [
			{ "metric": "saturation_level", "unit": "fraction", "window": "EMA-32", "notes": "Proportion of LTMM capacity currently occupied." },
			{ "metric": "lawful_compression_ratio", "unit": "dimensionless", "window": "EMA-32", "notes": "post_equiv_count / pre_equiv_count measured pre-prune." },
			{ "metric": "equivalence_efficiency", "unit": "fraction", "window": "EMA-32", "notes": "1 - lawful_compression_ratio." },
			{ "metric": "prune_events", "unit": "count", "window": "EMA-32", "notes": "Incremented only when prune_decision=true." }
		  ],
		  "bindings": [
			{ "dashboard": "memory/homeostasis", "series": ["saturation_level", "lawful_compression_ratio", "equivalence_efficiency"], "window": "EMA-32" }
		  ],
		  "notes": [
			"Promotion gating prevents capacity-negative promotions during pressure.",
			"Equivalence compression uses canonical representatives; counts are captured before any destructive step.",
			"Pruning is conditional and only follows a failed post-equivalence saturation check."
		  ],
		  "handoff": "Capacity contract demonstrated; next example isolates KPI computation paths for pre-prune snapshots."
		},

		{
		  "id": "A.3",
		  "title": "Compression KPI Snapshot (Pre-Prune)",
		  "type": "worked_example",
		  "objective": "Compute lawful_compression_ratio and equivalence_efficiency strictly pre-prune; export EMA-bound KPIs.",
		  "rfc_anchors": ["RFC-0006 ยง4.4", "RFC-0009 ยง7.2"],
		  "math_refs": ["A.4", "A.5"],

		  "algorithms": [
			{
			  "name": "compute_compression_kpis",
			  "role": "observer",
			  "inputs": ["pre_equiv_count", "post_equiv_count"],
			  "outputs": ["snapshot.lawful_compression_ratio", "snapshot.equivalence_efficiency"],
			  "params": ["window='EMA-32'"],
			  "steps": [
				"1. Guard: if pre_equiv_count == 0 โ set lcr=1.0 and eff=0.0; goto step 4.",
				"2. Compute lcr = post_equiv_count / pre_equiv_count.",
				"3. Compute eff = 1 - lcr.",
				"4. snapshot := {pre_equiv_count, post_equiv_count, lawful_compression_ratio:lcr, equivalence_efficiency:eff}.",
				"5. Return snapshot."
			  ]
			},
			{
			  "name": "export_kpis_to_telemetry",
			  "role": "observer",
			  "inputs": ["snapshot.lawful_compression_ratio", "snapshot.equivalence_efficiency", "window"],
			  "outputs": ["telemetry.lawful_compression_ratio", "telemetry.equivalence_efficiency"],
			  "params": ["window โ {EMA-16, EMA-32, EMA-64} (default 'EMA-32')"],
			  "steps": [
				"1. Feed snapshot.lawful_compression_ratio into EMA(window) โ telemetry.lawful_compression_ratio.",
				"2. Feed snapshot.equivalence_efficiency into EMA(window) โ telemetry.equivalence_efficiency.",
				"3. Emit both metrics to the memory/homeostasis dashboard series.",
				"4. Return export handles."
			  ]
			},
			{
			  "name": "pre_prune_guard",
			  "role": "observer",
			  "inputs": ["stage"],
			  "outputs": ["ok"],
			  "params": [],
			  "steps": [
				"1. Require stage == 'pre-prune'.",
				"2. If stage != 'pre-prune' โ raise E.MMM.stage.violation.",
				"3. ok <- true; return."
			  ]
			}
		  ],

		  "invariants": [
			{
			  "name": "PrePruneOnly",
			  "condition": "KPI snapshot MUST be taken before any pruning or eviction occurs.",
			  "source": "RFC-0006 ยง4.4; RFC-0009 ยง7.2"
			},
			{
			  "name": "EMAWindows",
			  "condition": "Telemetry smoothing windows MUST be one of {EMA-16, EMA-32, EMA-64}.",
			  "source": "RFC-0009 ยง7.2"
			},
			{
			  "name": "ZeroDivisionGuard",
			  "condition": "If pre_equiv_count == 0, set lawful_compression_ratio=1.0 and equivalence_efficiency=0.0.",
			  "source": "RFC-0009 ยง7.2"
			},
			{
			  "name": "ASCII_On_Wire",
			  "condition": "All JSON keys are ASCII; any math glyphs appear only in the A.M index.",
			  "source": "PDP-0001 ยง4.5 (authoring/validation discipline)"
			},
			{
			  "name": "ObserverOnly",
			  "condition": "This routine measures and emits telemetry only; no control writes to ฮ.",
			  "source": "PDP-0001 ยง4.5"
			}
		  ],

		  "example_json": {
			"fixture_nominal": {
			  "stage": "pre-prune",
			  "window": "EMA-32",
			  "pre_equiv_count": 1200,
			  "post_equiv_count": 780,
			  "snapshot": {
				"lawful_compression_ratio": 0.65,
				"equivalence_efficiency": 0.35
			  },
			  "telemetry_rollup": {
				"lawful_compression_ratio": 0.648,
				"equivalence_efficiency": 0.352
			  },
			  "notes": "Counts taken immediately after equivalence mapping; before any destructive action."
			},
			"fixture_edge_zero_pre": {
			  "stage": "pre-prune",
			  "window": "EMA-16",
			  "pre_equiv_count": 0,
			  "post_equiv_count": 0,
			  "snapshot": {
				"lawful_compression_ratio": 1.0,
				"equivalence_efficiency": 0.0
			  },
			  "telemetry_rollup": {
				"lawful_compression_ratio": 1.0,
				"equivalence_efficiency": 0.0
			  },
			  "notes": "Zero-division guard path; telemetry remains well-defined."
			},
			"fixture_out_of_order_violation": {
			  "stage": "post-prune",
			  "expect_error": "E.MMM.stage.violation",
			  "notes": "Spec-violating call for negative test coverage."
			}
		  },

		  "telemetry": [
			{ "metric": "lawful_compression_ratio", "range": "[0,1]", "units": "dimensionless", "window": "EMA-32", "description": "post_equiv_count / pre_equiv_count measured strictly pre-prune." },
			{ "metric": "equivalence_efficiency", "range": "[0,1]", "units": "fraction", "window": "EMA-32", "description": "1 - lawful_compression_ratio." }
		  ],

		  "bindings": [
			{ "dashboard": "memory/homeostasis", "series": ["lawful_compression_ratio", "equivalence_efficiency"], "window": "EMA-32" }
		  ],

		  "error_model": [
			{ "code": "E.MMM.stage.violation", "when": "stage != 'pre-prune'", "message": "Compression KPI snapshot must be taken pre-prune.", "remedy": "Reorder: run equivalence snapshot before prune pipeline." }
		  ],

		  "notes": [
			"Inputs are integers โฅ 0; snapshot values are computed in floating point.",
			"This example intentionally omits any storage or adapter detail (Layer_2)."
		  ]
		},

		{
		  "id": "A.4",
		  "title": "Ethical TTL Floor Verification",
		  "type": "worked_example",
		  "objective": "Verify TTL_floor โค TTL โค TTL_max(t) with observer-only checks and telemetry.",
		  "rfc_anchors": ["RFC-0005 ยง4.2", "RFC-0009 ยง7.1"],
		  "math_refs": ["A.2a", "A.2b"],

		  "algorithms": [
			{
			  "name": "compute_ttl_floor",
			  "role": "observer",
			  "inputs": ["tau_decay", "delta_t_tick"],
			  "outputs": ["TTL_floor"],
			  "params": [],
			  "steps": [
				"1. x <- tau_decay.",
				"2. y <- 10 * delta_t_tick.",
				"3. TTL_floor <- max(x, y).",
				"4. return TTL_floor."
			  ]
			},
			{
			  "name": "compute_ttl_max_effective",
			  "role": "observer",
			  "inputs": ["policy", "storage_pressure"],
			  "outputs": ["TTL_max"],
			  "params": ["g(policy, storage_pressure) is monotone non-increasing in storage_pressure"],
			  "steps": [
				"1. TTL_max <- g(policy, storage_pressure).",
				"2. return TTL_max."
			  ]
			},
			{
			  "name": "evaluate_retention",
			  "role": "observer",
			  "inputs": ["TTL_observed", "tau_decay", "delta_t_tick", "policy", "storage_pressure"],
			  "outputs": ["is_compliant", "violation_reason?", "TTL_floor", "TTL_max"],
			  "params": [],
			  "steps": [
				"1. TTL_floor <- compute_ttl_floor(tau_decay, delta_t_tick).",
				"2. TTL_max <- compute_ttl_max_effective(policy, storage_pressure).",
				"3. if TTL_observed < TTL_floor: is_compliant <- false; violation_reason <- 'below_floor'; return with TTL_floor, TTL_max.",
				"4. if TTL_observed > TTL_max: is_compliant <- false; violation_reason <- 'above_max'; return with TTL_floor, TTL_max.",
				"5. is_compliant <- true; violation_reason <- null; return with TTL_floor, TTL_max."
			  ]
			},
			{
			  "name": "export_retention_telemetry",
			  "role": "observer",
			  "inputs": ["TTL_floor", "TTL_observed", "TTL_max", "is_compliant", "window"],
			  "outputs": ["telemetry.ethical_ttl_floor", "telemetry.ttl_max_effective", "telemetry.ttl_compliance_rate"],
			  "params": ["window โ {EMA-16, EMA-32, EMA-64} (default 'EMA-16')"],
			  "steps": [
				"1. telemetry.ethical_ttl_floor <- EMA(window, TTL_floor).",
				"2. telemetry.ttl_max_effective <- EMA(window, TTL_max).",
				"3. telemetry.ttl_compliance_rate <- EMA(window, 1 if is_compliant else 0).",
				"4. return export handles."
			  ]
			}
		  ],

		  "invariants": [
			{
			  "name": "EthicalFloorBound",
			  "condition": "Retention MUST satisfy TTL_floor โค TTL โค TTL_max(t).",
			  "source": "RFC-0005 ยง4.2; RFC-0009 ยง7.1"
			},
			{
			  "name": "TTLFloorDefinition",
			  "condition": "TTL_floor = max(tau_decay, 10ยทdelta_t_tick).",
			  "source": "RFC-0005 ยง4.2"
			},
			{
			  "name": "TTLMaxMonotonicity",
			  "condition": "TTL_max(t) MUST be monotone non-increasing in storage_pressure.",
			  "source": "RFC-0009 ยง7.1"
			},
			{
			  "name": "ObserverOnly",
			  "condition": "Evaluation and telemetry are observer-class only; no control writes to ฮ.",
			  "source": "PDP-0001 ยง4.5"
			},
			{
			  "name": "EMAWindows",
			  "condition": "All telemetry smoothing windows MUST be one of {EMA-16, EMA-32, EMA-64}.",
			  "source": "RFC-0009 ยง7.1"
			},
			{
			  "name": "ASCII_On_Wire",
			  "condition": "All JSON keys are ASCII; math glyphs live only in the A.M index.",
			  "source": "Authoring discipline"
			}
		  ],

		  "example_json": {
			"fixture_nominal": {
			  "window": "EMA-16",
			  "inputs": {
				"tau_decay": 240,
				"delta_t_tick": 12,
				"TTL_observed": 300,
				"policy": "retention:balanced",
				"storage_pressure": 0.7
			  },
			  "computed": {
				"TTL_floor": 240,
				"TTL_max": 360,
				"is_compliant": true,
				"violation_reason": null
			  },
			  "telemetry_rollup": {
				"ethical_ttl_floor": 241.2,
				"ttl_max_effective": 358.7,
				"ttl_compliance_rate": 1.0
			  },
			  "notes": "Within bounds: 240 โค 300 โค 360."
			},
			"fixture_below_floor": {
			  "window": "EMA-32",
			  "inputs": {
				"tau_decay": 240,
				"delta_t_tick": 8,
				"TTL_observed": 180,
				"policy": "retention:conservative",
				"storage_pressure": 0.3
			  },
			  "computed": {
				"TTL_floor": 240,
				"TTL_max": 420,
				"is_compliant": false,
				"violation_reason": "below_floor"
			  },
			  "expect_error": null,
			  "notes": "Violation: observed TTL below ethical floor."
			},
			"fixture_above_max": {
			  "window": "EMA-64",
			  "inputs": {
				"tau_decay": 120,
				"delta_t_tick": 10,
				"TTL_observed": 900,
				"policy": "retention:pressure-aware",
				"storage_pressure": 0.9
			  },
			  "computed": {
				"TTL_floor": 120,
				"TTL_max": 300,
				"is_compliant": false,
				"violation_reason": "above_max"
			  },
			  "notes": "Violation: observed TTL exceeds pressure-constrained maximum."
			}
		  },

		  "telemetry": [
			{ "metric": "ethical_ttl_floor", "range": "[0,+inf)", "units": "ticks", "window": "EMA-16", "description": "Smoothed floor bound used for audits." },
			{ "metric": "ttl_max_effective", "range": "[0,+inf)", "units": "ticks", "window": "EMA-16", "description": "Smoothed maximum bound under current policy/pressure." },
			{ "metric": "ttl_compliance_rate", "range": "[0,1]", "units": "fraction", "window": "EMA-16", "description": "Rate of samples in compliance with the ethical bound." }
		  ],

		  "bindings": [
			{ "dashboard": "memory/policy", "series": ["ethical_ttl_floor", "ttl_max_effective", "ttl_compliance_rate"], "window": "EMA-16" }
		  ],

		  "error_model": [
			{ "code": "E.MMM.ttl.floor.undefined", "when": "tau_decay or delta_t_tick missing/invalid", "message": "Cannot compute TTL_floor without tau_decay and delta_t_tick.", "remedy": "Provide both inputs as non-negative numbers." },
			{ "code": "E.MMM.ttl.max.nonmonotone", "when": "g(policy, storage_pressure) increases with storage_pressure", "message": "TTL_max must be non-increasing in storage_pressure.", "remedy": "Select a policy function g that respects monotonicity." }
		  ],

		  "notes": [
			"Inputs are non-negative numbers; units (ticks/seconds) must be consistent across tau_decay, delta_t_tick, TTL_observed.",
			"This worked example avoids any storage, role, or crypto detail (Layer_2)."
		  ]
		},

		{
		  "id": "A.5",
		  "title": "Replay Window & seen_set Defense",
		  "description": "Observer-class replay protection using a phase-derived horizon and a hybrid (time-window + LRU) seen_set. Keys are composed structurally and gated by feature flags; telemetry uses fixed EMA windows.",
		  "rfc_anchors": [
			"RFC-0008 ยง2.2",
			"RFC-0009 ยง7.2",
			"RFC-0006 ยง3.2",
			"RFC-0005 ยง4.3",
			"PDP-0001 ยง4.5",
			"PDP-0001 ยง5.2"
		  ],
		  "interfaces": {
			"inputs": [
			  {
				"name": "import_event",
				"type": "object",
				"constraints": "Required fields: origin (ASCII), bundle_id (ASCII). Optional: Sigma_phase, Delta_hash. Fields used in key MUST NOT contain '|' unescaped.",
				"notes": "Sigma_phase is present only when enable_exchange_envelope=true; Delta_hash present only when enable_integrity_checks=true."
			  },
			  {
				"name": "C_trace",
				"type": "list<float>",
				"constraints": "Non-empty; consistent timebase.",
				"notes": "Used to compute the phase horizon via EMA-32 and alpha."
			  },
			  {
				"name": "alpha",
				"type": "float",
				"constraints": "alpha โ [0.5, 2.0]",
				"notes": "Scales the phase horizon derived from coherence."
			  },
			  {
				"name": "flags",
				"type": "object",
				"constraints": "{ enable_exchange_envelope: bool, enable_integrity_checks: bool }",
				"notes": "Gates inclusion of Sigma_phase and Delta_hash in seen_key."
			  }
			],
			"outputs": [
			  {
				"name": "decision",
				"type": "object",
				"constraints": "{ accepted: bool, reason: 'ok'|'replay_drop'|'missing_checksum'|'validation_error' }",
				"notes": "Observer emits decision and telemetry only; no control writes."
			  },
			  {
				"name": "telemetry",
				"type": "object",
				"constraints": "Metrics defined below; EMA windows โ {EMA-16, EMA-32, EMA-64}.",
				"notes": "Default window EMA-32."
			  }
			],
			"side_effects": [
			  "observer-only"
			]
		  },
		  "state_lifecycle": {
			"states": [
			  "Absent",
			  "Cached",
			  "Expired"
			],
			"transitions": [
			  {
				"from": "Absent",
				"to": "Cached",
				"on": "import_event with unseen seen_key",
				"guard": "โ",
				"notes": "Initialize entry with {ts: now, ttl: window} where window = 2*Delta_tau_phase."
			  },
			  {
				"from": "Cached",
				"to": "Cached",
				"on": "import_event with seen_key and (now - ts) > window",
				"guard": "โ",
				"notes": "Treat as fresh; update ts and ttl; may trigger LRU maintenance."
			  },
			  {
				"from": "Cached",
				"to": "Cached",
				"on": "capacity_pressure",
				"guard": "Eviction policy == LRU",
				"notes": "Least-recently-used entries evicted first."
			  },
			  {
				"from": "Cached",
				"to": "Cached",
				"on": "import_event with seen_key and (now - ts) โค window",
				"guard": "โ",
				"notes": "Replay drop; do not mutate ts."
			  },
			  {
				"from": "Cached",
				"to": "Expired",
				"on": "ttl elapsed and entry evicted",
				"guard": "โ",
				"notes": "Expiration is observational; removal results from LRU or ttl aging."
			  }
			]
		  },
		  "requirements": [
			{
			  "level": "MUST",
			  "text": "Compute Delta_tau_phase := alpha * EMA-32(C_trace) with alpha โ [0.5, 2.0] using a consistent timebase.",
			  "anchor": "RFC-0006 ยง3.2; RFC-0009 ยง7.1"
			},
			{
			  "level": "MUST",
			  "text": "Use replay window = 2 * Delta_tau_phase for acceptance decisions.",
			  "anchor": "RFC-0008 ยง2.2"
			},
			{
			  "level": "MUST",
			  "text": "Compose seen_key by joining parts with '|' in the order: [origin, Sigma_phase?, Delta_hash?, bundle_id], including optional parts only when their corresponding flags are enabled.",
			  "anchor": "RFC-0008 ยง2; RFC-0009 ยง7.2"
			},
			{
			  "level": "MUST",
			  "text": "Ensure origin and bundle_id either do not contain '|' or are escaped before key composition; escaping/enforcement is deferred to Layer_2.",
			  "anchor": "PDP-0001 ยง4.2; RFC-0008 ยง2.2"
			},
			{
			  "level": "MUST",
			  "text": "The seen_set eviction policy is LRU.",
			  "anchor": "RFC-0008 ยง2.2; RFC-0009 ยง7.2"
			},
			{
			  "level": "MUST",
			  "text": "This defense remains observer-class: perform lookup/insert/emit only; do not perform control writes to ฮ.",
			  "anchor": "PDP-0001 ยง4.5"
			},
			{
			  "level": "SHOULD",
			  "text": "Default metric smoothing window is EMA-32; only EMA-16/32/64 are permitted.",
			  "anchor": "PDP-0001 ยง5.2; RFC-0009 ยง7.2"
			},
			{
			  "level": "MAY",
			  "text": "Emit Sigma_phase and Delta_hash in seen_key only when enable_exchange_envelope and enable_integrity_checks are true, respectively.",
			  "anchor": "RFC-0008 ยง2; RFC-0009 ยง7.2"
			}
		  ],
		  "error_model": [
			{
			  "code": "E.MMM.phase.alpha.invalid",
			  "when": "alpha โ [0.5, 2.0]",
			  "message": "alpha outside allowed range for Delta_tau_phase computation.",
			  "remedy": "Choose alpha in [0.5, 2.0]."
			},
			{
			  "code": "E.MMM.seen.eviction_policy",
			  "when": "Eviction policy != LRU",
			  "message": "seen_set eviction policy must be LRU.",
			  "remedy": "Configure LRU eviction within the replay window."
			},
			{
			  "code": "E.MMM.seen.flag_key_violation",
			  "when": "seen_key contains gated fields while flags are disabled (or vice versa)",
			  "message": "Key composition must respect feature flags.",
			  "remedy": "Recompose key according to current flags."
			},
			{
			  "code": "E.MMM.seen.key_escape",
			  "when": "origin or bundle_id contains unescaped '|'",
			  "message": "Key parts must not include raw '|' characters.",
			  "remedy": "Escape or forbid '|' in origin/bundle_id at Layer_2 before composition."
			},
			{
			  "code": "E.MMM.seen.missing_checksum",
			  "when": "Flags require Sigma_phase and/or Delta_hash but corresponding field is absent",
			  "message": "Required checksum fields missing under current feature flags.",
			  "remedy": "Provide gated fields or disable the corresponding flags."
			}
		  ],
		  "metrics": [
			{
			  "name": "avg_replay_window_ticks",
			  "unit": "ticks",
			  "window": "EMA-32",
			  "notes": "Smoothed value of 2 * Delta_tau_phase."
			},
			{
			  "name": "replay_drop_rate",
			  "unit": "fraction",
			  "window": "EMA-32",
			  "notes": "Fraction of imports dropped as replays within the window."
			},
			{
			  "name": "accepted_within_window",
			  "unit": "fraction",
			  "window": "EMA-32",
			  "notes": "Fraction of imports accepted (not dropped) across the same horizon."
			},
			{
			  "name": "import_reject_missing_checksum",
			  "unit": "count",
			  "window": "EMA-32",
			  "notes": "Rejected imports due to missing gated checksum fields when flags demand them."
			}
		  ],
		  "pseudocode": [
			{
			  "title": "compute_phase_window",
			  "anchors": [
				"compute_phase_window"
			  ],
			  "rfc_anchors": [
				"RFC-0006 ยง3.2",
				"RFC-0009 ยง7.1"
			  ],
			  "code": [
				"def compute_phase_window(C_trace, alpha):",
				"    C_bar = EMA32(C_trace)",
				"    Delta_tau_phase = alpha * C_bar",
				"    return 2 * Delta_tau_phase  # replay window"
			  ]
			},
			{
			  "title": "compose_seen_key (flag-respecting, with escape requirement)",
			  "anchors": [
				"compose_seen_key"
			  ],
			  "rfc_anchors": [
				"RFC-0008 ยง2.2",
				"PDP-0001 ยง4.2"
			  ],
			  "code": [
				"def compose_seen_key(origin, bundle_id, flags, Sigma_phase=None, Delta_hash=None):",
				"    # PRECONDITION (L2): origin and bundle_id contain no raw '|' (escape if needed).",
				"    parts = [origin]",
				"    if flags.enable_exchange_envelope and Sigma_phase is not None:",
				"        parts.append(Sigma_phase)",
				"    if flags.enable_integrity_checks and Delta_hash is not None:",
				"        parts.append(Delta_hash)",
				"    parts.append(bundle_id)",
				"    return '|'.join(parts)"
			  ]
			},
			{
			  "title": "seen_set_hybrid_policy (time-window + LRU)",
			  "anchors": [
				"seen_set_hybrid_policy"
			  ],
			  "rfc_anchors": [
				"RFC-0008 ยง2.2",
				"RFC-0009 ยง7.2"
			  ],
			  "code": [
				"def seen_set_hybrid_policy(seen_set, seen_key, now, window):",
				"    if seen_key in seen_set and (now - seen_set[seen_key].ts) <= window:",
				"        emit('replay_drop_event')",
				"        return {'accepted': False, 'reason': 'replay_drop'}",
				"    seen_set[seen_key] = {'ts': now, 'ttl': window}",
				"    lru_eviction_if_needed(seen_set)",
				"    return {'accepted': True, 'reason': 'ok'}"
			  ]
			}
		  ],
		  "examples": [
			{
			  "title": "Flags ON (Sigma_phase + Delta_hash included)",
			  "input": {
				"flags": { "enable_exchange_envelope": true, "enable_integrity_checks": true },
				"alpha": 1.0,
				"C_trace": [0.62, 0.64, 0.63, 0.65],
				"events": [
				  { "t": 100.00, "origin": "agent.A", "bundle_id": "G@2025-Q4", "Sigma_phase": "phase:t100", "Delta_hash": "sha256:aa...11" },
				  { "t": 100.80, "origin": "agent.A", "bundle_id": "G@2025-Q4", "Sigma_phase": "phase:t100", "Delta_hash": "sha256:aa...11" },
				  { "t": 101.50, "origin": "agent.A", "bundle_id": "G@2025-Q4", "Sigma_phase": "phase:t101.5", "Delta_hash": "sha256:aa...11" }
				]
			  },
			  "output": {
				"computed": { "Delta_tau_phase": 0.64, "window_ticks": 1.28 },
				"decisions": ["accepted", "replay_drop", "accepted"],
				"telemetry": {
				  "avg_replay_window_ticks": 1.28,
				  "replay_drop_rate": 0.333,
				  "accepted_within_window": 0.667
				}
			  },
			  "notes": "Second event occurs within 2*Delta_tau_phase; dropped as replay. Key order respects flags."
			},
			{
			  "title": "Flags OFF (checksums excluded)",
			  "input": {
				"flags": { "enable_exchange_envelope": false, "enable_integrity_checks": false },
				"alpha": 0.8,
				"C_trace": [0.40, 0.45, 0.44, 0.46],
				"events": [
				  { "t": 200.00, "origin": "agent.X", "bundle_id": "G@2025-Q4" },
				  { "t": 200.50, "origin": "agent.X", "bundle_id": "G@2025-Q4" },
				  { "t": 201.00, "origin": "agent.X", "bundle_id": "G@2025-Q4" }
				]
			  },
			  "output": {
				"computed": { "Delta_tau_phase": 0.36, "window_ticks": 0.72 },
				"decisions": ["accepted", "replay_drop", "accepted"],
				"telemetry": {
				  "avg_replay_window_ticks": 0.72,
				  "replay_drop_rate": 0.333,
				  "accepted_within_window": 0.667
				}
			  },
			  "notes": "Behavior still bounded by 2*Delta_tau_phase; key excludes gated fields."
			},
			{
			  "title": "Negative: non-LRU eviction policy",
			  "input": {
				"flags": { "enable_exchange_envelope": true, "enable_integrity_checks": true },
				"policy_attempt": "FIFO"
			  },
			  "output": {
				"error": "E.MMM.seen.eviction_policy"
			  },
			  "notes": "Eviction policy MUST be LRU."
			}
		  ]
		},

		{
		  "id": "A.6",
		  "title": "Provenance & Lineage: Merge vs Fork",
		  "type": "worked_example",
		  "objective": "Validate RFC-0007 bundles; decide merge/fork via parent_hash and integrity_hash; emit provenance events (observer-only).",
		  "rfc_anchors": ["RFC-0007 ยง2", "RFC-0009 ยง5.1", "PDP-0001 ยง3"],

		  "algorithms": [
			{
			  "name": "validate_provenance_and_lineage",
			  "role": "observer",
			  "inputs": ["bundle_header"],
			  "outputs": ["provenance_ok", "lineage_ok", "reasons"],
			  "params": [
				"version_format = 'YYYY-QX'",
				"psi_regex = '^ฯ-[a-z0-9_]+@ฮ$'",
				"hash_regex = '^[a-f0-9]{6,}$'"
			  ],
			  "steps": [
				"1. Check header.version matches version_format.",
				"2. Verify provenance fields {origin, origin_hash, created_at} exist and origin_hash matches hash_regex (structural only).",
				"3. Validate ontology index ฯ-field names against psi_regex (values may be unicode; keys remain ASCII).",
				"4. lineage_ok <- header.lineage.schema in {'RFC-0007','RFC-0009-lineage'} AND parent_hash/integrity_hash match hash_regex.",
				"5. provenance_ok <- (origin is present) AND (origin_hash structural check passed) AND (created_at ISO-8601).",
				"6. reasons <- array of any failing checks (empty if all pass).",
				"7. return provenance_ok, lineage_ok, reasons."
			  ]
			},
			{
			  "name": "merge_or_fork_decision",
			  "role": "observer",
			  "inputs": ["bundle_A.lineage", "bundle_B.lineage"],
			  "outputs": ["decision"],
			  "params": [],
			  "steps": [
				"1. if A.parent_hash == B.parent_hash AND A.integrity_hash == B.integrity_hash: decision <- 'merge'.",
				"2. else if A.parent_hash == B.parent_hash AND A.integrity_hash != B.integrity_hash: decision <- 'fork'.",
				"3. else: decision <- 'unrelated'.",
				"4. return decision."
			  ]
			},
			{
			  "name": "emit_provenance_event",
			  "role": "observer",
			  "inputs": ["decision", "bundle_meta"],
			  "outputs": ["event_recorded"],
			  "params": ["window = 'EMA-32'"],
			  "steps": [
				"1. if decision == 'fork': record {type:'fork_event', origin, parent_hash, integrity_hash_A, integrity_hash_B, timestamp}.",
				"2. else if decision == 'merge': record {type:'merge_event', origin, parent_hash, integrity_hash, timestamp}.",
				"3. else: record {type:'no_merge', reason:'unrelated', timestamp}.",
				"4. event_recorded <- true; return."
			  ]
			}
		  ],

		  "invariants": [
			{
			  "name": "RFC0007_First",
			  "condition": "Bundle schema (version, ฯ-field, lineage) is validated before any merge/fork decision.",
			  "source": "RFC-0007 ยง2"
			},
			{
			  "name": "MergeFork_Rules",
			  "condition": "merge iff parent_hash and integrity_hash both match; fork iff parent_hash matches and integrity_hash differs; else unrelated.",
			  "source": "RFC-0007 ยง2; RFC-0009 ยง5.1"
			},
			{
			  "name": "Observer_Only",
			  "condition": "Process performs measurement/validation/record-only; no control writes to Xi.",
			  "source": "PDP-0001 ยง3"
			},
			{
			  "name": "ASCII_On_Wire",
			  "condition": "All JSON keys are ASCII; unicode may appear in values (e.g., ฯ-field).",
			  "source": "Appendix A conventions"
			}
		  ],

		  "example_json": {
			"version": "2025-Q4",
			"bundle_A": {
			  "header": {
				"provenance": { "origin": "agent.A", "origin_hash": "a1b2c3d4", "created_at": "2025-09-30T12:00:00Z" },
				"lineage": { "parent_hash": "p_hash_77aa", "integrity_hash": "ihash_aa11", "schema": "RFC-0007" },
				"motif_count": 128
			  },
			  "index": [
				{ "motif_id": "m-001", "psi_field": "ฯ-null@ฮ", "usage_frequency": 12, "version": "2025-Q4" }
			  ]
			},
			"bundle_B": {
			  "header": {
				"provenance": { "origin": "agent.B", "origin_hash": "d4e5f6a7", "created_at": "2025-10-02T08:45:10Z" },
				"lineage": { "parent_hash": "p_hash_77aa", "integrity_hash": "ihash_bb22", "schema": "RFC-0007" },
				"motif_count": 129
			  },
			  "index": [
				{ "motif_id": "m-001", "psi_field": "ฯ-null@ฮ", "usage_frequency": 13, "version": "2025-Q4" }
			  ]
			},
			"validation": {
			  "provenance_ok": true,
			  "lineage_ok": true,
			  "reasons": []
			},
			"decision": "fork",
			"provenance_event": {
			  "type": "fork_event",
			  "origin": "agent.B",
			  "parent_hash": "p_hash_77aa",
			  "integrity_hash_A": "ihash_aa11",
			  "integrity_hash_B": "ihash_bb22",
			  "timestamp": "2025-10-11T00:00:00Z"
			},
			"notes": "Parent hashes equal; integrity hashes differ โ fork per RFC-0007."
		  },

		  "telemetry": [
			{ "metric": "fork_events", "range": "[0,+inf)", "units": "count", "window": "EMA-32", "description": "Count of fork decisions recorded." },
			{ "metric": "merge_events", "range": "[0,+inf)", "units": "count", "window": "EMA-32", "description": "Count of merge decisions recorded." },
			{ "metric": "provenance_validation_failures", "range": "[0,+inf)", "units": "count", "window": "EMA-32", "description": "Number of structural provenance/lineage validation failures." }
		  ],

		  "bindings": [
			{ "dashboard": "security/provenance", "series": ["fork_events", "merge_events", "provenance_validation_failures"], "window": "EMA-32" }
		  ],

		  "notes": [
			"This appendix illustrates behavior; it does not introduce new MUSTs beyond those anchored to RFC-0007/RFC-0009.",
			"If feature flags for checksums are present elsewhere, they do not affect merge/fork rules in this example."
		  ]
		},

		{
		  "id": "A.7",
		  "title": "Adversarial Import โ Bounded Recovery & Quarantine",
		  "description": "Observer-class screening that routes suspect imports into a bounded, TTL-governed quarantine and releases them only after successful re-anchoring. Recovery is ordered via a per-agent monotonic recovery_token. Replay screening per A.5 precedes quarantine.",
		  "rfc_anchors": [
			"RFC-0008 ยง2.2",
			"RFC-0007 ยง3.2",
			"RFC-0009 ยง5.2",
			"RFC-0009 ยง7.1",
			"RFC-0005 ยง4.2",
			"PDP-0001 ยง4.5",
			"PDP-0001 ยง5.2",
			"PDP-0001 ยง6.1"
		  ],
		  "interfaces": {
			"inputs": [
			  {
				"name": "import_event",
				"type": "object",
				"constraints": "Required: origin (ASCII), bundle_id (ASCII). Optional (flag-gated): Sigma_phase, Delta_hash. Contains ontology_bundle_ref (by-reference).",
				"notes": "If flags require checksums and fields are missing, the event is potentially recoverable."
			  },
			  {
				"name": "seen_key",
				"type": "string",
				"constraints": "Computed per ยงA.5; '|' delimited; parts escaped at Layer_2.",
				"notes": "Replay screening MUST occur before quarantine evaluation."
			  },
			  {
				"name": "now",
				"type": "float",
				"constraints": "Monotone non-decreasing tick.",
				"notes": "Used for TTL and token ordering."
			  },
			  {
				"name": "policy",
				"type": "object",
				"constraints": "{ ttl_floor, ttl_ceiling } with ttl_floor โค ttl_ceiling.",
				"notes": "ttl_floor defers to ethical TTL bound; enforcement of storage timers lives in Layer_2."
			  },
			  {
				"name": "flags",
				"type": "object",
				"constraints": "{ enable_exchange_envelope: bool, enable_integrity_checks: bool }",
				"notes": "Gates required checks during release."
			  },
			  {
				"name": "recovery_attempt",
				"type": "object",
				"constraints": "Optional. Carries { recovery_token, updated_import_event } when attempting release.",
				"notes": "Used to re-validate quarantined items."
			  }
			],
			"outputs": [
			  {
				"name": "decision",
				"type": "object",
				"constraints": "{ status: 'accept'|'quarantine'|'reject'|'release'|'replay_drop', reason: string }",
				"notes": "Status 'replay_drop' is emitted only if A.5 declares the event a replay."
			  },
			  {
				"name": "recovery_token",
				"type": "string",
				"constraints": "Present only when status='quarantine'. Strictly increasing per-agent.",
				"notes": "Token is an ordering handle; no security semantics at Layer_1."
			  },
			  {
				"name": "telemetry",
				"type": "object",
				"constraints": "Metrics declared below; EMA windows โ {EMA-16, EMA-32, EMA-64}.",
				"notes": "Default EMA-32."
			  }
			],
			"side_effects": [
			  "observer-only"
			]
		  },
		  "state_lifecycle": {
			"states": [
			  "Screening",
			  "Quarantined",
			  "Released",
			  "Rejected",
			  "Expired"
			],
			"transitions": [
			  {
				"from": "Screening",
				"to": "Screening",
				"on": "A.5 replay detected",
				"guard": "โ",
				"notes": "Emit decision.status='replay_drop'; do not enter quarantine."
			  },
			  {
				"from": "Screening",
				"to": "Quarantined",
				"on": "Recoverable validation failure",
				"guard": "ttl_floor โค quarantine_ttl โค ttl_ceiling",
				"notes": "Issue recovery_token; record ts=now, ttl=quarantine_ttl."
			  },
			  {
				"from": "Screening",
				"to": "Rejected",
				"on": "Non-recoverable validation failure",
				"guard": "โ",
				"notes": "Emit reason; no token."
			  },
			  {
				"from": "Screening",
				"to": "Released",
				"on": "All validations pass",
				"guard": "โ",
				"notes": "Accept immediately."
			  },
			  {
				"from": "Quarantined",
				"to": "Released",
				"on": "recovery_attempt validated",
				"guard": "All required checks now pass",
				"notes": "Emit decision.status='release'."
			  },
			  {
				"from": "Quarantined",
				"to": "Expired",
				"on": "ttl elapsed or LRU eviction on pressure",
				"guard": "Eviction policy == LRU",
				"notes": "Emit expiration metric; item discarded."
			  }
			]
		  },
		  "requirements": [
			{
			  "level": "MUST",
			  "text": "Apply replay screening per ยงA.5 before evaluating quarantine.",
			  "anchor": "RFC-0008 ยง2.2; RFC-0009 ยง7.2"
			},
			{
			  "level": "MUST",
			  "text": "Generate recovery_token as a strictly increasing, per-agent sequence keyed by agent_id and time.",
			  "anchor": "RFC-0009 ยง5.2; PDP-0001 ยง6.1"
			},
			{
			  "level": "MUST",
			  "text": "Quarantine TTL must satisfy TTL_floor โค quarantine_ttl โค TTL_max(t); TTL_floor defers to ethical bound; enforcement is Layer_2.",
			  "anchor": "RFC-0005 ยง4.2; RFC-0009 ยง7.1"
			},
			{
			  "level": "MUST",
			  "text": "Quarantine store uses LRU eviction under capacity pressure; expiration is observational (no control writes to ฮ).",
			  "anchor": "RFC-0008 ยง2.2; PDP-0001 ยง4.5"
			},
			{
			  "level": "MUST",
			  "text": "Release from quarantine only when (a) RFC-0007 ontology validation passes, (b) required checksums are present when flags demand them, and (c) provenance/coherence checks pass.",
			  "anchor": "RFC-0007 ยง3.2; RFC-0008 ยง2.2; RFC-0009 ยง7.1"
			},
			{
			  "level": "SHOULD",
			  "text": "Classify recoverable vs non-recoverable failures via a documented policy table (e.g., missing checksum โ recoverable; malformed JSON or reserved motif redefinition โ non-recoverable).",
			  "anchor": "RFC-0007 ยง3.2; RFC-0009 ยง5.2"
			},
			{
			  "level": "SHOULD",
			  "text": "Default all recovery-related metrics to EMA-32.",
			  "anchor": "PDP-0001 ยง5.2; RFC-0009 ยง7.1"
			}
		  ],
		  "error_model": [
			{
			  "code": "E.MMM.recovery.token.order",
			  "when": "Observed recovery_token is not strictly greater than the last token for the same agent_id",
			  "message": "Non-monotonic recovery_token detected.",
			  "remedy": "Regenerate token via monotonic_token(agent_id, now, seq) ensuring ordering."
			},
			{
			  "code": "E.MMM.recovery.ttl.bounds",
			  "when": "quarantine_ttl < TTL_floor or quarantine_ttl > TTL_max(t)",
			  "message": "Quarantine TTL outside permitted bounds.",
			  "remedy": "Choose a TTL within [TTL_floor, TTL_max(t)]."
			},
			{
			  "code": "E.MMM.recovery.flags.integrity",
			  "when": "flags require Sigma_phase and/or Delta_hash but corresponding field absent at release",
			  "message": "Required checksum fields missing under current flags.",
			  "remedy": "Provide gated fields or disable flags."
			},
			{
			  "code": "E.MMM.ontology.invalid",
			  "when": "Ontology validation fails on release attempt",
			  "message": "Ontology bundle invalid per RFC-0007.",
			  "remedy": "Submit a valid, acyclic bundle referencing known motifs."
			},
			{
			  "code": "E.MMM.dep.a5.missing",
			  "when": "Quarantine invoked without prior ยงA.5 replay screening or without a valid seen_key",
			  "message": "Missing replay-screening dependency.",
			  "remedy": "Compute seen_key and apply ยงA.5 before quarantine."
			}
		  ],
		  "metrics": [
			{
			  "name": "quarantine_queue_depth",
			  "unit": "count",
			  "window": "EMA-32",
			  "notes": "Smoothed number of items currently quarantined."
			},
			{
			  "name": "quarantine_release_rate",
			  "unit": "fraction",
			  "window": "EMA-32",
			  "notes": "Rate of quarantined items successfully released."
			},
			{
			  "name": "quarantine_expire_rate",
			  "unit": "fraction",
			  "window": "EMA-32",
			  "notes": "Rate of quarantined items that expire or are evicted (LRU)."
			},
			{
			  "name": "recovery_attempt_rate",
			  "unit": "count",
			  "window": "EMA-32",
			  "notes": "Number of recovery attempts processed per horizon."
			},
			{
			  "name": "invalid_ontology_rate",
			  "unit": "fraction",
			  "window": "EMA-32",
			  "notes": "Fraction of recovery attempts failing RFC-0007 validation."
			}
		  ],
		  "pseudocode": [
			{
			  "title": "monotonic_token (per-agent, strictly increasing)",
			  "anchors": [
				"monotonic_token"
			  ],
			  "rfc_anchors": [
				"RFC-0009 ยง5.2",
				"PDP-0001 ยง6.1"
			  ],
			  "code": [
				"def monotonic_token(agent_id, tick, seq):",
				"    # PRE: tick is monotone per agent; seq is local increment.",
				"    # FORMAT is structural; no security semantics at Layer_1.",
				"    return f\"rtok:{agent_id}:{int(tick*1e6)}:{seq}\""
			  ]
			},
			{
			  "title": "recovery_gate (screen โ quarantine/reject/accept)",
			  "anchors": [
				"recovery_gate"
			  ],
			  "rfc_anchors": [
				"RFC-0008 ยง2.2",
				"RFC-0009 ยง7.1",
				"RFC-0007 ยง3.2"
			  ],
			  "code": [
				"def recovery_gate(import_event, seen_key, now, policy, flags):",
				"    # 1) Replay screen (delegated):",
				"    if is_replay_per_A5(seen_key, now):",
				"        return {'status': 'replay_drop', 'reason': 'A5_window'}",
				"    # 2) Validate recoverable/non-recoverable:",
				"    errors = validate_import(import_event, flags)  # structural + gated checks only",
				"    if not errors:",
				"        return {'status': 'accept', 'reason': 'ok'}",
				"    if is_non_recoverable(errors):",
				"        return {'status': 'reject', 'reason': 'non_recoverable'}",
				"    # 3) Quarantine path:",
				"    ttl = clamp(policy.ttl_floor, policy.ttl_ceiling, pick_quarantine_ttl(errors))",
				"    token = monotonic_token(import_event.origin, now, next_seq(import_event.origin))",
				"    quarantine_store_put(token, import_event, now, ttl)  # observer-class record",
				"    return {'status': 'quarantine', 'recovery_token': token, 'reason': 'recoverable'}"
			  ]
			},
			{
			  "title": "recovery_attempt (release or keep)",
			  "anchors": [
				"recovery_attempt"
			  ],
			  "rfc_anchors": [
				"RFC-0007 ยง3.2",
				"RFC-0009 ยง7.1"
			  ],
			  "code": [
				"def recovery_attempt(recovery_token, updated_import_event, now, flags):",
				"    rec = quarantine_store_get(recovery_token)",
				"    if rec is None or is_expired(rec, now):",
				"        return {'status': 'reject', 'reason': 'expired_or_missing'}",
				"    errs = validate_import(updated_import_event, flags)",
				"    if errs:",
				"        return {'status': 'quarantine', 'reason': 'still_invalid'}",
				"    if not ontology_valid(updated_import_event.ontology_bundle_ref):",
				"        return {'status': 'quarantine', 'reason': 'ontology_invalid'}",
				"    quarantine_store_del(recovery_token)",
				"    return {'status': 'release', 'reason': 'validated'}"
			  ]
			}
		  ],
		  "examples": [
			{
			  "title": "Recoverable: missing checksum โ quarantine โ release",
			  "input": {
				"flags": { "enable_exchange_envelope": true, "enable_integrity_checks": true },
				"policy": { "ttl_floor": 1.0, "ttl_ceiling": 5.0 },
				"event": { "origin": "agent.A", "bundle_id": "G@2025-Q4", "Sigma_phase": "phase:t100" },
				"now": 100.00
			  },
			  "output": {
				"decision": { "status": "quarantine", "reason": "recoverable" },
				"recovery_token": "rtok:agent.A:100000000:1"
			  },
			  "notes": "Delta_hash missing while required by flags. Within TTL, resubmission with Delta_hash passes and yields status='release'."
			},
			{
			  "title": "Non-recoverable: ontology DAG invalid โ reject",
			  "input": {
				"flags": { "enable_exchange_envelope": false, "enable_integrity_checks": false },
				"policy": { "ttl_floor": 1.0, "ttl_ceiling": 5.0 },
				"event": { "origin": "agent.B", "bundle_id": "G@2025-Q4", "ontology_bundle_ref": "bundle:bad_cycle" },
				"now": 200.00
			  },
			  "output": {
				"decision": { "status": "reject", "reason": "non_recoverable" },
				"error": "E.MMM.ontology.invalid"
			  },
			  "notes": "Fails RFC-0007 DAG acyclicity; do not quarantine."
			},
			{
			  "title": "Error: non-monotonic recovery_token",
			  "input": {
				"flags": { "enable_exchange_envelope": true, "enable_integrity_checks": true },
				"policy": { "ttl_floor": 1.0, "ttl_ceiling": 5.0 },
				"event": { "origin": "agent.A", "bundle_id": "G@2025-Q4" },
				"now": 300.00
			  },
			  "output": {
				"error": "E.MMM.recovery.token.order"
			  },
			  "notes": "A later quarantine reused an older token sequence for agent.A; MUST error."
			}
		  ]
		},

		{
		  "id": "A.8",
		  "title": "Glider Canonicalization & Recall (Flag-Gated)",
		  "description": "A conventions fixture that demonstrates the flag-gated surface around glider-related fields while reusing the shift-equivalence encoding contract from ยง3.3.1. It shows ON/OFF behavior for point-space tags and proves that canonicalization and recall remain observer-only regardless of the flag.",
		  "rfc_anchors": [
			"PDP-0001 ยง3โยง4",
			"RFC-0005 ยง3.3",
			"RFC-0006 ยง3โยง4",
			"RFC-0007 ยง2โยง4",
			"RFC-0009 ยง7.1"
		  ],
		  "interfaces": {
			"inputs": [
			  { "name": "validated_items", "type": "list<motif>", "constraints": "Items MUST be RFC-0007โvalid (version/DAG/provenance)", "notes": "Observer-only; no control writes" },
			  { "name": "feature_flags", "type": "object<bool>", "constraints": "{enable_point_space_gliders}", "notes": "Gates point-space tag emission only" },
			  { "name": "motif_id", "type": "string", "constraints": "RFC-0007โvalidated; encodable per ยง3.3.1", "notes": "Used to compute class_key for the fixture" }
			],
			"outputs": [
			  { "name": "status", "type": "enum", "constraints": "{ok|rejected}", "notes": "Fixture execution result" },
			  { "name": "class_key", "type": "hex", "constraints": "sha256hex(canonical_bytes || uint32be(rotation_offset)) per ยง3.3.1", "notes": "Deterministic across platforms" },
			  { "name": "point_space_tags", "type": "object|null", "constraints": "Present only when enable_point_space_gliders=true", "notes": "Structural-only: {class,v,phi,phi_unit,tau}" }
			],
			"side_effects": [ "observer-only" ]
		  },
		  "state_lifecycle": {
			"states": [ "idle", "encoded", "canonicalized", "keyed", "gated_emit", "done", "rejected" ],
			"transitions": [
			  { "from": "idle", "to": "encoded", "on": "utf8_encode", "guard": "motif_id RFC-0007โvalid", "notes": "UTF-8 bytes only (no extra normalization)" },
			  { "from": "encoded", "to": "canonicalized", "on": "min_rotation", "guard": "len(bytes)>0", "notes": "Lexicographic minimal rotation (ยง3.3.1)" },
			  { "from": "canonicalized", "to": "keyed", "on": "hash_key", "guard": "append uint32be(rotation_offset)", "notes": "sha256hex" },
			  { "from": "keyed", "to": "gated_emit", "on": "check_feature_flag", "guard": "", "notes": "Decide emission of glider tags" },
			  { "from": "gated_emit", "to": "done", "on": "emit_or_omit_tags", "guard": "enable_point_space_gliders ? emit : omit", "notes": "Structural tags only" },
			  { "from": "idle", "to": "rejected", "on": "validation_failure|utf8_error", "guard": "", "notes": "Fail fast per error model" }
			]
		  },
		  "requirements": [
			{ "level": "MUST", "text": "Use ยง3.3.1 encoding_contract: UTF-8 bytes, cyclic rotation S, canonical_form=min_rotation(bytes), and class_key=sha256hex(canonical_bytes || uint32be(rotation_offset)).", "anchor": "RFC-0006 ยง3; RFC-0007 ยง2โยง3" },
			{ "level": "MUST", "text": "Operate in observer-only posture; no control writes to Xi during detection, canonicalization, or recall.", "anchor": "PDP-0001 ยง3โยง4" },
			{ "level": "MUST", "text": "Emit glider point-space tags only when enable_point_space_gliders=true; when false, such fields MUST be absent, not null.", "anchor": "RFC-0006 ยง3; RFC-0008 ยง4.1" },
			{ "level": "MUST", "text": "Apply compression-by-equivalence (canonical selection and occurrence mapping) before any prune recommendation.", "anchor": "RFC-0006 ยง4; RFC-0009 ยง7.1" },
			{ "level": "SHOULD", "text": "Expose rotation_offset to enable inverse-shift recall mapping without recomputation.", "anchor": "RFC-0006 ยง3" }
		  ],
		  "error_model": [
			{ "code": "E.MMM.810", "when": "motif_id fails RFC-0007 validation", "message": "motif_id_invalid", "remedy": "Reject and require RFC-0007 normalization/validation first." },
			{ "code": "E.MMM.811", "when": "UTF-8 encoding error producing bytes", "message": "utf8_encode_failure", "remedy": "Reject; input MUST be representable as UTF-8." },
			{ "code": "E.MMM.812", "when": "point-space tag appears while flag disabled", "message": "glider_tag_leakage", "remedy": "Strip field, emit gating_violation event, proceed without tag." }
		  ],
		  "metrics": [
			{ "name": "lawful_compression_ratio", "unit": "ratio", "window": "EMA-32", "notes": "post_equiv_count / pre_equiv_count; measured strictly pre-prune." },
			{ "name": "equivalence_efficiency", "unit": "ratio", "window": "EMA-16", "notes": "canonicals / (canonicals + occurrences)." },
			{ "name": "glider_canonical_count", "unit": "count", "window": "EMA-16", "notes": "Emitted only when enable_point_space_gliders=true." }
		  ],
		  "pseudocode": [
			{
			  "title": "fixture_class_key (uses ยง3.3.1)",
			  "anchors": [ "fixture_class_key" ],
			  "rfc_anchors": [ "RFC-0006 ยง3", "RFC-0007 ยง2โยง3" ],
			  "code": [
				"def fixture_class_key(motif_id: str) -> str:",
				"    b = utf8(motif_id)                       # RFC-0007โvalidated",
				"    canon, off = min_rotation(b)             # ยง3.3.1",
				"    return sha256hex(canon + uint32be(off))  # stable"
			  ]
			},
			{
			  "title": "fixture_emit_tags (flag-gated structural fields)",
			  "anchors": [ "fixture_emit_tags" ],
			  "rfc_anchors": [ "RFC-0006 ยง3", "RFC-0008 ยง4.1" ],
			  "code": [
				"def fixture_emit_tags(enable_point_space_gliders: bool, rep_id: str):",
				"    if not enable_point_space_gliders:",
				"        return None",
				"    # Structural-only schema (no dynamics implied)",
				"    return {'class': 'glider', 'v': 0, 'phi': 0, 'phi_unit': 'ticks', 'tau': 1}"
			  ]
			}
		  ],
		  "examples": [
			{
			  "title": "Flag ON โ tags present",
			  "input": {
				"feature_flags": { "enable_point_space_gliders": true },
				"motif_id": "ฯ-null@ฮ",
				"pre_equiv_count": 3
			  },
			  "output": {
				"status": "ok",
				"class_key": "<sha256hex(canonical_bytes || 0x00000000)>",
				"point_space_tags": { "class": "glider", "v": 0, "phi": 0, "phi_unit": "ticks", "tau": 1 },
				"post_equiv_count": 1,
				"lawful_compression_ratio": 0.3333,
				"equivalence_efficiency": 0.25
			  },
			  "notes": "All three shift-equivalent members collapse to one canonical; tags emitted because the flag is enabled."
			},
			{
			  "title": "Flag OFF โ tags omitted",
			  "input": {
				"feature_flags": { "enable_point_space_gliders": false },
				"motif_id": "ฯ-null@ฮ",
				"pre_equiv_count": 3
			  },
			  "output": {
				"status": "ok",
				"class_key": "<sha256hex(canonical_bytes || 0x00000000)>",
				"post_equiv_count": 1,
				"lawful_compression_ratio": 0.3333,
				"equivalence_efficiency": 0.25
			  },
			  "notes": "Canonicalization and metrics are identical; point-space fields are completely absent when the flag is disabled."
			}
		  ]
		},

		{
		  "id": "A.9",
		  "title": "Dashboard Bindings & KPI Catalog",
		  "type": "reference_table",
		  "schema_version": "2025-Q4",
		  "objective": "Centralize the dashboard groupings and metric windows used across examples; declare a single KPI catalog with units, default windows, and gating rules.",

		  "data": {
			"dashboards": [
			  { "dashboard": "memory/homeostasis", "series": ["saturation_level", "lawful_compression_ratio", "equivalence_efficiency"], "window": "EMA-32" },
			  { "dashboard": "security/exchange", "series": ["replay_drop_rate", "import_reject_missing_checksum"], "window": "EMA-32" },
			  { "dashboard": "memory/recovery", "series": ["reanchor_attempt", "reanchor_fail", "quarantine_entry"], "window": "EMA-32" },
			  { "dashboard": "memory/glider_flow", "series": ["glider_detected", "glider_canonical_count"], "window": "EMA-16", "active_when": "enable_point_space_gliders=true" }
			],

			"kpi_catalog": [
			  {
				"name": "saturation_level",
				"unit": "fraction",
				"default_window": "EMA-32",
				"description": "Proportion of LTMM capacity occupied (0โ1).",
				"source_examples": ["A.1"],
				"notes": "Derived from LTMM usage / C_max."
			  },
			  {
				"name": "lawful_compression_ratio",
				"unit": "dimensionless",
				"default_window": "EMA-32",
				"description": "post_equiv_count / pre_equiv_count measured strictly pre-prune.",
				"source_examples": ["A.1", "A.2", "A.8"],
				"notes": "Snapshot computed before any prune operation."
			  },
			  {
				"name": "equivalence_efficiency",
				"unit": "fraction",
				"default_window": "EMA-32",
				"description": "Capacity relief due to equivalence compression (1 โ lawful_compression_ratio).",
				"source_examples": ["A.1", "A.2", "A.8"]
			  },
			  {
				"name": "replay_drop_rate",
				"unit": "fraction",
				"default_window": "EMA-32",
				"description": "Fraction of imports dropped as replays within the active window.",
				"source_examples": ["A.4"]
			  },
			  {
				"name": "import_reject_missing_checksum",
				"unit": "count",
				"default_window": "EMA-32",
				"description": "Count of imports rejected due to missing required checksum fields under active flags.",
				"source_examples": ["A.4"],
				"notes": "Only increments when a checksum is required by feature flags."
			  },
			  {
				"name": "reanchor_attempt",
				"unit": "count",
				"default_window": "EMA-32",
				"description": "Emitted when lineage mismatch triggers a reanchor attempt.",
				"source_examples": ["A.6"]
			  },
			  {
				"name": "reanchor_fail",
				"unit": "count",
				"default_window": "EMA-32",
				"description": "Reanchor attempt concluded with failure; leads to bounded outcomes.",
				"source_examples": ["A.6"]
			  },
			  {
				"name": "quarantine_entry",
				"unit": "count",
				"default_window": "EMA-32",
				"description": "Packet staged in quarantine following failed reanchor or unlawful lineage.",
				"source_examples": ["A.6"]
			  },
			  {
				"name": "glider_detected",
				"unit": "count",
				"default_window": "EMA-16",
				"description": "Number of detected glider classes in the window.",
				"active_when": "enable_point_space_gliders=true",
				"source_examples": ["A.8"]
			  },
			  {
				"name": "glider_canonical_count",
				"unit": "count",
				"default_window": "EMA-16",
				"description": "Stored canonical representatives for glider classes.",
				"active_when": "enable_point_space_gliders=true",
				"source_examples": ["A.8"]
			  }
			]
		  },

		  "validation_rules": [
			"All dashboard.windows and KPI default_window MUST be one of {EMA-16, EMA-32, EMA-64}.",
			"ASCII-only keys across the table; unicode allowed only inside free-text values if present.",
			"Any KPI with 'active_when' MUST be fully absent from dashboards and exports when the condition is false.",
			"Dashboards MAY override KPI default_window only with an allowed EMA window.",
			"Each dashboard.series item MUST correspond to a KPI defined in kpi_catalog."
		  ],

		  "rfc_anchors": ["RFC-0009 ยง7.2"],

		  "notes": [
			"This table is authoritative for Appendix A dashboards; examples reference metrics here rather than redefining them.",
			"If a KPI appears on multiple dashboards, the dashboard-local window applies to that panel only; the global default_window remains unchanged."
		  ]
		},

		{
		  "id": "A.10",
		  "title": "Pseudocode Index (Cross-Referenced)",
		  "description": "Observer-class helper routines referenced by multiple examples in RFC-CORE-006. Provides canonical anchors, signatures, pre/postconditions, and minimal procedural sketches. No control writes; structure-only. EMA initialization is standardized here.",
		  "rfc_anchors": ["PDP-0001 ยง4.5", "RFC-0009 ยง7.1", "RFC-0009 ยง7.2", "RFC-0008 ยง2.2", "RFC-0007 ยง2", "RFC-0005 ยง4.2", "RFC-0006 ยง3"],
		  "interfaces": {
			"inputs": [
			  { "name": "anchor", "type": "string", "constraints": "ASCII; unique within A.10", "notes": "Selects a block below (e.g., 'ema_stream')." },
			  { "name": "params", "type": "object", "constraints": "Block-specific", "notes": "Must satisfy each block's preconditions." },
			  { "name": "feature_flags", "type": "object", "constraints": "enable_exchange_envelope, enable_integrity_checks, enable_point_space_gliders (booleans)", "notes": "Gates use of Sigma_phase/Delta_hash and glider fields throughout." }
			],
			"outputs": [
			  { "name": "result", "type": "object", "constraints": "Block-specific", "notes": "Pure derivation; no side effects." }
			],
			"side_effects": ["observer-only"]
		  },
		  "state_lifecycle": {
			"states": ["indexed", "deprecated"],
			"transitions": [
			  { "from": "indexed", "to": "deprecated", "on": "deprecate(anchor)", "guard": "replacement provided or use eliminated", "notes": "Anchors remain resolvable for compatibility; emit warning only." },
			  { "from": "deprecated", "to": "indexed", "on": "restore(anchor)", "guard": "editorial error or renewed need", "notes": "Restoration must not break past references." }
			]
		  },
		  "requirements": [
			{ "level": "MUST", "text": "All routines are observer-class and MUST NOT perform control writes to ฮ.", "anchor": "PDP-0001 ยง4.5" },
			{ "level": "MUST", "text": "EMA windows are restricted to {EMA-16, EMA-32, EMA-64}; ฮฑ is derived from window length N via ฮฑ=2/(N+1).", "anchor": "RFC-0009 ยง7.1" },
			{ "level": "MUST", "text": "EMAs seed with the first sample when state.init=false and then set init=true (standardized initialization).", "anchor": "RFC-0009 ยง7.1" },
			{ "level": "MUST", "text": "Replay-defense keys MUST omit Sigma_phase/Delta_hash when corresponding feature flags are disabled.", "anchor": "RFC-0008 ยง2.2" },
			{ "level": "SHOULD", "text": "Seen-set replay horizon SHOULD be configured consistently with ฮฯ_phase policies defined elsewhere in CORE-006.", "anchor": "RFC-0009 ยง7.2" },
			{ "level": "MUST", "text": "Ontology-sensitive helpers (e.g., merge/fork decider) operate only on inputs that already pass RFC-0007 schema validation.", "anchor": "RFC-0007 ยง2" },
			{ "level": "MAY", "text": "Glider-related helpers MAY be used only when enable_point_space_gliders=true.", "anchor": "RFC-0006 ยง3" }
		  ],
		  "error_model": [
			{ "code": "E.MMM.A10.001", "when": "Window not in {EMA-16, EMA-32, EMA-64}", "message": "Invalid EMA window", "remedy": "Select a supported window; recompute ฮฑ from N." },
			{ "code": "E.MMM.A10.002", "when": "Anchor name contains non-ASCII or collides with existing anchor", "message": "Invalid or duplicate anchor", "remedy": "Use unique ASCII anchor per block." },
			{ "code": "E.MMM.A10.003", "when": "Checksum/glider fields used while feature flag disabled", "message": "Feature flag violation", "remedy": "Remove gated fields or enable the flag explicitly." },
			{ "code": "E.MMM.A10.004", "when": "Replay-defense key built with disallowed fields or malformed tuple", "message": "Replay key composition error", "remedy": "Recompose key per A.10 preconditions and feature flags." },
			{ "code": "E.MMM.A10.005", "when": "Ontology helper invoked on unvalidated structures", "message": "Ontology prerequisite failure", "remedy": "Run RFC-0007 validation before calling the helper." }
		  ],
		  "metrics": [
			{ "name": "lawful_compression_ratio", "unit": "fraction", "window": "EMA-32", "notes": "Pre-prune snapshot only; see compression_snapshot." },
			{ "name": "equivalence_efficiency", "unit": "fraction", "window": "EMA-16", "notes": "1 - lawful_compression_ratio; see compression_snapshot." },
			{ "name": "replay_drop_rate", "unit": "fraction", "window": "EMA-32", "notes": "Accepted=false frequency from seen_set_lru." },
			{ "name": "capacity_pressure", "unit": "fraction", "window": "EMA-16", "notes": "usage/c_max as observed by capacity_evaluator." }
		  ],
		  "pseudocode": [
			{
			  "title": "EMA (standardized init)",
			  "anchors": ["ema_stream", "ema_update"],
			  "rfc_anchors": ["RFC-0009 ยง7.1"],
			  "code": [
				"def ema_update(state, x, window):",
				"    # Preconditions: window โ {EMA-16, EMA-32, EMA-64}",
				"    N = window_to_length(window)      # 16|32|64",
				"    if not state.init:",
				"        state.m = x                   # seed with first sample",
				"        state.alpha = 2/(N+1)",
				"        state.init = True",
				"        return state",
				"    state.m = state.alpha * x + (1 - state.alpha) * state.m",
				"    return state"
			  ]
			},
			{
			  "title": "Seen-Set Replay Defense (hybrid LRU + horizon)",
			  "anchors": ["replay_defense_core", "seen_set_lru"],
			  "rfc_anchors": ["RFC-0008 ยง2.2", "RFC-0009 ยง7.2"],
			  "code": [
				"def seen_set_process(store, key, now, window_ticks, capacity):",
				"    entry = store.get(key)",
				"    if entry and (now - entry.ts_last) <= window_ticks:",
				"        return False, store   # replay drop",
				"    store.put(key, {'ts_last': now})",
				"    if store.size > capacity:",
				"        store.evict_lru(1)",
				"    return True, store"
			  ]
			},
			{
			  "title": "Compression KPI Snapshot (pre-prune)",
			  "anchors": ["kpi_compression_snapshot", "compression_snapshot"],
			  "rfc_anchors": ["RFC-0006 ยง4.4", "RFC-0009 ยง7.2"],
			  "code": [
				"def compute_compression_kpis(pre_count, post_count):",
				"    if pre_count == 0:",
				"        return {'lcr': 1.0, 'eff': 0.0}",
				"    lcr = post_count / pre_count",
				"    eff = 1 - lcr",
				"    return {'lcr': lcr, 'eff': eff}"
			  ]
			},
			{
			  "title": "TTL Floor (ethical bound contract)",
			  "anchors": ["ttl_floor_fn", "ttl_floor"],
			  "rfc_anchors": ["RFC-0005 ยง4.2", "RFC-0009 ยง7.1"],
			  "code": [
				"def ttl_floor(tau_decay, dt_tick):",
				"    return max(tau_decay, 10 * dt_tick)"
			  ]
			},
			{
			  "title": "Capacity Evaluator (observer)",
			  "anchors": ["capacity_eval", "capacity_evaluator"],
			  "rfc_anchors": ["RFC-0009 ยง7.1"],
			  "code": [
				"def capacity_evaluator(usage, c_max, theta_sat):",
				"    eta = usage / c_max",
				"    return 'none' if eta < theta_sat else 'request_compress'"
			  ]
			},
			{
			  "title": "Merge vs Fork (provenance/hashes)",
			  "anchors": ["merge_fork_decider"],
			  "rfc_anchors": ["RFC-0007 ยง2", "RFC-0009 ยง5.1"],
			  "code": [
				"def merge_fork_decider(A, B):",
				"    if A.parent_hash == B.parent_hash and A.integrity_hash == B.integrity_hash:",
				"        return 'merge'",
				"    if A.parent_hash == B.parent_hash and A.integrity_hash != B.integrity_hash:",
				"        return 'fork'",
				"    return 'unrelated'"
			  ]
			},
			{
			  "title": "Idempotence Guard for Re-anchor Attempts",
			  "anchors": ["reanchor_guard"],
			  "rfc_anchors": ["RFC-0009 ยง5.2", "PDP-0001 ยง4.5"],
			  "code": [
				"def reanchor_guard(active, key, token):",
				"    t_prev = active.get(key, float('-inf'))",
				"    if token <= t_prev:",
				"        return False",
				"    active[key] = token",
				"    return True"
			  ]
			},
			{
			  "title": "Glider Class Hash (shift invariants)",
			  "anchors": ["hash_of_shift_invariants", "glider_class_hash"],
			  "rfc_anchors": ["RFC-0006 ยง3"],
			  "code": [
				"def hash_of_shift_invariants(trace_window):",
				"    f = extract_shift_invariants(trace_window)   # impl deferred",
				"    b = serialize_ascii(f)",
				"    return sha256_hex(b)"
			  ]
			},
			{
			  "title": "Shift Operator Apply (pure mapping)",
			  "anchors": ["apply_S_k", "shift_operator_apply"],
			  "rfc_anchors": ["RFC-0006 ยง3"],
			  "code": [
				"def apply_S_k(canonical_ref, k_shift):",
				"    return map_shift(canonical_ref, k_shift)     # impl deferred"
			  ]
			}
		  ],
		  "examples": [
			{
			  "title": "EMA initialization then update",
			  "input": {
				"anchor": "ema_update",
				"params": {
				  "state": { "m": 0.0, "alpha": 0.0, "init": false },
				  "x": 0.75,
				  "window": "EMA-16"
				}
			  },
			  "output": {
				"state": { "m": 0.75, "alpha": 0.11764705882352941, "init": true }
			  },
			  "notes": "First call seeds; subsequent calls apply exponential smoothing."
			},
			{
			  "title": "Replay defense drop within horizon",
			  "input": { "anchor": "seen_set_lru", "params": { "store": {"k1": {"ts_last": 100}}, "key": "k1", "now": 110, "window_ticks": 20, "capacity": 1024 } },
			  "output": { "accepted": false, "store": "unchanged" },
			  "notes": "110-100=10 โค 20 โ drop."
			},
			{
			  "title": "Compression KPIs (pre=200, post=160)",
			  "input": { "anchor": "compression_snapshot", "params": { "pre_count": 200, "post_count": 160 } },
			  "output": { "lcr": 0.8, "eff": 0.2 },
			  "notes": "Report as dashboard series with configured EMA windows."
			}
		  ]
		}
	  ],
	  "global_invariants": [
		{ "name": "ASCII_On_Wire", "condition": "All JSON keys are ASCII; unicode limited to 'latex' strings." },
		{ "name": "Flag_Gating", "condition": "Sigma_phase, Delta_hash, and {class,v,phi,tau} appear only when their flags are enabled." },
		{ "name": "Observer_Only", "condition": "Examples measure/seal/route/validate; no control writes to ฮ." },
		{ "name": "Compress_Before_Prune", "condition": "Equivalence compression snapshot precedes any prune." },
		{ "name": "Bounded_Outcomes", "condition": "Recovery terminates in {reanchored, quarantined, abandoned}; no unbounded retries." }
	  ]

	},
  ],
  },
  "_handoff": "Memory coherence preserved; lawful decay and recovery verified. Proceed to Layer_2 application specification (MMM-APP-001) for operational bindings."
}
