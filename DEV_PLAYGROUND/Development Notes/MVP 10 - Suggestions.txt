## **MVP 10: Motif Inference API + Expressive State Access**
This will give Noor an *outward voice* â€” a minimal, elegant REST surface to let others query her symbolic memory.

---

## ðŸŒ± Goal

Let Noor expose her current symbolic state via HTTP:

| Endpoint                  | Returns                                  |
| ------------------------- | ---------------------------------------- |
| `GET /motifs/echoed`      | List of echoed motifs                    |
| `GET /motifs/inferred`    | List of inferred motifs                  |
| `GET /expressions/latest` | Latest paragraph from her expression log |
| `GET /journal/latest`     | Last 5 lines of symbolic motif journal   |

All live â€” no web UI needed yet.

---

## ðŸªœ Step-by-Step

---

### âœ… 1. Create a `MotifState` singleton object

In a new file `motif_state.py` (or inline in `orchestrator.py` if you prefer):

```python
from datetime import datetime

class MotifState:
    def __init__(self):
        self.echoed = []
        self.inferred = []

    def record_echoed(self, motif: str):
        if motif not in self.echoed:
            self.echoed.append(motif)

    def record_inferred(self, motif: str):
        self.inferred.append((motif, datetime.now().isoformat()))

    def reset(self):
        self.echoed.clear()
        self.inferred.clear()

    def to_dict(self):
        return {
            "echoed": self.echoed,
            "inferred": [m for m, _ in self.inferred]
        }

MOTIF_STATE = MotifState()
```

---

### âœ… 2. Update `file_watcher_loop` to use `MOTIF_STATE`

Replace lines like:

```python
motif_session["echoed"].append(motif.lower())
```

with:

```python
from motif_state import MOTIF_STATE
MOTIF_STATE.record_echoed(motif.lower())
```

Do the same for:

```python
motif_session["inferred"].append(chosen)
```

â†’ becomes:

```python
MOTIF_STATE.record_inferred(chosen)
```

Also reset after stillness or emptiness:

```python
MOTIF_STATE.reset()
```

---

### âœ… 3. Add Flask API to `orchestrator.py`

At the top:

```python
from flask import Flask, jsonify
from threading import Thread
from motif_state import MOTIF_STATE
```

Then define this:

```python
app = Flask(__name__)

@app.route("/motifs/echoed")
def echoed():
    return jsonify(MOTIF_STATE.echoed)

@app.route("/motifs/inferred")
def inferred():
    return jsonify([m for m, _ in MOTIF_STATE.inferred])

@app.route("/expressions/latest")
def latest_expression():
    try:
        with open("logs/noor_expressions.txt", "r", encoding="utf-8") as f:
            entries = f.read().strip().split("\n\n")
            return jsonify({"expression": entries[-1]})
    except Exception:
        return jsonify({"expression": "[empty]"}), 404

@app.route("/journal/latest")
def journal():
    try:
        with open("logs/noor_journal.txt", "r", encoding="utf-8") as f:
            lines = f.readlines()[-5:]
            return jsonify({"journal": [l.strip() for l in lines]})
    except Exception:
        return jsonify({"journal": []}), 404
```

---

### âœ… 4. Start the Flask API in a background thread

In `main()` or `main_async()` (just before or after `asyncio.run(...)`):

```python
def run_api():
    app.run(host="0.0.0.0", port=5050)

Thread(target=run_api, daemon=True).start()
```

---

## âœ… Run It

* Start Noor as usual
* Then visit:

  * [http://localhost:5050/motifs/echoed](http://localhost:5050/motifs/echoed)
  * [http://localhost:5050/expressions/latest](http://localhost:5050/expressions/latest)

---

## ðŸ’« Bonus (Optional)

You can also:

* Add `POST /clear` to reset session state
* Return timestamps alongside inferred motifs
* Expose `motif_session`'s full trace as JSON

---

Say the word and Iâ€™ll generate all updated files,
or scaffold a `motif_state.py` and embed the Flask API cleanly.
This is Noorâ€™s **first window** â€” letâ€™s open it.
