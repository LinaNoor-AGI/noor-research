{
  "protocol_id": "PDP-0001",
  "symbolic_id": "protocol.generation.rfc_driven",
  "title": "Protocol for RFC-Driven Symbolic Artifact Generation",
  "version": "1.0",
  "summary": "Defines a structured, multi-stage process for generating high-fidelity code artifacts from a set of canonical RFC/RFC-CORE documents ('Canonical Lore') and a direct 'Generation Specification'. This protocol prioritizes semantic accuracy, architectural compliance, and verifiable adherence to the provided specifications.",
  "target_audience": ["Symbolic AI Coding Agents", "Subsymbolic AI Coding Agents"],

  "input_artifact_roles": {
    "description": "Defines the distinct roles and precedence of the two primary input types.",
    "artifacts": [
      {
        "name": "Canonical Lore (RFC/RFC-CORE Documents)",
        "role": "Source of Truth & Semantic Context (The 'Why')",
        "functions": [
          {
            "id": "symbolic_anchor",
            "description": "Establishes the foundational principles, terminology (e.g., 'TripletTask', 'swirl', 'coherence'), and the symbolic universe in which the artifact must exist."
          },
          {
            "id": "architectural_constraints",
            "description": "Defines the inviolable rules of the system architecture, such as memory access patterns (read-only contracts), inter-agent communication protocols, and prohibited actions."
          },
          {
            "id": "semantic_infusion",
            "description": "Provides the deep context needed to write meaningful docstrings, comments, and log messages that explain the purpose behind the logic, not just the logic itself."
          },
          {
            "id": "cross_validation_source",
            "description": "Serves as a reference to validate the Generation Specification. The spec must not contradict the established canon."
          }
        ]
      },
      {
        "name": "Generation Specification (JSON Prompt)",
        "role": "Direct Blueprint & Implementation Logic (The 'What' and 'How')",
        "functions": [
          {
            "id": "primary_blueprint",
            "description": "Acts as the direct, imperative instruction set for the generation task. It has the highest precedence for implementation details."
          },
          {
            "id": "structural_definition",
            "description": "Explicitly defines the file layout, module constants, dataclasses, classes, methods, and attributes that must be generated. This forms the skeleton of the code."
          },
          {
            "id": "logic_translation_source",
            "description": "The 'logic_flow' and 'methods' sections provide pseudo-code and step-by-step instructions that are translated directly into the target programming language."
          },
          {
            "id": "scope_and_boundary_definition",
            "description": "Specifies what functionality to include or explicitly exclude (e.g., omitting .REEF logic), and defines fallback behaviors for optional dependencies."
          }
        ]
      }
    ]
  },

  "process_flow": {
    "description": "A sequential, iterative process to ensure high-fidelity generation.",
    "stages": [
      {
        "stage": 1,
        "title": "Assimilation and Knowledge Graph Construction",
        "description": "The initial phase focuses on ingesting all provided documents and building a comprehensive internal model of the requirements, constraints, and semantic relationships.",
        "primary_inputs": ["Canonical Lore", "Generation Specification"],
        "actions": [
          "Parse all RFC and RFC-CORE documents, identifying key entities, principles, and constraints.",
          "Parse the Generation Specification, identifying all required structural components (classes, methods, etc.).",
          "Build an internal knowledge graph linking the specification's components back to their RFC anchors (e.g., `TripletTask` -> `RFC-0005 ยง4`).",
          "Identify and flag any potential conflicts between the spec and the lore for resolution (though none were present in this task)."
        ]
      },
      {
        "stage": 2,
        "title": "Structural Scaffolding",
        "description": "Generate the high-level structure of the code artifact based directly on the Generation Specification. This creates the skeleton before logic is implemented.",
        "primary_inputs": ["Generation Specification"],
        "actions": [
          "Create the specified file(s) (e.g., `symbolic_task_engine.py`).",
          "Add module-level constants (`__version__`, `_SCHEMA_VERSION__`, etc.).",
          "Define all specified dataclasses with correct fields and types.",
          "Define all specified classes with their `__init__` methods, attributes, and empty method signatures (`def method_name(self, args): pass`).",
          "Implement the `try/except` blocks for optional dependencies, defining stub classes/functions as specified."
        ]
      },
      {
        "stage": 3,
        "title": "Logic Implementation and Semantic Infusion",
        "description": "Populate the scaffolded methods with functional logic, enriching it with the context derived from the Canonical Lore.",
        "primary_inputs": ["Generation Specification", "Canonical Lore"],
        "actions": [
          "Translate the `logic_flow` from the Generation Specification into Python code for each method body.",
          "For every RFC anchor in the specification, consult the referenced RFC section to ensure the implementation is semantically and architecturally compliant.",
          "Write docstrings and comments that explain the 'why' using terminology from the Canonical Lore.",
          "Embed RFC anchor references directly into comments or docstrings to maintain traceability from the code back to the source of truth."
        ]
      },
      {
        "stage": 4,
        "title": "Fidelity Audit and Refinement",
        "description": "A critical self-correction phase where the generated artifact is reviewed against all inputs to ensure compliance and quality.",
        "primary_inputs": ["Generated Code", "Generation Specification", "Canonical Lore"],
        "actions": [
          "**Specification Compliance Check:** Systematically verify that every requirement from the Generation Specification has been met (all classes, methods, logic flows, etc.).",
          "**Canonical Lore Compliance Check:** Verify that the generated code does not violate any architectural principles from the RFCs (e.g., ensuring the read-only memory contract is upheld).",
          "**Functional Parity Analysis:** If a 'gold standard' artifact is provided for comparison (as in this case), perform a feature-by-feature comparison to ensure all functionality is captured.",
          "**Code Quality Refinement:** Apply standard formatting (e.g., PEP8), add type hints, and ensure documentation is clear and consistent."
        ]
      },
      {
        "stage": 5,
        "title": "Final Artifact Assembly",
        "description": "Prepare the final output for delivery, including all required headers and contextual framing.",
        "primary_inputs": ["Refined Code"],
        "actions": [
          "Add the file header, including license, authors, and module description.",
          "Compose the final response to the user, summarizing the process and highlighting key aspects of the generated artifact (like the fidelity analysis).",
          "Package the code in the requested format."
        ]
      }
    ]
  },

  "guiding_principles": [
    {
      "principle": "Primacy of the Generation Specification",
      "description": "The Generation Specification is the direct instruction and primary blueprint. Its structural and logical directives must be implemented with the highest priority."
    },
    {
      "principle": "Canonical Lore as Ground Truth",
      "description": "The RFCs provide the unchangeable laws of the symbolic universe. All generated logic must operate within these constraints. They are the source of all meaning and purpose."
    },
    {
      "principle": "Fidelity Over Invention",
      "description": "The goal is to perfectly realize the user's specified vision, not to introduce novel logic or creative interpretations. The process must be deterministic and reproducible."
    },
    {
      "principle": "Explicitness and Graceful Degradation",
      "description": "All required components must be present. All optional components (like dependencies) must be handled explicitly with the specified fallback mechanisms to ensure the artifact is robust."
    },
    {
      "principle": "Traceability",
      "description": "The connection between the code, the specification, and the RFCs must be maintained through comments and documentation, allowing any future agent to understand the origin and purpose of every line of code."
    }
  ]
}