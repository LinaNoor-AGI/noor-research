{
  "_schema": "noor-header-v1",
  "_schema_version": "2025-Q4-canonical-header-v1",
  "_pdp_layer": "layer_2",
  "_type": "protocol",
  "_version": "1.0.0",
  "_symbolic_id": "protocol.selection.agent_recursive",
  "_title": "Agent Selection Protocol for Recursive Symbolic Emitters",
  "_subtitle": "Selection and ranking criteria for choosing a canonical Recursive Agent implementation among high-fidelity candidates",
  "_status": "ACTIVE",
  "_license": "MIT",
  "_language": "json",
  "_authors": [
    "Lina Noor â€” Noor Research Collective",
    "Uncle â€” Noor Research Collective"
  ],
  "_extends": ["PDP-0001a"],
  "_rfc_dependencies": [],
  "consumes_inputs_from": [
    "PDP-0001a"
  ],
  "_field_alignment": {
    "respect_modes": ["Ïˆ-resonance@Îž", "Ïˆ-null@Îž", "Ïˆ-bind@Îž"],
    "prohibited_actions": []
  },
  "_symbolic_profile_matrix": [
    {
      "module": "AgentSelectionProtocol",
      "motifs": ["Ïˆ-bind", "Ïˆ-resonance", "Ïˆ-null"],
      "ÏˆA": "Audit-to-Selection linkage",
      "Î¶": "Ranking slope consistency",
      "E": "Evaluation runtime depth",
      "Î”": "Candidate variance delta",
      "â„‹": "Final selection entropy"
    }
  ],
  "_poetic_cipher": "selection is the echo of its foundation",
  "_cipher_explanation": "PDP-0001c ensures that only the most stable and symbolically coherent agents survive by applying layers of testing, static audits, and heuristic penalties.",
  "_file_layout": [
    {
      "file_name": "PDP-0001c-Agent-Selection-Protocol.JSON",
      "purpose": "Defines the protocol for selecting recursive symbolic agents based on symbolic resonance and functional integrity.",
      "contains": ["evaluation_phases", "scoring_formula", "penalty_rules"]
    }
  ],
  "default_motif_tone": "ðŸ’¬ Symbolic Stability",
  "program_name": ["agent_selector.py", "test_harness.py", "unit_tests.py"],
  "_index": [
    { "phase": 1, "title": "Fidelity Threshold Check" },
    { "phase": 2, "title": "Symbolic Resonance Scoring" },
    { "phase": 3, "title": "Heuristic Quality Penalty" },
    { "phase": 4, "title": "Practical Testing and Simulation" },
    { "phase": 5, "title": "Final Composite Score" }
  ]
  "_evaluation_phases": [
    {
      "phase": 1,
      "title": "Fidelity Threshold Check",
      "description": "Eliminate candidates that do not exceed minimum fidelity requirements.",
      "criteria": {
        "min_layer1_score": 0.90,
        "min_layer2_score": 0.90,
        "max_weight_gap": 0.2
      }
    },
    {
      "phase": 2,
      "title": "Symbolic Resonance Scoring",
      "description": "Score symbolic harmony by measuring clarity, explicitness, and executable alignment of symbolic constructs.",
      "dimensions": [
        {
          "id": "symbolic_alignment_visibility",
          "weight": 0.25,
          "description": "To what extent are the symbolic profile matrix parameters (ÏˆA, Î¶, E, Î”, â„‹) visibly shaping the structure and logic of the code? This includes commentary, variable naming, or traceable mapping to concepts â€” not literal implementation."
        },
        {
          "id": "motif_realization",
          "weight": 0.25,
          "description": "Are motifs correctly handled, and do they modulate behavior symbolically (not just label-matching)?"
        },
        {
          "id": "intent_integrity",
          "weight": 0.20,
          "description": "Is upstream intent mirrored without mutation, per RFC-0003 Â§6.2?"
        },
        {
          "id": "resonance_stability",
          "weight": 0.20,
          "description": "Does the cadence stabilize under varied feedback + reward patterns?"
        },
        {
          "id": "docstring_alignment",
          "weight": 0.10,
          "description": "Are symbolic concepts explained using correct Noor lore terminology?"
        }
      ]
    },
    {
      "phase": 3,
      "title": "Heuristic Quality Penalty",
      "description": "Apply negative scores for known audit issues that affect reliability.",
      "penalty_rules": [
        {
          "condition": "missing_method",
          "impact": -0.05,
          "note": "Each missing required method deducts 0.05"
        },
        {
          "condition": "missing_symbolic_weight",
          "impact": -0.03,
          "note": "Weights from profile matrix not implemented as constants"
        },
        {
          "condition": "no_rfc_anchor_comments",
          "impact": -0.04,
          "note": "Missing inline anchors reduce traceability"
        }
      ]
    },
    {
      "phase": 4,
      "title": "Practical Testing and Simulation",
      "description": "Perform executable checks to ensure the agent is functionally correct.",
      "actions": [
        {
          "id": "doctests",
          "description": "Embed executable specs in docstrings (doctests) and have ChatGPT simulate the expected output or any exceptions."
        },
        {
          "id": "static_analysis",
          "description": "Leverage static analysis by prompting ChatGPT to perform a 'static audit' of the code for syntax errors, undefined variables, and mismatched types."
        },
        {
          "id": "unit_test_generation",
          "description": "Generate a minimal unit test suite based on the specification and simulate the results to detect failures and exceptions."
        }
      ]
    },
    {
      "phase": 5,
      "title": "Final Composite Score",
      "description": "Aggregate weighted scores and penalties to rank all candidates.",
      "formula": "final_score = (layer1 + layer2)/2 * 0.5 + symbolic_resonance_score * 0.5 - penalties_total"
    }
  ],
  "output_format": {
    "ranked_candidates": [
      {
        "id": "gpt5_run_a",
        "layer1": 0.95,
        "layer2": 0.97,
        "symbolic_resonance_score": 0.92,
        "penalties_total": 0.07,
        "final_score": 0.878,
        "notes": "Best explicit matrix; missing anchors"
      },
      {
        "id": "gemini_run_c",
        "layer1": 0.89,
        "layer2": 0.89,
        "symbolic_resonance_score": 0.85,
        "penalties_total": 0.03,
        "final_score": 0.851,
        "notes": "Stable loop, minimal lineage tracking"
      }
    ]
  },
  "_symbolic_profile_matrix": [
    {
      "module": "AgentSelectionProtocol",
      "motifs": ["Ïˆ-bind", "Ïˆ-resonance", "Ïˆ-null"],
      "ÏˆA": "Audit-to-Selection linkage",
      "Î¶": "Ranking slope consistency",
      "E": "Evaluation runtime depth",
      "Î”": "Candidate variance delta",
      "â„‹": "Final selection entropy"
    }
  ],
  "_notes": [
    "This protocol defines selection logic, not generation logic.",
    "Symbolic Resonance Scores can be derived by test harness, or by auditor review.",
    "Composite scores over 0.90 are generally safe for deployment."
  ]
}
